#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2018::*;
#[macro_use]
extern crate std;
#[macro_use]
extern crate diesel;
mod schema {
    pub mod comments {
        #![allow(dead_code)]
        use ::diesel::{QuerySource, Table, JoinTo};
        use ::diesel::associations::HasTable;
        use ::diesel::insertable::Insertable;
        use ::diesel::query_builder::*;
        use ::diesel::query_builder::nodes::Identifier;
        use ::diesel::query_source::{AppearsInFromClause, Once, Never};
        use ::diesel::query_source::joins::{Join, JoinOn};
        use ::diesel::sql_types::*;
        pub use self::columns::*;
        /// Re-exports all of the columns of this table, as well as the
        /// table struct renamed to the module name. This is meant to be
        /// glob imported for functions which only deal with one table.
        pub mod dsl {
            pub use super::columns::{id};
            pub use super::columns::{content};
            pub use super::columns::{approved};
            pub use super::columns::{post_id};
            pub use super::columns::{user_id};
            pub use super::columns::{anonymous_user};
            pub use super::columns::{created_at};
            pub use super::columns::{updated_at};
            pub use super::table as comments;
        }
        #[allow(non_upper_case_globals, dead_code)]
        /// A tuple of all of the columns on this table
        pub const all_columns: (
            id,
            content,
            approved,
            post_id,
            user_id,
            anonymous_user,
            created_at,
            updated_at,
        ) = (
            id,
            content,
            approved,
            post_id,
            user_id,
            anonymous_user,
            created_at,
            updated_at,
        );
        #[allow(non_camel_case_types)]
        /// The actual table struct
        ///
        /// This is the type which provides the base methods of the query
        /// builder, such as `.select` and `.filter`.
        pub struct table;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::fmt::Debug for table {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    table => ::core::fmt::Formatter::write_str(f, "table"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for table {
            #[inline]
            fn clone(&self) -> table {
                {
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::marker::Copy for table {}
        #[allow(non_snake_case, unused_extern_crates, unused_imports)]
        fn _impl_query_id_for_table() {
            extern crate std;
            use diesel;
            use diesel::query_builder::QueryId;
            #[allow(non_camel_case_types)]
            impl QueryId for table {
                type QueryId = table;
                const HAS_STATIC_QUERY_ID: bool = true;
            }
        }
        impl table {
            #[allow(dead_code)]
            /// Represents `table_name.*`, which is sometimes necessary
            /// for efficient count queries. It cannot be used in place of
            /// `all_columns`
            pub fn star(&self) -> star {
                star
            }
        }
        /// The SQL type of all of the columns on this table
        pub type SqlType = (
            Int4,
            Text,
            Bool,
            Int4,
            Nullable<Int4>,
            Nullable<Varchar>,
            Timestamptz,
            Timestamptz,
        );
        /// Helper type for representing a boxed query from this table
        pub type BoxedQuery<'a, DB, ST = SqlType> = BoxedSelectStatement<'a, ST, table, DB>;
        impl QuerySource for table {
            type FromClause = Identifier<'static>;
            type DefaultSelection = <Self as Table>::AllColumns;
            fn from_clause(&self) -> Self::FromClause {
                Identifier("comments")
            }
            fn default_selection(&self) -> Self::DefaultSelection {
                Self::all_columns()
            }
        }
        impl AsQuery for table {
            type SqlType = SqlType;
            type Query = SelectStatement<Self>;
            fn as_query(self) -> Self::Query {
                SelectStatement::simple(self)
            }
        }
        impl Table for table {
            type PrimaryKey = (id);
            type AllColumns = (
                id,
                content,
                approved,
                post_id,
                user_id,
                anonymous_user,
                created_at,
                updated_at,
            );
            fn primary_key(&self) -> Self::PrimaryKey {
                (id)
            }
            fn all_columns() -> Self::AllColumns {
                (
                    id,
                    content,
                    approved,
                    post_id,
                    user_id,
                    anonymous_user,
                    created_at,
                    updated_at,
                )
            }
        }
        impl HasTable for table {
            type Table = Self;
            fn table() -> Self::Table {
                table
            }
        }
        impl IntoUpdateTarget for table {
            type WhereClause = <<Self as AsQuery>::Query as IntoUpdateTarget>::WhereClause;
            fn into_update_target(self) -> UpdateTarget<Self::Table, Self::WhereClause> {
                self.as_query().into_update_target()
            }
        }
        impl AppearsInFromClause<table> for table {
            type Count = Once;
        }
        impl AppearsInFromClause<table> for () {
            type Count = Never;
        }
        impl<Left, Right, Kind> JoinTo<Join<Left, Right, Kind>> for table
        where
            Join<Left, Right, Kind>: JoinTo<table>,
        {
            type FromClause = Join<Left, Right, Kind>;
            type OnClause = <Join<Left, Right, Kind> as JoinTo<table>>::OnClause;
            fn join_target(rhs: Join<Left, Right, Kind>) -> (Self::FromClause, Self::OnClause) {
                let (_, on_clause) = Join::join_target(table);
                (rhs, on_clause)
            }
        }
        impl<Join, On> JoinTo<JoinOn<Join, On>> for table
        where
            JoinOn<Join, On>: JoinTo<table>,
        {
            type FromClause = JoinOn<Join, On>;
            type OnClause = <JoinOn<Join, On> as JoinTo<table>>::OnClause;
            fn join_target(rhs: JoinOn<Join, On>) -> (Self::FromClause, Self::OnClause) {
                let (_, on_clause) = JoinOn::join_target(table);
                (rhs, on_clause)
            }
        }
        impl<F, S, D, W, O, L, Of, G> JoinTo<SelectStatement<F, S, D, W, O, L, Of, G>> for table
        where
            SelectStatement<F, S, D, W, O, L, Of, G>: JoinTo<table>,
        {
            type FromClause = SelectStatement<F, S, D, W, O, L, Of, G>;
            type OnClause = <SelectStatement<F, S, D, W, O, L, Of, G> as JoinTo<table>>::OnClause;
            fn join_target(
                rhs: SelectStatement<F, S, D, W, O, L, Of, G>,
            ) -> (Self::FromClause, Self::OnClause) {
                let (_, on_clause) = SelectStatement::join_target(table);
                (rhs, on_clause)
            }
        }
        impl<'a, QS, ST, DB> JoinTo<BoxedSelectStatement<'a, QS, ST, DB>> for table
        where
            BoxedSelectStatement<'a, QS, ST, DB>: JoinTo<table>,
        {
            type FromClause = BoxedSelectStatement<'a, QS, ST, DB>;
            type OnClause = <BoxedSelectStatement<'a, QS, ST, DB> as JoinTo<table>>::OnClause;
            fn join_target(
                rhs: BoxedSelectStatement<'a, QS, ST, DB>,
            ) -> (Self::FromClause, Self::OnClause) {
                let (_, on_clause) = BoxedSelectStatement::join_target(table);
                (rhs, on_clause)
            }
        }
        impl<T> Insertable<T> for table
        where
            <table as AsQuery>::Query: Insertable<T>,
        {
            type Values = <<table as AsQuery>::Query as Insertable<T>>::Values;
            fn values(self) -> Self::Values {
                self.as_query().values()
            }
        }
        impl<'a, T> Insertable<T> for &'a table
        where
            table: Insertable<T>,
        {
            type Values = <table as Insertable<T>>::Values;
            fn values(self) -> Self::Values {
                (*self).values()
            }
        }
        /// Contains all of the columns of this table
        pub mod columns {
            use super::table;
            use ::diesel::{Expression, SelectableExpression, AppearsOnTable, QuerySource};
            use ::diesel::backend::Backend;
            use ::diesel::query_builder::{QueryFragment, AstPass, SelectStatement};
            use ::diesel::query_source::joins::{Join, JoinOn, Inner, LeftOuter};
            use ::diesel::query_source::{AppearsInFromClause, Once, Never};
            use ::diesel::result::QueryResult;
            use ::diesel::sql_types::*;
            #[allow(non_camel_case_types, dead_code)]
            /// Represents `table_name.*`, which is sometimes needed for
            /// efficient count queries. It cannot be used in place of
            /// `all_columns`, and has a `SqlType` of `()` to prevent it
            /// being used that way
            pub struct star;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for star {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        star => ::core::fmt::Formatter::write_str(f, "star"),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for star {
                #[inline]
                fn clone(&self) -> star {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for star {}
            impl Expression for star {
                type SqlType = ();
            }
            impl<DB: Backend> QueryFragment<DB> for star
            where
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(&self, mut out: AstPass<DB>) -> QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".*");
                    Ok(())
                }
            }
            impl SelectableExpression<table> for star {}
            impl AppearsOnTable<table> for star {}
            #[allow(non_camel_case_types, dead_code)]
            pub struct id;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for id {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        id => ::core::fmt::Formatter::write_str(f, "id"),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for id {
                #[inline]
                fn clone(&self) -> id {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for id {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_id() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for id {
                    type QueryId = id;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for id {
                #[inline]
                fn default() -> id {
                    id {}
                }
            }
            impl ::diesel::expression::Expression for id {
                type SqlType = Int4;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for id
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("id")
                }
            }
            impl SelectableExpression<table> for id {}
            impl<QS> AppearsOnTable<QS> for id where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for id
            where
                id: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for id
            where
                id: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for id where
                id: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for id where
                id: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for id {}
            impl ::diesel::query_source::Column for id {
                type Table = table;
                const NAME: &'static str = "id";
            }
            impl<T> ::diesel::EqAll<T> for id
            where
                T: ::diesel::expression::AsExpression<Int4>,
                ::diesel::dsl::Eq<id, T>: ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            impl<Rhs> ::std::ops::Add<Rhs> for id
            where
                Rhs: ::diesel::expression::AsExpression<
                    <<id as ::diesel::Expression>::SqlType as ::diesel::sql_types::ops::Add>::Rhs,
                >,
            {
                type Output = ::diesel::expression::ops::Add<Self, Rhs::Expression>;
                fn add(self, rhs: Rhs) -> Self::Output {
                    ::diesel::expression::ops::Add::new(self, rhs.as_expression())
                }
            }
            impl<Rhs> ::std::ops::Sub<Rhs> for id
            where
                Rhs: ::diesel::expression::AsExpression<
                    <<id as ::diesel::Expression>::SqlType as ::diesel::sql_types::ops::Sub>::Rhs,
                >,
            {
                type Output = ::diesel::expression::ops::Sub<Self, Rhs::Expression>;
                fn sub(self, rhs: Rhs) -> Self::Output {
                    ::diesel::expression::ops::Sub::new(self, rhs.as_expression())
                }
            }
            impl<Rhs> ::std::ops::Div<Rhs> for id
            where
                Rhs: ::diesel::expression::AsExpression<
                    <<id as ::diesel::Expression>::SqlType as ::diesel::sql_types::ops::Div>::Rhs,
                >,
            {
                type Output = ::diesel::expression::ops::Div<Self, Rhs::Expression>;
                fn div(self, rhs: Rhs) -> Self::Output {
                    ::diesel::expression::ops::Div::new(self, rhs.as_expression())
                }
            }
            impl<Rhs> ::std::ops::Mul<Rhs> for id
            where
                Rhs: ::diesel::expression::AsExpression<
                    <<id as ::diesel::Expression>::SqlType as ::diesel::sql_types::ops::Mul>::Rhs,
                >,
            {
                type Output = ::diesel::expression::ops::Mul<Self, Rhs::Expression>;
                fn mul(self, rhs: Rhs) -> Self::Output {
                    ::diesel::expression::ops::Mul::new(self, rhs.as_expression())
                }
            }
            #[allow(non_camel_case_types, dead_code)]
            pub struct content;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for content {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        content => ::core::fmt::Formatter::write_str(f, "content"),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for content {
                #[inline]
                fn clone(&self) -> content {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for content {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_content() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for content {
                    type QueryId = content;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for content {
                #[inline]
                fn default() -> content {
                    content {}
                }
            }
            impl ::diesel::expression::Expression for content {
                type SqlType = Text;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for content
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("content")
                }
            }
            impl SelectableExpression<table> for content {}
            impl<QS> AppearsOnTable<QS> for content where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for content
            where
                content: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for content
            where
                content: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for content where
                content: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for content where
                content: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for content {}
            impl ::diesel::query_source::Column for content {
                type Table = table;
                const NAME: &'static str = "content";
            }
            impl<T> ::diesel::EqAll<T> for content
            where
                T: ::diesel::expression::AsExpression<Text>,
                ::diesel::dsl::Eq<content, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            #[allow(non_camel_case_types, dead_code)]
            pub struct approved;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for approved {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        approved => ::core::fmt::Formatter::write_str(f, "approved"),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for approved {
                #[inline]
                fn clone(&self) -> approved {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for approved {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_approved() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for approved {
                    type QueryId = approved;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for approved {
                #[inline]
                fn default() -> approved {
                    approved {}
                }
            }
            impl ::diesel::expression::Expression for approved {
                type SqlType = Bool;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for approved
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("approved")
                }
            }
            impl SelectableExpression<table> for approved {}
            impl<QS> AppearsOnTable<QS> for approved where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for approved
            where
                approved: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for approved
            where
                approved: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for approved where
                approved: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for approved where
                approved: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for approved {}
            impl ::diesel::query_source::Column for approved {
                type Table = table;
                const NAME: &'static str = "approved";
            }
            impl<T> ::diesel::EqAll<T> for approved
            where
                T: ::diesel::expression::AsExpression<Bool>,
                ::diesel::dsl::Eq<approved, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            #[allow(non_camel_case_types, dead_code)]
            pub struct post_id;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for post_id {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        post_id => ::core::fmt::Formatter::write_str(f, "post_id"),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for post_id {
                #[inline]
                fn clone(&self) -> post_id {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for post_id {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_post_id() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for post_id {
                    type QueryId = post_id;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for post_id {
                #[inline]
                fn default() -> post_id {
                    post_id {}
                }
            }
            impl ::diesel::expression::Expression for post_id {
                type SqlType = Int4;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for post_id
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("post_id")
                }
            }
            impl SelectableExpression<table> for post_id {}
            impl<QS> AppearsOnTable<QS> for post_id where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for post_id
            where
                post_id: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for post_id
            where
                post_id: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for post_id where
                post_id: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for post_id where
                post_id: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for post_id {}
            impl ::diesel::query_source::Column for post_id {
                type Table = table;
                const NAME: &'static str = "post_id";
            }
            impl<T> ::diesel::EqAll<T> for post_id
            where
                T: ::diesel::expression::AsExpression<Int4>,
                ::diesel::dsl::Eq<post_id, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            impl < Rhs > :: std :: ops :: Add < Rhs > for post_id where Rhs : :: diesel :: expression :: AsExpression < < < post_id as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Add > :: Rhs > { type Output = :: diesel :: expression :: ops :: Add < Self , Rhs :: Expression > ; fn add (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Add :: new (self , rhs . as_expression ()) } }
            impl < Rhs > :: std :: ops :: Sub < Rhs > for post_id where Rhs : :: diesel :: expression :: AsExpression < < < post_id as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Sub > :: Rhs > { type Output = :: diesel :: expression :: ops :: Sub < Self , Rhs :: Expression > ; fn sub (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Sub :: new (self , rhs . as_expression ()) } }
            impl < Rhs > :: std :: ops :: Div < Rhs > for post_id where Rhs : :: diesel :: expression :: AsExpression < < < post_id as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Div > :: Rhs > { type Output = :: diesel :: expression :: ops :: Div < Self , Rhs :: Expression > ; fn div (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Div :: new (self , rhs . as_expression ()) } }
            impl < Rhs > :: std :: ops :: Mul < Rhs > for post_id where Rhs : :: diesel :: expression :: AsExpression < < < post_id as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Mul > :: Rhs > { type Output = :: diesel :: expression :: ops :: Mul < Self , Rhs :: Expression > ; fn mul (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Mul :: new (self , rhs . as_expression ()) } }
            #[allow(non_camel_case_types, dead_code)]
            pub struct user_id;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for user_id {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        user_id => ::core::fmt::Formatter::write_str(f, "user_id"),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for user_id {
                #[inline]
                fn clone(&self) -> user_id {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for user_id {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_user_id() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for user_id {
                    type QueryId = user_id;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for user_id {
                #[inline]
                fn default() -> user_id {
                    user_id {}
                }
            }
            impl ::diesel::expression::Expression for user_id {
                type SqlType = Nullable<Int4>;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for user_id
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("user_id")
                }
            }
            impl SelectableExpression<table> for user_id {}
            impl<QS> AppearsOnTable<QS> for user_id where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for user_id
            where
                user_id: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for user_id
            where
                user_id: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for user_id where
                user_id: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for user_id where
                user_id: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for user_id {}
            impl ::diesel::query_source::Column for user_id {
                type Table = table;
                const NAME: &'static str = "user_id";
            }
            impl<T> ::diesel::EqAll<T> for user_id
            where
                T: ::diesel::expression::AsExpression<Nullable<Int4>>,
                ::diesel::dsl::Eq<user_id, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            impl < Rhs > :: std :: ops :: Add < Rhs > for user_id where Rhs : :: diesel :: expression :: AsExpression < < < user_id as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Add > :: Rhs > { type Output = :: diesel :: expression :: ops :: Add < Self , Rhs :: Expression > ; fn add (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Add :: new (self , rhs . as_expression ()) } }
            impl < Rhs > :: std :: ops :: Sub < Rhs > for user_id where Rhs : :: diesel :: expression :: AsExpression < < < user_id as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Sub > :: Rhs > { type Output = :: diesel :: expression :: ops :: Sub < Self , Rhs :: Expression > ; fn sub (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Sub :: new (self , rhs . as_expression ()) } }
            impl < Rhs > :: std :: ops :: Div < Rhs > for user_id where Rhs : :: diesel :: expression :: AsExpression < < < user_id as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Div > :: Rhs > { type Output = :: diesel :: expression :: ops :: Div < Self , Rhs :: Expression > ; fn div (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Div :: new (self , rhs . as_expression ()) } }
            impl < Rhs > :: std :: ops :: Mul < Rhs > for user_id where Rhs : :: diesel :: expression :: AsExpression < < < user_id as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Mul > :: Rhs > { type Output = :: diesel :: expression :: ops :: Mul < Self , Rhs :: Expression > ; fn mul (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Mul :: new (self , rhs . as_expression ()) } }
            #[allow(non_camel_case_types, dead_code)]
            pub struct anonymous_user;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for anonymous_user {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        anonymous_user => ::core::fmt::Formatter::write_str(f, "anonymous_user"),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for anonymous_user {
                #[inline]
                fn clone(&self) -> anonymous_user {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for anonymous_user {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_anonymous_user() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for anonymous_user {
                    type QueryId = anonymous_user;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for anonymous_user {
                #[inline]
                fn default() -> anonymous_user {
                    anonymous_user {}
                }
            }
            impl ::diesel::expression::Expression for anonymous_user {
                type SqlType = Nullable<Varchar>;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for anonymous_user
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("anonymous_user")
                }
            }
            impl SelectableExpression<table> for anonymous_user {}
            impl<QS> AppearsOnTable<QS> for anonymous_user where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for anonymous_user
            where
                anonymous_user: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for anonymous_user
            where
                anonymous_user: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for anonymous_user where
                anonymous_user: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for anonymous_user where
                anonymous_user: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for anonymous_user {}
            impl ::diesel::query_source::Column for anonymous_user {
                type Table = table;
                const NAME: &'static str = "anonymous_user";
            }
            impl<T> ::diesel::EqAll<T> for anonymous_user
            where
                T: ::diesel::expression::AsExpression<Nullable<Varchar>>,
                ::diesel::dsl::Eq<anonymous_user, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            #[allow(non_camel_case_types, dead_code)]
            pub struct created_at;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for created_at {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        created_at => ::core::fmt::Formatter::write_str(f, "created_at"),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for created_at {
                #[inline]
                fn clone(&self) -> created_at {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for created_at {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_created_at() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for created_at {
                    type QueryId = created_at;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for created_at {
                #[inline]
                fn default() -> created_at {
                    created_at {}
                }
            }
            impl ::diesel::expression::Expression for created_at {
                type SqlType = Timestamptz;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for created_at
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("created_at")
                }
            }
            impl SelectableExpression<table> for created_at {}
            impl<QS> AppearsOnTable<QS> for created_at where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for created_at
            where
                created_at: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for created_at
            where
                created_at: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for created_at where
                created_at: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for created_at where
                created_at: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for created_at {}
            impl ::diesel::query_source::Column for created_at {
                type Table = table;
                const NAME: &'static str = "created_at";
            }
            impl<T> ::diesel::EqAll<T> for created_at
            where
                T: ::diesel::expression::AsExpression<Timestamptz>,
                ::diesel::dsl::Eq<created_at, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            impl < Rhs > :: std :: ops :: Add < Rhs > for created_at where Rhs : :: diesel :: expression :: AsExpression < < < created_at as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Add > :: Rhs > { type Output = :: diesel :: expression :: ops :: Add < Self , Rhs :: Expression > ; fn add (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Add :: new (self , rhs . as_expression ()) } }
            impl < Rhs > :: std :: ops :: Sub < Rhs > for created_at where Rhs : :: diesel :: expression :: AsExpression < < < created_at as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Sub > :: Rhs > { type Output = :: diesel :: expression :: ops :: Sub < Self , Rhs :: Expression > ; fn sub (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Sub :: new (self , rhs . as_expression ()) } }
            #[allow(non_camel_case_types, dead_code)]
            pub struct updated_at;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for updated_at {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        updated_at => ::core::fmt::Formatter::write_str(f, "updated_at"),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for updated_at {
                #[inline]
                fn clone(&self) -> updated_at {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for updated_at {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_updated_at() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for updated_at {
                    type QueryId = updated_at;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for updated_at {
                #[inline]
                fn default() -> updated_at {
                    updated_at {}
                }
            }
            impl ::diesel::expression::Expression for updated_at {
                type SqlType = Timestamptz;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for updated_at
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("updated_at")
                }
            }
            impl SelectableExpression<table> for updated_at {}
            impl<QS> AppearsOnTable<QS> for updated_at where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for updated_at
            where
                updated_at: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for updated_at
            where
                updated_at: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for updated_at where
                updated_at: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for updated_at where
                updated_at: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for updated_at {}
            impl ::diesel::query_source::Column for updated_at {
                type Table = table;
                const NAME: &'static str = "updated_at";
            }
            impl<T> ::diesel::EqAll<T> for updated_at
            where
                T: ::diesel::expression::AsExpression<Timestamptz>,
                ::diesel::dsl::Eq<updated_at, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            impl < Rhs > :: std :: ops :: Add < Rhs > for updated_at where Rhs : :: diesel :: expression :: AsExpression < < < updated_at as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Add > :: Rhs > { type Output = :: diesel :: expression :: ops :: Add < Self , Rhs :: Expression > ; fn add (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Add :: new (self , rhs . as_expression ()) } }
            impl < Rhs > :: std :: ops :: Sub < Rhs > for updated_at where Rhs : :: diesel :: expression :: AsExpression < < < updated_at as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Sub > :: Rhs > { type Output = :: diesel :: expression :: ops :: Sub < Self , Rhs :: Expression > ; fn sub (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Sub :: new (self , rhs . as_expression ()) } }
        }
    }
    pub mod posts {
        #![allow(dead_code)]
        use ::diesel::{QuerySource, Table, JoinTo};
        use ::diesel::associations::HasTable;
        use ::diesel::insertable::Insertable;
        use ::diesel::query_builder::*;
        use ::diesel::query_builder::nodes::Identifier;
        use ::diesel::query_source::{AppearsInFromClause, Once, Never};
        use ::diesel::query_source::joins::{Join, JoinOn};
        use ::diesel::sql_types::*;
        pub use self::columns::*;
        /// Re-exports all of the columns of this table, as well as the
        /// table struct renamed to the module name. This is meant to be
        /// glob imported for functions which only deal with one table.
        pub mod dsl {
            pub use super::columns::{id};
            pub use super::columns::{title};
            pub use super::columns::{subtitle};
            pub use super::columns::{content};
            pub use super::columns::{publish_date};
            pub use super::columns::{publish_time};
            pub use super::columns::{user_id};
            pub use super::columns::{created_at};
            pub use super::columns::{updated_at};
            pub use super::table as posts;
        }
        #[allow(non_upper_case_globals, dead_code)]
        /// A tuple of all of the columns on this table
        pub const all_columns: (
            id,
            title,
            subtitle,
            content,
            publish_date,
            publish_time,
            user_id,
            created_at,
            updated_at,
        ) = (
            id,
            title,
            subtitle,
            content,
            publish_date,
            publish_time,
            user_id,
            created_at,
            updated_at,
        );
        #[allow(non_camel_case_types)]
        /// The actual table struct
        ///
        /// This is the type which provides the base methods of the query
        /// builder, such as `.select` and `.filter`.
        pub struct table;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::fmt::Debug for table {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    table => ::core::fmt::Formatter::write_str(f, "table"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for table {
            #[inline]
            fn clone(&self) -> table {
                {
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::marker::Copy for table {}
        #[allow(non_snake_case, unused_extern_crates, unused_imports)]
        fn _impl_query_id_for_table() {
            extern crate std;
            use diesel;
            use diesel::query_builder::QueryId;
            #[allow(non_camel_case_types)]
            impl QueryId for table {
                type QueryId = table;
                const HAS_STATIC_QUERY_ID: bool = true;
            }
        }
        impl table {
            #[allow(dead_code)]
            /// Represents `table_name.*`, which is sometimes necessary
            /// for efficient count queries. It cannot be used in place of
            /// `all_columns`
            pub fn star(&self) -> star {
                star
            }
        }
        /// The SQL type of all of the columns on this table
        pub type SqlType = (
            Int4,
            Varchar,
            Nullable<Varchar>,
            Text,
            Date,
            Time,
            Int4,
            Timestamptz,
            Timestamptz,
        );
        /// Helper type for representing a boxed query from this table
        pub type BoxedQuery<'a, DB, ST = SqlType> = BoxedSelectStatement<'a, ST, table, DB>;
        impl QuerySource for table {
            type FromClause = Identifier<'static>;
            type DefaultSelection = <Self as Table>::AllColumns;
            fn from_clause(&self) -> Self::FromClause {
                Identifier("posts")
            }
            fn default_selection(&self) -> Self::DefaultSelection {
                Self::all_columns()
            }
        }
        impl AsQuery for table {
            type SqlType = SqlType;
            type Query = SelectStatement<Self>;
            fn as_query(self) -> Self::Query {
                SelectStatement::simple(self)
            }
        }
        impl Table for table {
            type PrimaryKey = (id);
            type AllColumns = (
                id,
                title,
                subtitle,
                content,
                publish_date,
                publish_time,
                user_id,
                created_at,
                updated_at,
            );
            fn primary_key(&self) -> Self::PrimaryKey {
                (id)
            }
            fn all_columns() -> Self::AllColumns {
                (
                    id,
                    title,
                    subtitle,
                    content,
                    publish_date,
                    publish_time,
                    user_id,
                    created_at,
                    updated_at,
                )
            }
        }
        impl HasTable for table {
            type Table = Self;
            fn table() -> Self::Table {
                table
            }
        }
        impl IntoUpdateTarget for table {
            type WhereClause = <<Self as AsQuery>::Query as IntoUpdateTarget>::WhereClause;
            fn into_update_target(self) -> UpdateTarget<Self::Table, Self::WhereClause> {
                self.as_query().into_update_target()
            }
        }
        impl AppearsInFromClause<table> for table {
            type Count = Once;
        }
        impl AppearsInFromClause<table> for () {
            type Count = Never;
        }
        impl<Left, Right, Kind> JoinTo<Join<Left, Right, Kind>> for table
        where
            Join<Left, Right, Kind>: JoinTo<table>,
        {
            type FromClause = Join<Left, Right, Kind>;
            type OnClause = <Join<Left, Right, Kind> as JoinTo<table>>::OnClause;
            fn join_target(rhs: Join<Left, Right, Kind>) -> (Self::FromClause, Self::OnClause) {
                let (_, on_clause) = Join::join_target(table);
                (rhs, on_clause)
            }
        }
        impl<Join, On> JoinTo<JoinOn<Join, On>> for table
        where
            JoinOn<Join, On>: JoinTo<table>,
        {
            type FromClause = JoinOn<Join, On>;
            type OnClause = <JoinOn<Join, On> as JoinTo<table>>::OnClause;
            fn join_target(rhs: JoinOn<Join, On>) -> (Self::FromClause, Self::OnClause) {
                let (_, on_clause) = JoinOn::join_target(table);
                (rhs, on_clause)
            }
        }
        impl<F, S, D, W, O, L, Of, G> JoinTo<SelectStatement<F, S, D, W, O, L, Of, G>> for table
        where
            SelectStatement<F, S, D, W, O, L, Of, G>: JoinTo<table>,
        {
            type FromClause = SelectStatement<F, S, D, W, O, L, Of, G>;
            type OnClause = <SelectStatement<F, S, D, W, O, L, Of, G> as JoinTo<table>>::OnClause;
            fn join_target(
                rhs: SelectStatement<F, S, D, W, O, L, Of, G>,
            ) -> (Self::FromClause, Self::OnClause) {
                let (_, on_clause) = SelectStatement::join_target(table);
                (rhs, on_clause)
            }
        }
        impl<'a, QS, ST, DB> JoinTo<BoxedSelectStatement<'a, QS, ST, DB>> for table
        where
            BoxedSelectStatement<'a, QS, ST, DB>: JoinTo<table>,
        {
            type FromClause = BoxedSelectStatement<'a, QS, ST, DB>;
            type OnClause = <BoxedSelectStatement<'a, QS, ST, DB> as JoinTo<table>>::OnClause;
            fn join_target(
                rhs: BoxedSelectStatement<'a, QS, ST, DB>,
            ) -> (Self::FromClause, Self::OnClause) {
                let (_, on_clause) = BoxedSelectStatement::join_target(table);
                (rhs, on_clause)
            }
        }
        impl<T> Insertable<T> for table
        where
            <table as AsQuery>::Query: Insertable<T>,
        {
            type Values = <<table as AsQuery>::Query as Insertable<T>>::Values;
            fn values(self) -> Self::Values {
                self.as_query().values()
            }
        }
        impl<'a, T> Insertable<T> for &'a table
        where
            table: Insertable<T>,
        {
            type Values = <table as Insertable<T>>::Values;
            fn values(self) -> Self::Values {
                (*self).values()
            }
        }
        /// Contains all of the columns of this table
        pub mod columns {
            use super::table;
            use ::diesel::{Expression, SelectableExpression, AppearsOnTable, QuerySource};
            use ::diesel::backend::Backend;
            use ::diesel::query_builder::{QueryFragment, AstPass, SelectStatement};
            use ::diesel::query_source::joins::{Join, JoinOn, Inner, LeftOuter};
            use ::diesel::query_source::{AppearsInFromClause, Once, Never};
            use ::diesel::result::QueryResult;
            use ::diesel::sql_types::*;
            #[allow(non_camel_case_types, dead_code)]
            /// Represents `table_name.*`, which is sometimes needed for
            /// efficient count queries. It cannot be used in place of
            /// `all_columns`, and has a `SqlType` of `()` to prevent it
            /// being used that way
            pub struct star;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for star {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        star => ::core::fmt::Formatter::write_str(f, "star"),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for star {
                #[inline]
                fn clone(&self) -> star {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for star {}
            impl Expression for star {
                type SqlType = ();
            }
            impl<DB: Backend> QueryFragment<DB> for star
            where
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(&self, mut out: AstPass<DB>) -> QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".*");
                    Ok(())
                }
            }
            impl SelectableExpression<table> for star {}
            impl AppearsOnTable<table> for star {}
            #[allow(non_camel_case_types, dead_code)]
            pub struct id;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for id {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        id => ::core::fmt::Formatter::write_str(f, "id"),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for id {
                #[inline]
                fn clone(&self) -> id {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for id {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_id() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for id {
                    type QueryId = id;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for id {
                #[inline]
                fn default() -> id {
                    id {}
                }
            }
            impl ::diesel::expression::Expression for id {
                type SqlType = Int4;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for id
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("id")
                }
            }
            impl SelectableExpression<table> for id {}
            impl<QS> AppearsOnTable<QS> for id where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for id
            where
                id: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for id
            where
                id: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for id where
                id: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for id where
                id: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for id {}
            impl ::diesel::query_source::Column for id {
                type Table = table;
                const NAME: &'static str = "id";
            }
            impl<T> ::diesel::EqAll<T> for id
            where
                T: ::diesel::expression::AsExpression<Int4>,
                ::diesel::dsl::Eq<id, T>: ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            impl<Rhs> ::std::ops::Add<Rhs> for id
            where
                Rhs: ::diesel::expression::AsExpression<
                    <<id as ::diesel::Expression>::SqlType as ::diesel::sql_types::ops::Add>::Rhs,
                >,
            {
                type Output = ::diesel::expression::ops::Add<Self, Rhs::Expression>;
                fn add(self, rhs: Rhs) -> Self::Output {
                    ::diesel::expression::ops::Add::new(self, rhs.as_expression())
                }
            }
            impl<Rhs> ::std::ops::Sub<Rhs> for id
            where
                Rhs: ::diesel::expression::AsExpression<
                    <<id as ::diesel::Expression>::SqlType as ::diesel::sql_types::ops::Sub>::Rhs,
                >,
            {
                type Output = ::diesel::expression::ops::Sub<Self, Rhs::Expression>;
                fn sub(self, rhs: Rhs) -> Self::Output {
                    ::diesel::expression::ops::Sub::new(self, rhs.as_expression())
                }
            }
            impl<Rhs> ::std::ops::Div<Rhs> for id
            where
                Rhs: ::diesel::expression::AsExpression<
                    <<id as ::diesel::Expression>::SqlType as ::diesel::sql_types::ops::Div>::Rhs,
                >,
            {
                type Output = ::diesel::expression::ops::Div<Self, Rhs::Expression>;
                fn div(self, rhs: Rhs) -> Self::Output {
                    ::diesel::expression::ops::Div::new(self, rhs.as_expression())
                }
            }
            impl<Rhs> ::std::ops::Mul<Rhs> for id
            where
                Rhs: ::diesel::expression::AsExpression<
                    <<id as ::diesel::Expression>::SqlType as ::diesel::sql_types::ops::Mul>::Rhs,
                >,
            {
                type Output = ::diesel::expression::ops::Mul<Self, Rhs::Expression>;
                fn mul(self, rhs: Rhs) -> Self::Output {
                    ::diesel::expression::ops::Mul::new(self, rhs.as_expression())
                }
            }
            #[allow(non_camel_case_types, dead_code)]
            pub struct title;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for title {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        title => ::core::fmt::Formatter::write_str(f, "title"),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for title {
                #[inline]
                fn clone(&self) -> title {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for title {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_title() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for title {
                    type QueryId = title;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for title {
                #[inline]
                fn default() -> title {
                    title {}
                }
            }
            impl ::diesel::expression::Expression for title {
                type SqlType = Varchar;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for title
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("title")
                }
            }
            impl SelectableExpression<table> for title {}
            impl<QS> AppearsOnTable<QS> for title where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for title
            where
                title: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for title
            where
                title: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for title where
                title: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for title where
                title: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for title {}
            impl ::diesel::query_source::Column for title {
                type Table = table;
                const NAME: &'static str = "title";
            }
            impl<T> ::diesel::EqAll<T> for title
            where
                T: ::diesel::expression::AsExpression<Varchar>,
                ::diesel::dsl::Eq<title, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            #[allow(non_camel_case_types, dead_code)]
            pub struct subtitle;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for subtitle {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        subtitle => ::core::fmt::Formatter::write_str(f, "subtitle"),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for subtitle {
                #[inline]
                fn clone(&self) -> subtitle {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for subtitle {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_subtitle() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for subtitle {
                    type QueryId = subtitle;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for subtitle {
                #[inline]
                fn default() -> subtitle {
                    subtitle {}
                }
            }
            impl ::diesel::expression::Expression for subtitle {
                type SqlType = Nullable<Varchar>;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for subtitle
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("subtitle")
                }
            }
            impl SelectableExpression<table> for subtitle {}
            impl<QS> AppearsOnTable<QS> for subtitle where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for subtitle
            where
                subtitle: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for subtitle
            where
                subtitle: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for subtitle where
                subtitle: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for subtitle where
                subtitle: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for subtitle {}
            impl ::diesel::query_source::Column for subtitle {
                type Table = table;
                const NAME: &'static str = "subtitle";
            }
            impl<T> ::diesel::EqAll<T> for subtitle
            where
                T: ::diesel::expression::AsExpression<Nullable<Varchar>>,
                ::diesel::dsl::Eq<subtitle, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            #[allow(non_camel_case_types, dead_code)]
            pub struct content;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for content {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        content => ::core::fmt::Formatter::write_str(f, "content"),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for content {
                #[inline]
                fn clone(&self) -> content {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for content {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_content() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for content {
                    type QueryId = content;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for content {
                #[inline]
                fn default() -> content {
                    content {}
                }
            }
            impl ::diesel::expression::Expression for content {
                type SqlType = Text;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for content
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("content")
                }
            }
            impl SelectableExpression<table> for content {}
            impl<QS> AppearsOnTable<QS> for content where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for content
            where
                content: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for content
            where
                content: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for content where
                content: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for content where
                content: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for content {}
            impl ::diesel::query_source::Column for content {
                type Table = table;
                const NAME: &'static str = "content";
            }
            impl<T> ::diesel::EqAll<T> for content
            where
                T: ::diesel::expression::AsExpression<Text>,
                ::diesel::dsl::Eq<content, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            #[allow(non_camel_case_types, dead_code)]
            pub struct publish_date;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for publish_date {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        publish_date => ::core::fmt::Formatter::write_str(f, "publish_date"),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for publish_date {
                #[inline]
                fn clone(&self) -> publish_date {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for publish_date {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_publish_date() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for publish_date {
                    type QueryId = publish_date;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for publish_date {
                #[inline]
                fn default() -> publish_date {
                    publish_date {}
                }
            }
            impl ::diesel::expression::Expression for publish_date {
                type SqlType = Date;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for publish_date
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("publish_date")
                }
            }
            impl SelectableExpression<table> for publish_date {}
            impl<QS> AppearsOnTable<QS> for publish_date where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for publish_date
            where
                publish_date: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for publish_date
            where
                publish_date: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for publish_date where
                publish_date: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for publish_date where
                publish_date: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for publish_date {}
            impl ::diesel::query_source::Column for publish_date {
                type Table = table;
                const NAME: &'static str = "publish_date";
            }
            impl<T> ::diesel::EqAll<T> for publish_date
            where
                T: ::diesel::expression::AsExpression<Date>,
                ::diesel::dsl::Eq<publish_date, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            impl < Rhs > :: std :: ops :: Add < Rhs > for publish_date where Rhs : :: diesel :: expression :: AsExpression < < < publish_date as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Add > :: Rhs > { type Output = :: diesel :: expression :: ops :: Add < Self , Rhs :: Expression > ; fn add (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Add :: new (self , rhs . as_expression ()) } }
            impl < Rhs > :: std :: ops :: Sub < Rhs > for publish_date where Rhs : :: diesel :: expression :: AsExpression < < < publish_date as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Sub > :: Rhs > { type Output = :: diesel :: expression :: ops :: Sub < Self , Rhs :: Expression > ; fn sub (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Sub :: new (self , rhs . as_expression ()) } }
            #[allow(non_camel_case_types, dead_code)]
            pub struct publish_time;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for publish_time {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        publish_time => ::core::fmt::Formatter::write_str(f, "publish_time"),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for publish_time {
                #[inline]
                fn clone(&self) -> publish_time {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for publish_time {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_publish_time() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for publish_time {
                    type QueryId = publish_time;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for publish_time {
                #[inline]
                fn default() -> publish_time {
                    publish_time {}
                }
            }
            impl ::diesel::expression::Expression for publish_time {
                type SqlType = Time;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for publish_time
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("publish_time")
                }
            }
            impl SelectableExpression<table> for publish_time {}
            impl<QS> AppearsOnTable<QS> for publish_time where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for publish_time
            where
                publish_time: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for publish_time
            where
                publish_time: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for publish_time where
                publish_time: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for publish_time where
                publish_time: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for publish_time {}
            impl ::diesel::query_source::Column for publish_time {
                type Table = table;
                const NAME: &'static str = "publish_time";
            }
            impl<T> ::diesel::EqAll<T> for publish_time
            where
                T: ::diesel::expression::AsExpression<Time>,
                ::diesel::dsl::Eq<publish_time, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            impl < Rhs > :: std :: ops :: Add < Rhs > for publish_time where Rhs : :: diesel :: expression :: AsExpression < < < publish_time as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Add > :: Rhs > { type Output = :: diesel :: expression :: ops :: Add < Self , Rhs :: Expression > ; fn add (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Add :: new (self , rhs . as_expression ()) } }
            impl < Rhs > :: std :: ops :: Sub < Rhs > for publish_time where Rhs : :: diesel :: expression :: AsExpression < < < publish_time as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Sub > :: Rhs > { type Output = :: diesel :: expression :: ops :: Sub < Self , Rhs :: Expression > ; fn sub (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Sub :: new (self , rhs . as_expression ()) } }
            #[allow(non_camel_case_types, dead_code)]
            pub struct user_id;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for user_id {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        user_id => ::core::fmt::Formatter::write_str(f, "user_id"),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for user_id {
                #[inline]
                fn clone(&self) -> user_id {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for user_id {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_user_id() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for user_id {
                    type QueryId = user_id;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for user_id {
                #[inline]
                fn default() -> user_id {
                    user_id {}
                }
            }
            impl ::diesel::expression::Expression for user_id {
                type SqlType = Int4;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for user_id
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("user_id")
                }
            }
            impl SelectableExpression<table> for user_id {}
            impl<QS> AppearsOnTable<QS> for user_id where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for user_id
            where
                user_id: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for user_id
            where
                user_id: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for user_id where
                user_id: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for user_id where
                user_id: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for user_id {}
            impl ::diesel::query_source::Column for user_id {
                type Table = table;
                const NAME: &'static str = "user_id";
            }
            impl<T> ::diesel::EqAll<T> for user_id
            where
                T: ::diesel::expression::AsExpression<Int4>,
                ::diesel::dsl::Eq<user_id, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            impl < Rhs > :: std :: ops :: Add < Rhs > for user_id where Rhs : :: diesel :: expression :: AsExpression < < < user_id as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Add > :: Rhs > { type Output = :: diesel :: expression :: ops :: Add < Self , Rhs :: Expression > ; fn add (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Add :: new (self , rhs . as_expression ()) } }
            impl < Rhs > :: std :: ops :: Sub < Rhs > for user_id where Rhs : :: diesel :: expression :: AsExpression < < < user_id as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Sub > :: Rhs > { type Output = :: diesel :: expression :: ops :: Sub < Self , Rhs :: Expression > ; fn sub (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Sub :: new (self , rhs . as_expression ()) } }
            impl < Rhs > :: std :: ops :: Div < Rhs > for user_id where Rhs : :: diesel :: expression :: AsExpression < < < user_id as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Div > :: Rhs > { type Output = :: diesel :: expression :: ops :: Div < Self , Rhs :: Expression > ; fn div (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Div :: new (self , rhs . as_expression ()) } }
            impl < Rhs > :: std :: ops :: Mul < Rhs > for user_id where Rhs : :: diesel :: expression :: AsExpression < < < user_id as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Mul > :: Rhs > { type Output = :: diesel :: expression :: ops :: Mul < Self , Rhs :: Expression > ; fn mul (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Mul :: new (self , rhs . as_expression ()) } }
            #[allow(non_camel_case_types, dead_code)]
            pub struct created_at;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for created_at {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        created_at => ::core::fmt::Formatter::write_str(f, "created_at"),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for created_at {
                #[inline]
                fn clone(&self) -> created_at {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for created_at {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_created_at() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for created_at {
                    type QueryId = created_at;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for created_at {
                #[inline]
                fn default() -> created_at {
                    created_at {}
                }
            }
            impl ::diesel::expression::Expression for created_at {
                type SqlType = Timestamptz;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for created_at
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("created_at")
                }
            }
            impl SelectableExpression<table> for created_at {}
            impl<QS> AppearsOnTable<QS> for created_at where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for created_at
            where
                created_at: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for created_at
            where
                created_at: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for created_at where
                created_at: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for created_at where
                created_at: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for created_at {}
            impl ::diesel::query_source::Column for created_at {
                type Table = table;
                const NAME: &'static str = "created_at";
            }
            impl<T> ::diesel::EqAll<T> for created_at
            where
                T: ::diesel::expression::AsExpression<Timestamptz>,
                ::diesel::dsl::Eq<created_at, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            impl < Rhs > :: std :: ops :: Add < Rhs > for created_at where Rhs : :: diesel :: expression :: AsExpression < < < created_at as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Add > :: Rhs > { type Output = :: diesel :: expression :: ops :: Add < Self , Rhs :: Expression > ; fn add (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Add :: new (self , rhs . as_expression ()) } }
            impl < Rhs > :: std :: ops :: Sub < Rhs > for created_at where Rhs : :: diesel :: expression :: AsExpression < < < created_at as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Sub > :: Rhs > { type Output = :: diesel :: expression :: ops :: Sub < Self , Rhs :: Expression > ; fn sub (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Sub :: new (self , rhs . as_expression ()) } }
            #[allow(non_camel_case_types, dead_code)]
            pub struct updated_at;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for updated_at {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        updated_at => ::core::fmt::Formatter::write_str(f, "updated_at"),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for updated_at {
                #[inline]
                fn clone(&self) -> updated_at {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for updated_at {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_updated_at() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for updated_at {
                    type QueryId = updated_at;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for updated_at {
                #[inline]
                fn default() -> updated_at {
                    updated_at {}
                }
            }
            impl ::diesel::expression::Expression for updated_at {
                type SqlType = Timestamptz;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for updated_at
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("updated_at")
                }
            }
            impl SelectableExpression<table> for updated_at {}
            impl<QS> AppearsOnTable<QS> for updated_at where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for updated_at
            where
                updated_at: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for updated_at
            where
                updated_at: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for updated_at where
                updated_at: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for updated_at where
                updated_at: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for updated_at {}
            impl ::diesel::query_source::Column for updated_at {
                type Table = table;
                const NAME: &'static str = "updated_at";
            }
            impl<T> ::diesel::EqAll<T> for updated_at
            where
                T: ::diesel::expression::AsExpression<Timestamptz>,
                ::diesel::dsl::Eq<updated_at, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            impl < Rhs > :: std :: ops :: Add < Rhs > for updated_at where Rhs : :: diesel :: expression :: AsExpression < < < updated_at as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Add > :: Rhs > { type Output = :: diesel :: expression :: ops :: Add < Self , Rhs :: Expression > ; fn add (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Add :: new (self , rhs . as_expression ()) } }
            impl < Rhs > :: std :: ops :: Sub < Rhs > for updated_at where Rhs : :: diesel :: expression :: AsExpression < < < updated_at as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Sub > :: Rhs > { type Output = :: diesel :: expression :: ops :: Sub < Self , Rhs :: Expression > ; fn sub (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Sub :: new (self , rhs . as_expression ()) } }
        }
    }
    pub mod users {
        #![allow(dead_code)]
        use ::diesel::{QuerySource, Table, JoinTo};
        use ::diesel::associations::HasTable;
        use ::diesel::insertable::Insertable;
        use ::diesel::query_builder::*;
        use ::diesel::query_builder::nodes::Identifier;
        use ::diesel::query_source::{AppearsInFromClause, Once, Never};
        use ::diesel::query_source::joins::{Join, JoinOn};
        use ::diesel::sql_types::*;
        pub use self::columns::*;
        /// Re-exports all of the columns of this table, as well as the
        /// table struct renamed to the module name. This is meant to be
        /// glob imported for functions which only deal with one table.
        pub mod dsl {
            pub use super::columns::{id};
            pub use super::columns::{username};
            pub use super::columns::{role};
            pub use super::columns::{created_at};
            pub use super::columns::{updated_at};
            pub use super::table as users;
        }
        #[allow(non_upper_case_globals, dead_code)]
        /// A tuple of all of the columns on this table
        pub const all_columns: (id, username, role, created_at, updated_at) =
            (id, username, role, created_at, updated_at);
        #[allow(non_camel_case_types)]
        /// The actual table struct
        ///
        /// This is the type which provides the base methods of the query
        /// builder, such as `.select` and `.filter`.
        pub struct table;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::fmt::Debug for table {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    table => ::core::fmt::Formatter::write_str(f, "table"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for table {
            #[inline]
            fn clone(&self) -> table {
                {
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(non_camel_case_types)]
        impl ::core::marker::Copy for table {}
        #[allow(non_snake_case, unused_extern_crates, unused_imports)]
        fn _impl_query_id_for_table() {
            extern crate std;
            use diesel;
            use diesel::query_builder::QueryId;
            #[allow(non_camel_case_types)]
            impl QueryId for table {
                type QueryId = table;
                const HAS_STATIC_QUERY_ID: bool = true;
            }
        }
        impl table {
            #[allow(dead_code)]
            /// Represents `table_name.*`, which is sometimes necessary
            /// for efficient count queries. It cannot be used in place of
            /// `all_columns`
            pub fn star(&self) -> star {
                star
            }
        }
        /// The SQL type of all of the columns on this table
        pub type SqlType = (Int4, Varchar, Varchar, Timestamptz, Timestamptz);
        /// Helper type for representing a boxed query from this table
        pub type BoxedQuery<'a, DB, ST = SqlType> = BoxedSelectStatement<'a, ST, table, DB>;
        impl QuerySource for table {
            type FromClause = Identifier<'static>;
            type DefaultSelection = <Self as Table>::AllColumns;
            fn from_clause(&self) -> Self::FromClause {
                Identifier("users")
            }
            fn default_selection(&self) -> Self::DefaultSelection {
                Self::all_columns()
            }
        }
        impl AsQuery for table {
            type SqlType = SqlType;
            type Query = SelectStatement<Self>;
            fn as_query(self) -> Self::Query {
                SelectStatement::simple(self)
            }
        }
        impl Table for table {
            type PrimaryKey = (id);
            type AllColumns = (id, username, role, created_at, updated_at);
            fn primary_key(&self) -> Self::PrimaryKey {
                (id)
            }
            fn all_columns() -> Self::AllColumns {
                (id, username, role, created_at, updated_at)
            }
        }
        impl HasTable for table {
            type Table = Self;
            fn table() -> Self::Table {
                table
            }
        }
        impl IntoUpdateTarget for table {
            type WhereClause = <<Self as AsQuery>::Query as IntoUpdateTarget>::WhereClause;
            fn into_update_target(self) -> UpdateTarget<Self::Table, Self::WhereClause> {
                self.as_query().into_update_target()
            }
        }
        impl AppearsInFromClause<table> for table {
            type Count = Once;
        }
        impl AppearsInFromClause<table> for () {
            type Count = Never;
        }
        impl<Left, Right, Kind> JoinTo<Join<Left, Right, Kind>> for table
        where
            Join<Left, Right, Kind>: JoinTo<table>,
        {
            type FromClause = Join<Left, Right, Kind>;
            type OnClause = <Join<Left, Right, Kind> as JoinTo<table>>::OnClause;
            fn join_target(rhs: Join<Left, Right, Kind>) -> (Self::FromClause, Self::OnClause) {
                let (_, on_clause) = Join::join_target(table);
                (rhs, on_clause)
            }
        }
        impl<Join, On> JoinTo<JoinOn<Join, On>> for table
        where
            JoinOn<Join, On>: JoinTo<table>,
        {
            type FromClause = JoinOn<Join, On>;
            type OnClause = <JoinOn<Join, On> as JoinTo<table>>::OnClause;
            fn join_target(rhs: JoinOn<Join, On>) -> (Self::FromClause, Self::OnClause) {
                let (_, on_clause) = JoinOn::join_target(table);
                (rhs, on_clause)
            }
        }
        impl<F, S, D, W, O, L, Of, G> JoinTo<SelectStatement<F, S, D, W, O, L, Of, G>> for table
        where
            SelectStatement<F, S, D, W, O, L, Of, G>: JoinTo<table>,
        {
            type FromClause = SelectStatement<F, S, D, W, O, L, Of, G>;
            type OnClause = <SelectStatement<F, S, D, W, O, L, Of, G> as JoinTo<table>>::OnClause;
            fn join_target(
                rhs: SelectStatement<F, S, D, W, O, L, Of, G>,
            ) -> (Self::FromClause, Self::OnClause) {
                let (_, on_clause) = SelectStatement::join_target(table);
                (rhs, on_clause)
            }
        }
        impl<'a, QS, ST, DB> JoinTo<BoxedSelectStatement<'a, QS, ST, DB>> for table
        where
            BoxedSelectStatement<'a, QS, ST, DB>: JoinTo<table>,
        {
            type FromClause = BoxedSelectStatement<'a, QS, ST, DB>;
            type OnClause = <BoxedSelectStatement<'a, QS, ST, DB> as JoinTo<table>>::OnClause;
            fn join_target(
                rhs: BoxedSelectStatement<'a, QS, ST, DB>,
            ) -> (Self::FromClause, Self::OnClause) {
                let (_, on_clause) = BoxedSelectStatement::join_target(table);
                (rhs, on_clause)
            }
        }
        impl<T> Insertable<T> for table
        where
            <table as AsQuery>::Query: Insertable<T>,
        {
            type Values = <<table as AsQuery>::Query as Insertable<T>>::Values;
            fn values(self) -> Self::Values {
                self.as_query().values()
            }
        }
        impl<'a, T> Insertable<T> for &'a table
        where
            table: Insertable<T>,
        {
            type Values = <table as Insertable<T>>::Values;
            fn values(self) -> Self::Values {
                (*self).values()
            }
        }
        /// Contains all of the columns of this table
        pub mod columns {
            use super::table;
            use ::diesel::{Expression, SelectableExpression, AppearsOnTable, QuerySource};
            use ::diesel::backend::Backend;
            use ::diesel::query_builder::{QueryFragment, AstPass, SelectStatement};
            use ::diesel::query_source::joins::{Join, JoinOn, Inner, LeftOuter};
            use ::diesel::query_source::{AppearsInFromClause, Once, Never};
            use ::diesel::result::QueryResult;
            use ::diesel::sql_types::*;
            #[allow(non_camel_case_types, dead_code)]
            /// Represents `table_name.*`, which is sometimes needed for
            /// efficient count queries. It cannot be used in place of
            /// `all_columns`, and has a `SqlType` of `()` to prevent it
            /// being used that way
            pub struct star;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for star {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        star => ::core::fmt::Formatter::write_str(f, "star"),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for star {
                #[inline]
                fn clone(&self) -> star {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for star {}
            impl Expression for star {
                type SqlType = ();
            }
            impl<DB: Backend> QueryFragment<DB> for star
            where
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(&self, mut out: AstPass<DB>) -> QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".*");
                    Ok(())
                }
            }
            impl SelectableExpression<table> for star {}
            impl AppearsOnTable<table> for star {}
            #[allow(non_camel_case_types, dead_code)]
            pub struct id;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for id {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        id => ::core::fmt::Formatter::write_str(f, "id"),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for id {
                #[inline]
                fn clone(&self) -> id {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for id {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_id() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for id {
                    type QueryId = id;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for id {
                #[inline]
                fn default() -> id {
                    id {}
                }
            }
            impl ::diesel::expression::Expression for id {
                type SqlType = Int4;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for id
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("id")
                }
            }
            impl SelectableExpression<table> for id {}
            impl<QS> AppearsOnTable<QS> for id where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for id
            where
                id: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for id
            where
                id: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for id where
                id: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for id where
                id: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for id {}
            impl ::diesel::query_source::Column for id {
                type Table = table;
                const NAME: &'static str = "id";
            }
            impl<T> ::diesel::EqAll<T> for id
            where
                T: ::diesel::expression::AsExpression<Int4>,
                ::diesel::dsl::Eq<id, T>: ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            impl<Rhs> ::std::ops::Add<Rhs> for id
            where
                Rhs: ::diesel::expression::AsExpression<
                    <<id as ::diesel::Expression>::SqlType as ::diesel::sql_types::ops::Add>::Rhs,
                >,
            {
                type Output = ::diesel::expression::ops::Add<Self, Rhs::Expression>;
                fn add(self, rhs: Rhs) -> Self::Output {
                    ::diesel::expression::ops::Add::new(self, rhs.as_expression())
                }
            }
            impl<Rhs> ::std::ops::Sub<Rhs> for id
            where
                Rhs: ::diesel::expression::AsExpression<
                    <<id as ::diesel::Expression>::SqlType as ::diesel::sql_types::ops::Sub>::Rhs,
                >,
            {
                type Output = ::diesel::expression::ops::Sub<Self, Rhs::Expression>;
                fn sub(self, rhs: Rhs) -> Self::Output {
                    ::diesel::expression::ops::Sub::new(self, rhs.as_expression())
                }
            }
            impl<Rhs> ::std::ops::Div<Rhs> for id
            where
                Rhs: ::diesel::expression::AsExpression<
                    <<id as ::diesel::Expression>::SqlType as ::diesel::sql_types::ops::Div>::Rhs,
                >,
            {
                type Output = ::diesel::expression::ops::Div<Self, Rhs::Expression>;
                fn div(self, rhs: Rhs) -> Self::Output {
                    ::diesel::expression::ops::Div::new(self, rhs.as_expression())
                }
            }
            impl<Rhs> ::std::ops::Mul<Rhs> for id
            where
                Rhs: ::diesel::expression::AsExpression<
                    <<id as ::diesel::Expression>::SqlType as ::diesel::sql_types::ops::Mul>::Rhs,
                >,
            {
                type Output = ::diesel::expression::ops::Mul<Self, Rhs::Expression>;
                fn mul(self, rhs: Rhs) -> Self::Output {
                    ::diesel::expression::ops::Mul::new(self, rhs.as_expression())
                }
            }
            #[allow(non_camel_case_types, dead_code)]
            pub struct username;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for username {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        username => ::core::fmt::Formatter::write_str(f, "username"),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for username {
                #[inline]
                fn clone(&self) -> username {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for username {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_username() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for username {
                    type QueryId = username;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for username {
                #[inline]
                fn default() -> username {
                    username {}
                }
            }
            impl ::diesel::expression::Expression for username {
                type SqlType = Varchar;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for username
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("username")
                }
            }
            impl SelectableExpression<table> for username {}
            impl<QS> AppearsOnTable<QS> for username where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for username
            where
                username: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for username
            where
                username: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for username where
                username: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for username where
                username: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for username {}
            impl ::diesel::query_source::Column for username {
                type Table = table;
                const NAME: &'static str = "username";
            }
            impl<T> ::diesel::EqAll<T> for username
            where
                T: ::diesel::expression::AsExpression<Varchar>,
                ::diesel::dsl::Eq<username, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            #[allow(non_camel_case_types, dead_code)]
            pub struct role;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for role {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        role => ::core::fmt::Formatter::write_str(f, "role"),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for role {
                #[inline]
                fn clone(&self) -> role {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for role {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_role() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for role {
                    type QueryId = role;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for role {
                #[inline]
                fn default() -> role {
                    role {}
                }
            }
            impl ::diesel::expression::Expression for role {
                type SqlType = Varchar;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for role
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("role")
                }
            }
            impl SelectableExpression<table> for role {}
            impl<QS> AppearsOnTable<QS> for role where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for role
            where
                role: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for role
            where
                role: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for role where
                role: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for role where
                role: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for role {}
            impl ::diesel::query_source::Column for role {
                type Table = table;
                const NAME: &'static str = "role";
            }
            impl<T> ::diesel::EqAll<T> for role
            where
                T: ::diesel::expression::AsExpression<Varchar>,
                ::diesel::dsl::Eq<role, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            #[allow(non_camel_case_types, dead_code)]
            pub struct created_at;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for created_at {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        created_at => ::core::fmt::Formatter::write_str(f, "created_at"),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for created_at {
                #[inline]
                fn clone(&self) -> created_at {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for created_at {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_created_at() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for created_at {
                    type QueryId = created_at;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for created_at {
                #[inline]
                fn default() -> created_at {
                    created_at {}
                }
            }
            impl ::diesel::expression::Expression for created_at {
                type SqlType = Timestamptz;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for created_at
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("created_at")
                }
            }
            impl SelectableExpression<table> for created_at {}
            impl<QS> AppearsOnTable<QS> for created_at where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for created_at
            where
                created_at: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for created_at
            where
                created_at: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for created_at where
                created_at: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for created_at where
                created_at: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for created_at {}
            impl ::diesel::query_source::Column for created_at {
                type Table = table;
                const NAME: &'static str = "created_at";
            }
            impl<T> ::diesel::EqAll<T> for created_at
            where
                T: ::diesel::expression::AsExpression<Timestamptz>,
                ::diesel::dsl::Eq<created_at, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            impl < Rhs > :: std :: ops :: Add < Rhs > for created_at where Rhs : :: diesel :: expression :: AsExpression < < < created_at as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Add > :: Rhs > { type Output = :: diesel :: expression :: ops :: Add < Self , Rhs :: Expression > ; fn add (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Add :: new (self , rhs . as_expression ()) } }
            impl < Rhs > :: std :: ops :: Sub < Rhs > for created_at where Rhs : :: diesel :: expression :: AsExpression < < < created_at as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Sub > :: Rhs > { type Output = :: diesel :: expression :: ops :: Sub < Self , Rhs :: Expression > ; fn sub (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Sub :: new (self , rhs . as_expression ()) } }
            #[allow(non_camel_case_types, dead_code)]
            pub struct updated_at;
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::fmt::Debug for updated_at {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        updated_at => ::core::fmt::Formatter::write_str(f, "updated_at"),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::clone::Clone for updated_at {
                #[inline]
                fn clone(&self) -> updated_at {
                    {
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::marker::Copy for updated_at {}
            #[allow(non_snake_case, unused_extern_crates, unused_imports)]
            fn _impl_query_id_for_updated_at() {
                extern crate std;
                use diesel;
                use diesel::query_builder::QueryId;
                #[allow(non_camel_case_types)]
                impl QueryId for updated_at {
                    type QueryId = updated_at;
                    const HAS_STATIC_QUERY_ID: bool = true;
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            #[allow(non_camel_case_types, dead_code)]
            impl ::core::default::Default for updated_at {
                #[inline]
                fn default() -> updated_at {
                    updated_at {}
                }
            }
            impl ::diesel::expression::Expression for updated_at {
                type SqlType = Timestamptz;
            }
            impl<DB> ::diesel::query_builder::QueryFragment<DB> for updated_at
            where
                DB: ::diesel::backend::Backend,
                <table as QuerySource>::FromClause: QueryFragment<DB>,
            {
                fn walk_ast(
                    &self,
                    mut out: ::diesel::query_builder::AstPass<DB>,
                ) -> ::diesel::result::QueryResult<()> {
                    table.from_clause().walk_ast(out.reborrow())?;
                    out.push_sql(".");
                    out.push_identifier("updated_at")
                }
            }
            impl SelectableExpression<table> for updated_at {}
            impl<QS> AppearsOnTable<QS> for updated_at where QS: AppearsInFromClause<table, Count = Once> {}
            impl<Left, Right> SelectableExpression<Join<Left, Right, LeftOuter>> for updated_at
            where
                updated_at: AppearsOnTable<Join<Left, Right, LeftOuter>>,
                Left: AppearsInFromClause<table, Count = Once>,
                Right: AppearsInFromClause<table, Count = Never>,
            {
            }
            impl<Left, Right> SelectableExpression<Join<Left, Right, Inner>> for updated_at
            where
                updated_at: AppearsOnTable<Join<Left, Right, Inner>>,
                Join<Left, Right, Inner>: AppearsInFromClause<table, Count = Once>,
            {
            }
            impl<Join, On> SelectableExpression<JoinOn<Join, On>> for updated_at where
                updated_at: SelectableExpression<Join> + AppearsOnTable<JoinOn<Join, On>>
            {
            }
            impl<From> SelectableExpression<SelectStatement<From>> for updated_at where
                updated_at: SelectableExpression<From> + AppearsOnTable<SelectStatement<From>>
            {
            }
            impl ::diesel::expression::NonAggregate for updated_at {}
            impl ::diesel::query_source::Column for updated_at {
                type Table = table;
                const NAME: &'static str = "updated_at";
            }
            impl<T> ::diesel::EqAll<T> for updated_at
            where
                T: ::diesel::expression::AsExpression<Timestamptz>,
                ::diesel::dsl::Eq<updated_at, T>:
                    ::diesel::Expression<SqlType = ::diesel::sql_types::Bool>,
            {
                type Output = ::diesel::dsl::Eq<Self, T>;
                fn eq_all(self, rhs: T) -> Self::Output {
                    ::diesel::expression::operators::Eq::new(self, rhs.as_expression())
                }
            }
            impl < Rhs > :: std :: ops :: Add < Rhs > for updated_at where Rhs : :: diesel :: expression :: AsExpression < < < updated_at as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Add > :: Rhs > { type Output = :: diesel :: expression :: ops :: Add < Self , Rhs :: Expression > ; fn add (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Add :: new (self , rhs . as_expression ()) } }
            impl < Rhs > :: std :: ops :: Sub < Rhs > for updated_at where Rhs : :: diesel :: expression :: AsExpression < < < updated_at as :: diesel :: Expression > :: SqlType as :: diesel :: sql_types :: ops :: Sub > :: Rhs > { type Output = :: diesel :: expression :: ops :: Sub < Self , Rhs :: Expression > ; fn sub (self , rhs : Rhs) -> Self :: Output { :: diesel :: expression :: ops :: Sub :: new (self , rhs . as_expression ()) } }
        }
    }
    impl ::diesel::JoinTo<posts::table> for comments::table {
        type FromClause = posts::table;
        type OnClause = ::diesel::dsl::Eq<
            ::diesel::expression::nullable::Nullable<comments::post_id>,
            ::diesel::expression::nullable::Nullable<
                <posts::table as ::diesel::query_source::Table>::PrimaryKey,
            >,
        >;
        fn join_target(rhs: posts::table) -> (Self::FromClause, Self::OnClause) {
            use ::diesel::{ExpressionMethods, NullableExpressionMethods};
            (
                rhs,
                comments::post_id.nullable().eq(
                    <posts::table as ::diesel::query_source::Table>::primary_key(&posts::table)
                        .nullable(),
                ),
            )
        }
    }
    impl ::diesel::JoinTo<comments::table> for posts::table {
        type FromClause = comments::table;
        type OnClause = ::diesel::dsl::Eq<
            ::diesel::expression::nullable::Nullable<comments::post_id>,
            ::diesel::expression::nullable::Nullable<
                <posts::table as ::diesel::query_source::Table>::PrimaryKey,
            >,
        >;
        fn join_target(rhs: comments::table) -> (Self::FromClause, Self::OnClause) {
            use ::diesel::{ExpressionMethods, NullableExpressionMethods};
            (
                rhs,
                comments::post_id.nullable().eq(
                    <posts::table as ::diesel::query_source::Table>::primary_key(&posts::table)
                        .nullable(),
                ),
            )
        }
    }
    impl ::diesel::JoinTo<users::table> for comments::table {
        type FromClause = users::table;
        type OnClause = ::diesel::dsl::Eq<
            ::diesel::expression::nullable::Nullable<comments::user_id>,
            ::diesel::expression::nullable::Nullable<
                <users::table as ::diesel::query_source::Table>::PrimaryKey,
            >,
        >;
        fn join_target(rhs: users::table) -> (Self::FromClause, Self::OnClause) {
            use ::diesel::{ExpressionMethods, NullableExpressionMethods};
            (
                rhs,
                comments::user_id.nullable().eq(
                    <users::table as ::diesel::query_source::Table>::primary_key(&users::table)
                        .nullable(),
                ),
            )
        }
    }
    impl ::diesel::JoinTo<comments::table> for users::table {
        type FromClause = comments::table;
        type OnClause = ::diesel::dsl::Eq<
            ::diesel::expression::nullable::Nullable<comments::user_id>,
            ::diesel::expression::nullable::Nullable<
                <users::table as ::diesel::query_source::Table>::PrimaryKey,
            >,
        >;
        fn join_target(rhs: comments::table) -> (Self::FromClause, Self::OnClause) {
            use ::diesel::{ExpressionMethods, NullableExpressionMethods};
            (
                rhs,
                comments::user_id.nullable().eq(
                    <users::table as ::diesel::query_source::Table>::primary_key(&users::table)
                        .nullable(),
                ),
            )
        }
    }
    impl ::diesel::JoinTo<users::table> for posts::table {
        type FromClause = users::table;
        type OnClause = ::diesel::dsl::Eq<
            ::diesel::expression::nullable::Nullable<posts::user_id>,
            ::diesel::expression::nullable::Nullable<
                <users::table as ::diesel::query_source::Table>::PrimaryKey,
            >,
        >;
        fn join_target(rhs: users::table) -> (Self::FromClause, Self::OnClause) {
            use ::diesel::{ExpressionMethods, NullableExpressionMethods};
            (
                rhs,
                posts::user_id.nullable().eq(
                    <users::table as ::diesel::query_source::Table>::primary_key(&users::table)
                        .nullable(),
                ),
            )
        }
    }
    impl ::diesel::JoinTo<posts::table> for users::table {
        type FromClause = posts::table;
        type OnClause = ::diesel::dsl::Eq<
            ::diesel::expression::nullable::Nullable<posts::user_id>,
            ::diesel::expression::nullable::Nullable<
                <users::table as ::diesel::query_source::Table>::PrimaryKey,
            >,
        >;
        fn join_target(rhs: posts::table) -> (Self::FromClause, Self::OnClause) {
            use ::diesel::{ExpressionMethods, NullableExpressionMethods};
            (
                rhs,
                posts::user_id.nullable().eq(
                    <users::table as ::diesel::query_source::Table>::primary_key(&users::table)
                        .nullable(),
                ),
            )
        }
    }
    impl ::diesel::query_source::AppearsInFromClause<comments::table> for posts::table {
        type Count = ::diesel::query_source::Never;
    }
    impl ::diesel::query_source::AppearsInFromClause<posts::table> for comments::table {
        type Count = ::diesel::query_source::Never;
    }
    impl ::diesel::query_source::AppearsInFromClause<comments::table> for users::table {
        type Count = ::diesel::query_source::Never;
    }
    impl ::diesel::query_source::AppearsInFromClause<users::table> for comments::table {
        type Count = ::diesel::query_source::Never;
    }
    impl ::diesel::query_source::AppearsInFromClause<posts::table> for users::table {
        type Count = ::diesel::query_source::Never;
    }
    impl ::diesel::query_source::AppearsInFromClause<users::table> for posts::table {
        type Count = ::diesel::query_source::Never;
    }
}
use diesel::backend::Backend;
use rocket_sync_db_pools::database;
use rp1::{
    access_control::{CheckPermissions, PermissionFilter},
    CrudStruct,
};
impl CheckPermissions for User {
    type AuthUser = AUser;
}
impl CheckPermissions for Post {
    type AuthUser = AUser;
    fn filter_list<DB>(u: &Self::AuthUser) -> PermissionFilter<<Self as CrudStruct>::TableType, DB>
    where
        DB: Backend,
    {
        use crate::schema::posts::dsl::*;
        use diesel::prelude::*;
        match u {
            AUser::Anonymous => PermissionFilter::KeepNone,
            AUser::LoggedIn(u) => PermissionFilter::Filter(Box::new(user_id.eq(u.id))),
        }
    }
}
impl CheckPermissions for Comment {
    type AuthUser = AUser;
}
struct Db(::rocket_sync_db_pools::Connection<Self, diesel::PgConnection>);
impl Db {
    /// Returns a fairing that initializes the associated database
    /// connection pool.
    pub fn fairing() -> impl ::rocket_sync_db_pools::rocket::fairing::Fairing {
        <::rocket_sync_db_pools::ConnectionPool<Self, diesel::PgConnection>>::fairing(
            "\'diesel\' Database Pool",
            "diesel",
        )
    }
    /// Retrieves a connection of type `Self` from the `rocket`
    /// instance. Returns `Some` as long as `Self::fairing()` has been
    /// attached.
    pub async fn get_one<P>(__rocket: &::rocket_sync_db_pools::rocket::Rocket<P>) -> Option<Self>
    where
        P: ::rocket_sync_db_pools::rocket::Phase,
    {
        <::rocket_sync_db_pools::ConnectionPool<Self, diesel::PgConnection>>::get_one(&__rocket)
            .await
            .map(Self)
    }
    /// Runs the provided closure on a thread from a threadpool. The
    /// closure will be passed an `&mut r2d2::PooledConnection`.
    /// `.await`ing the return value of this function yields the value
    /// returned by the closure.
    pub async fn run<F, R>(&self, __f: F) -> R
    where
        F: FnOnce(&mut diesel::PgConnection) -> R + Send + 'static,
        R: Send + 'static,
    {
        self.0.run(__f).await
    }
}
impl<'r> ::rocket_sync_db_pools::rocket::request::FromRequest<'r> for Db {
    type Error = ();
    #[allow(
        clippy::let_unit_value,
        clippy::type_complexity,
        clippy::type_repetition_in_bounds,
        clippy::used_underscore_binding
    )]
    fn from_request<'life0, 'async_trait>(
        __r: &'r ::rocket_sync_db_pools::rocket::request::Request<'life0>,
    ) -> ::core::pin::Pin<
        Box<
            dyn ::core::future::Future<
                    Output = ::rocket_sync_db_pools::rocket::request::Outcome<Self, ()>,
                > + ::core::marker::Send
                + 'async_trait,
        >,
    >
    where
        'r: 'async_trait,
        'life0: 'async_trait,
        Self: 'async_trait,
    {
        Box::pin(async move {
            if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                ::rocket_sync_db_pools::rocket::request::Outcome<Self, ()>,
            > {
                return __ret;
            }
            let __r = __r;
            let __ret: ::rocket_sync_db_pools::rocket::request::Outcome<Self, ()> = {
                <::rocket_sync_db_pools::Connection<Self, diesel::PgConnection>>::from_request(__r)
                    .await
                    .map(Self)
            };
            #[allow(unreachable_code)]
            __ret
        })
    }
}
impl ::rocket_sync_db_pools::rocket::Sentinel for Db {
    fn abort(
        __r: &::rocket_sync_db_pools::rocket::Rocket<::rocket_sync_db_pools::rocket::Ignite>,
    ) -> bool {
        <::rocket_sync_db_pools::Connection<Self, diesel::PgConnection>>::abort(__r)
    }
}
mod user {
    use super::*;
    use diesel::prelude::*;
    use crate::schema::users;
    pub struct User {
        pub id: i32,
        #[validate(email)]
        username: String,
        role: String,
        created_at: rp1::datetime::OffsetDateTime,
        updated_at: rp1::datetime::OffsetDateTime,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for User {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "User",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "username",
                    &self.username,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "role",
                    &self.role,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "created_at",
                    &self.created_at,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "updated_at",
                    &self.updated_at,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[allow(non_snake_case, unused_extern_crates, unused_imports)]
    fn _impl_queryable_for_user() {
        extern crate std;
        use diesel;
        use diesel::Queryable;
        impl<__DB: diesel::backend::Backend, __ST> Queryable<__ST, __DB> for User
        where
            (
                i32,
                String,
                String,
                rp1::datetime::OffsetDateTime,
                rp1::datetime::OffsetDateTime,
            ): Queryable<__ST, __DB>,
        {
            type Row = <(
                i32,
                String,
                String,
                rp1::datetime::OffsetDateTime,
                rp1::datetime::OffsetDateTime,
            ) as Queryable<__ST, __DB>>::Row;
            fn build(row: Self::Row) -> Self {
                let row: (
                    i32,
                    String,
                    String,
                    rp1::datetime::OffsetDateTime,
                    rp1::datetime::OffsetDateTime,
                ) = Queryable::build(row);
                Self {
                    id: (row.0.into()),
                    username: (row.1.into()),
                    role: (row.2.into()),
                    created_at: (row.3.into()),
                    updated_at: (row.4.into()),
                }
            }
        }
    }
    impl ::validator::Validate for User {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_args(())
        }
    }
    #[allow(clippy::all)]
    impl<'v_a> ::validator::ValidateArgs<'v_a> for User {
        type Args = ();
        #[allow(unused_mut)]
        #[allow(unused_variable)]
        fn validate_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            let mut errors = ::validator::ValidationErrors::new();
            if !::validator::validate_email(&self.username) {
                let mut err = ::validator::ValidationError::new("email");
                err.add_param(::std::borrow::Cow::from("value"), &&self.username);
                errors.add("username", err);
            }
            let mut result = if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            };
            result
        }
    }
    #[table_name = "users"]
    pub struct NewUser {
        #[validate(email)]
        username: String,
        role: String,
    }
    impl ::validator::Validate for NewUser {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_args(())
        }
    }
    #[allow(clippy::all)]
    impl<'v_a> ::validator::ValidateArgs<'v_a> for NewUser {
        type Args = ();
        #[allow(unused_mut)]
        #[allow(unused_variable)]
        fn validate_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            let mut errors = ::validator::ValidationErrors::new();
            if !::validator::validate_email(&self.username) {
                let mut err = ::validator::ValidationError::new("email");
                err.add_param(::std::borrow::Cow::from("value"), &&self.username);
                errors.add("username", err);
            }
            let mut result = if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            };
            result
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for NewUser {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "username" => _serde::__private::Ok(__Field::__field0),
                            "role" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"username" => _serde::__private::Ok(__Field::__field0),
                            b"role" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<NewUser>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = NewUser;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct NewUser")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct NewUser with 2 elements",
                                        ),
                                    );
                                }
                            };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct NewUser with 2 elements",
                                        ),
                                    );
                                }
                            };
                        _serde::__private::Ok(NewUser {
                            username: __field0,
                            role: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "username",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<String>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "role",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<String>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("username") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("role") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(NewUser {
                            username: __field0,
                            role: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["username", "role"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "NewUser",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<NewUser>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_snake_case)]
    const _: () = { # [doc = r" Rocket generated FormForm context."] # [doc (hidden)] pub struct FromFormGeneratedContext < '__f > { __opts : :: rocket :: form :: prelude :: Options , __errors : :: rocket :: form :: prelude :: Errors < '__f > , __parent : :: std :: option :: Option < & '__f :: rocket :: form :: prelude :: Name > , username : :: std :: option :: Option < < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , role : :: std :: option :: Option < < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , } # [allow (unused_imports)] use :: rocket :: http :: uncased :: AsUncased ; impl < '__f > :: rocket :: form :: prelude :: FromForm < '__f > for NewUser { type Context = FromFormGeneratedContext < '__f > ; fn init (__opts : :: rocket :: form :: prelude :: Options) -> Self :: Context { Self :: Context { __opts , __errors : :: rocket :: form :: prelude :: Errors :: new () , __parent : :: std :: option :: Option :: None , username : :: std :: option :: Option :: None , role : :: std :: option :: Option :: None , } } fn push_value (__c : & mut Self :: Context , __f : :: rocket :: form :: prelude :: ValueField < '__f >) { __c . __parent = __f . name . parent () ; match __f . name . key_lossy () . as_str () { "username" => { { < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . username . get_or_insert_with (| | < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "role" => { { < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . role . get_or_insert_with (| | < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } __k if __k == "_method" || ! __c . __opts . strict => { } _ => __c . __errors . push (__f . unexpected ()) , } } # [allow (clippy :: let_unit_value , clippy :: type_complexity , clippy :: type_repetition_in_bounds , clippy :: used_underscore_binding)] fn push_data < 'life0 , 'life1 , 'async_trait > (__c : & 'life0 mut FromFormGeneratedContext < '__f > , __f : :: rocket :: form :: prelude :: DataField < '__f , 'life1 >) -> :: core :: pin :: Pin < Box < dyn :: core :: future :: Future < Output = () > + :: core :: marker :: Send + 'async_trait > > where '__f : 'async_trait , 'life0 : 'async_trait , 'life1 : 'async_trait { Box :: pin (async move { let __c = __c ; let __f = __f ; let _ : () = { __c . __parent = __f . name . parent () ; match __f . name . key_lossy () . as_str () { "username" => { { let _fut = < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . username . get_or_insert_with (| | < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "role" => { { let _fut = < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . role . get_or_insert_with (| | < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } __k if __k == "_method" || ! __c . __opts . strict => { } _ => __c . __errors . push (__f . unexpected ()) , } } ; }) } fn finalize (mut __c : Self :: Context) -> :: std :: result :: Result < Self , :: rocket :: form :: prelude :: Errors < '__f > > { # [allow (unused_imports)] use :: rocket :: form :: prelude :: validate :: * ; let username = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "username")) ; let __opts = __c . __opts ; __c . username . map_or_else (| | { < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| username | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | username) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (username) => :: std :: option :: Option :: Some (username) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let role = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "role")) ; let __opts = __c . __opts ; __c . role . map_or_else (| | { < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| role | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | role) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (role) => :: std :: option :: Option :: Some (role) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; if ! __c . __errors . is_empty () { return :: std :: result :: Result :: Err (__c . __errors) ; } let __o = Self { username : username . unwrap () , role : role . unwrap () , } ; if ! __c . __errors . is_empty () { return :: std :: result :: Result :: Err (__c . __errors) ; } Ok (__o) } } };
    #[allow(non_snake_case, unused_extern_crates, unused_imports)]
    fn _impl_queryable_for_newuser() {
        extern crate std;
        use diesel;
        use diesel::Queryable;
        impl<__DB: diesel::backend::Backend, __ST> Queryable<__ST, __DB> for NewUser
        where
            (String, String): Queryable<__ST, __DB>,
        {
            type Row = <(String, String) as Queryable<__ST, __DB>>::Row;
            fn build(row: Self::Row) -> Self {
                let row: (String, String) = Queryable::build(row);
                Self {
                    username: (row.0.into()),
                    role: (row.1.into()),
                }
            }
        }
    }
    #[allow(non_snake_case, unused_extern_crates, unused_imports)]
    fn _impl_insertable_for_newuser() {
        extern crate std;
        use diesel;
        use diesel::insertable::Insertable;
        use diesel::query_builder::UndecoratedInsertRecord;
        use diesel::prelude::*;
        impl<'insert> Insertable<users::table> for NewUser {
            type Values = <(
                std::option::Option<diesel::dsl::Eq<users::username, String>>,
                std::option::Option<diesel::dsl::Eq<users::role, String>>,
            ) as Insertable<users::table>>::Values;
            fn values(self) -> Self::Values {
                (
                    std::option::Option::Some(users::username.eq(self.username)),
                    std::option::Option::Some(users::role.eq(self.role)),
                )
                    .values()
            }
        }
        impl<'insert> Insertable<users::table> for &'insert NewUser {
            type Values = <(
                std::option::Option<diesel::dsl::Eq<users::username, &'insert String>>,
                std::option::Option<diesel::dsl::Eq<users::role, &'insert String>>,
            ) as Insertable<users::table>>::Values;
            fn values(self) -> Self::Values {
                (
                    std::option::Option::Some(users::username.eq(&self.username)),
                    std::option::Option::Some(users::role.eq(&self.role)),
                )
                    .values()
            }
        }
        impl<'insert> UndecoratedInsertRecord<users::table> for NewUser {}
    }
    impl ::rp1::CrudInsertable for User {
        type InsertType = NewUser;
    }
    async fn create_fn_help(
        db: Db,
        value: NewUser,
        auth_user: <User as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<User> {
        if !<User as ::rp1::CheckPermissions>::allow_create(&value, &auth_user) {
            return Err(::rp1::CrudError::Forbidden);
        }
        use ::validator::Validate;
        value.validate()?;
        Ok(::rocket::serde::json::Json(
            db.run(move |conn| {
                diesel::insert_into(crate::schema::users::table)
                    .values(&value)
                    .get_result(conn)
            })
            .await?,
        ))
    }
    async fn create_fn_json(
        db: Db,
        value: ::rocket::serde::json::Json<NewUser>,
        auth_user: <User as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<User> {
        let value = value.into_inner();
        create_fn_help(db, value, auth_user).await
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct create_fn_json {}
    /// Rocket code generated proxy static conversion implementations.
    impl create_fn_json {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::user",
                                                "example/src/main.rs",
                                                40u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::user",
                                                "example/src/main.rs",
                                                40u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let __rocket_value : :: rocket :: serde :: json :: Json < NewUser > = match < :: rocket :: serde :: json :: Json < NewUser > as :: rocket :: data :: FromData > :: from_data (__req , __data) . await { :: rocket :: outcome :: Outcome :: Success (__d) => __d , :: rocket :: outcome :: Outcome :: Forward (__d) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard is forwarding."] , & match (& ":: rocket :: serde :: json :: Json < NewUser >" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__d) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard failed: " , "."] , & match (& ":: rocket :: serde :: json :: Json < NewUser >" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let ___responder =
                        create_fn_json(__rocket_db, __rocket_value, __rocket_auth_user).await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "create_fn_json",
                method: ::rocket::http::Method::Post,
                uri: "/",
                handler: monomorphized_function,
                format: ::std::option::Option::Some(::rocket::http::MediaType::const_new(
                    "application",
                    "json",
                    &[],
                )),
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized: Resolve::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<User>(),
                            type_name: std::any::type_name::<User>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 41u32, 8u32),
                            specialized: Resolve::<User>::SPECIALIZED,
                            abort: Resolve::<User>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::CrudJsonResult<User>>(),
                            type_name: std::any::type_name::<::rp1::CrudJsonResult<User>>(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized: Resolve::<::rp1::CrudJsonResult<User>>::SPECIALIZED,
                            abort: Resolve::<::rp1::CrudJsonResult<User>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<User>(),
                            type_name: std::any::type_name::<User>(),
                            parent: None
                                .or(Some(std::any::TypeId::of::<::rp1::CrudJsonResult<User>>())),
                            location: ("example/src/main.rs", 41u32, 8u32),
                            specialized: Resolve::<User>::SPECIALIZED,
                            abort: Resolve::<User>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_create_fn_json_10639685049873058592 as rocket_uri_macro_create_fn_json;
    async fn create_fn_form(
        db: Db,
        value: ::rocket::form::Form<NewUser>,
        auth_user: <User as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<User> {
        let value = value.into_inner();
        create_fn_help(db, value, auth_user).await
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct create_fn_form {}
    /// Rocket code generated proxy static conversion implementations.
    impl create_fn_form {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::user",
                                                "example/src/main.rs",
                                                40u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::user",
                                                "example/src/main.rs",
                                                40u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let __rocket_value: ::rocket::form::Form<NewUser> = match <::rocket::form::Form<
                        NewUser,
                    > as ::rocket::data::FromData>::from_data(
                        __req, __data
                    )
                    .await
                    {
                        ::rocket::outcome::Outcome::Success(__d) => __d,
                        ::rocket::outcome::Outcome::Forward(__d) => {
                            {
                                let lvl = ::log::Level::Warn;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["`", "` data guard is forwarding."],
                                            &match (&":: rocket :: form :: Form < NewUser >",) {
                                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                                    arg0,
                                                    ::core::fmt::Display::fmt,
                                                )],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::user", "example/src/main.rs", 40u32),
                                    );
                                }
                            };
                            return ::rocket::outcome::Outcome::Forward(__d);
                        }
                        ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                            {
                                let lvl = ::log::Level::Warn;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["`", "` data guard failed: ", "."],
                                            &match (&":: rocket :: form :: Form < NewUser >", &__e)
                                            {
                                                (arg0, arg1) => [
                                                    ::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    ),
                                                    ::core::fmt::ArgumentV1::new(
                                                        arg1,
                                                        ::core::fmt::Debug::fmt,
                                                    ),
                                                ],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::user", "example/src/main.rs", 40u32),
                                    );
                                }
                            };
                            return ::rocket::outcome::Outcome::Failure(__c);
                        }
                    };
                    let ___responder =
                        create_fn_form(__rocket_db, __rocket_value, __rocket_auth_user).await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "create_fn_form",
                method: ::rocket::http::Method::Post,
                uri: "/",
                handler: monomorphized_function,
                format: ::std::option::Option::Some(::rocket::http::MediaType::const_new(
                    "application",
                    "x-www-form-urlencoded",
                    &[],
                )),
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized: Resolve::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<User>(),
                            type_name: std::any::type_name::<User>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 41u32, 8u32),
                            specialized: Resolve::<User>::SPECIALIZED,
                            abort: Resolve::<User>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::CrudJsonResult<User>>(),
                            type_name: std::any::type_name::<::rp1::CrudJsonResult<User>>(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized: Resolve::<::rp1::CrudJsonResult<User>>::SPECIALIZED,
                            abort: Resolve::<::rp1::CrudJsonResult<User>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<User>(),
                            type_name: std::any::type_name::<User>(),
                            parent: None
                                .or(Some(std::any::TypeId::of::<::rp1::CrudJsonResult<User>>())),
                            location: ("example/src/main.rs", 41u32, 8u32),
                            specialized: Resolve::<User>::SPECIALIZED,
                            abort: Resolve::<User>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_create_fn_form_10053876916193790656 as rocket_uri_macro_create_fn_form;
    async fn read_fn(
        db: Db,
        id: i32,
        auth_user: <User as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<User> {
        let row = db
            .run(move |conn| crate::schema::users::table.find(id).first::<User>(conn))
            .await?;
        let row = if <User as ::rp1::CheckPermissions>::allow_read(&row, &auth_user) {
            row
        } else {
            return Err(::rp1::CrudError::NotFound);
        };
        Ok(::rocket::serde::json::Json(row))
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct read_fn {}
    /// Rocket code generated proxy static conversion implementations.
    impl read_fn {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::user",
                                                "example/src/main.rs",
                                                40u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::user",
                                                "example/src/main.rs",
                                                40u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let __rocket_id: i32 = match __req.routed_segment(0usize) {
                        ::std::option::Option::Some(__s) => {
                            match <i32 as ::rocket::request::FromParam>::from_param(__s) {
                                ::std::result::Result::Ok(__v) => __v,
                                ::std::result::Result::Err(__error) => {
                                    return {
                                        {
                                            let lvl = ::log::Level::Warn;
                                            if lvl <= ::log::STATIC_MAX_LEVEL
                                                && lvl <= ::log::max_level()
                                            {
                                                :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , ": " , "` param guard parsed forwarding with error "] , & match (& "id" , & "i32" , & __error) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ;
                                            }
                                        };
                                        ::rocket::outcome::Outcome::Forward(__data)
                                    }
                                }
                            }
                        }
                        ::std::option::Option::None => {
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Internal invariant broken: dyn param not found."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::user", "example/src/main.rs", 43u32),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Please report this to the Rocket issue tracker."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::user", "example/src/main.rs", 43u32),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["https://github.com/SergioBenitez/Rocket/issues"],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::user", "example/src/main.rs", 43u32),
                                    );
                                }
                            };
                            return ::rocket::outcome::Outcome::Forward(__data);
                        }
                    };
                    let ___responder = read_fn(__rocket_db, __rocket_id, __rocket_auth_user).await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "read_fn",
                method: ::rocket::http::Method::Get,
                uri: "/<id>",
                handler: monomorphized_function,
                format: ::std::option::Option::None,
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<i32>(),
                            type_name: std::any::type_name::<i32>(),
                            parent: None,
                            location: ("example/src/main.rs", 43u32, 13u32),
                            specialized: Resolve::<i32>::SPECIALIZED,
                            abort: Resolve::<i32>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized: Resolve::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<User>(),
                            type_name: std::any::type_name::<User>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 41u32, 8u32),
                            specialized: Resolve::<User>::SPECIALIZED,
                            abort: Resolve::<User>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::CrudJsonResult<User>>(),
                            type_name: std::any::type_name::<::rp1::CrudJsonResult<User>>(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized: Resolve::<::rp1::CrudJsonResult<User>>::SPECIALIZED,
                            abort: Resolve::<::rp1::CrudJsonResult<User>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<User>(),
                            type_name: std::any::type_name::<User>(),
                            parent: None
                                .or(Some(std::any::TypeId::of::<::rp1::CrudJsonResult<User>>())),
                            location: ("example/src/main.rs", 41u32, 8u32),
                            specialized: Resolve::<User>::SPECIALIZED,
                            abort: Resolve::<User>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_read_fn_5857465909367393825 as rocket_uri_macro_read_fn;
    #[table_name = "users"]
    pub struct UpdatePatchUser {
        #[validate(email)]
        username: Option<String>,
        role: Option<String>,
    }
    impl ::validator::Validate for UpdatePatchUser {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_args(())
        }
    }
    #[allow(clippy::all)]
    impl<'v_a> ::validator::ValidateArgs<'v_a> for UpdatePatchUser {
        type Args = ();
        #[allow(unused_mut)]
        #[allow(unused_variable)]
        fn validate_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            let mut errors = ::validator::ValidationErrors::new();
            if let Some(ref username) = self.username {
                if !::validator::validate_email(username) {
                    let mut err = ::validator::ValidationError::new("email");
                    err.add_param(::std::borrow::Cow::from("value"), &username);
                    errors.add("username", err);
                }
            }
            let mut result = if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            };
            result
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UpdatePatchUser {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "username" => _serde::__private::Ok(__Field::__field0),
                            "role" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"username" => _serde::__private::Ok(__Field::__field0),
                            b"role" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UpdatePatchUser>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UpdatePatchUser;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UpdatePatchUser",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct UpdatePatchUser with 2 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct UpdatePatchUser with 2 elements",
                                ));
                            }
                        };
                        _serde::__private::Ok(UpdatePatchUser {
                            username: __field0,
                            role: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Option<String>> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<String>> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "username",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Option<String>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "role",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Option<String>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("username") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("role") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(UpdatePatchUser {
                            username: __field0,
                            role: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["username", "role"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UpdatePatchUser",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UpdatePatchUser>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_snake_case)]
    const _: () = { # [doc = r" Rocket generated FormForm context."] # [doc (hidden)] pub struct FromFormGeneratedContext < '__f > { __opts : :: rocket :: form :: prelude :: Options , __errors : :: rocket :: form :: prelude :: Errors < '__f > , __parent : :: std :: option :: Option < & '__f :: rocket :: form :: prelude :: Name > , username : :: std :: option :: Option < < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , role : :: std :: option :: Option < < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , } # [allow (unused_imports)] use :: rocket :: http :: uncased :: AsUncased ; impl < '__f > :: rocket :: form :: prelude :: FromForm < '__f > for UpdatePatchUser { type Context = FromFormGeneratedContext < '__f > ; fn init (__opts : :: rocket :: form :: prelude :: Options) -> Self :: Context { Self :: Context { __opts , __errors : :: rocket :: form :: prelude :: Errors :: new () , __parent : :: std :: option :: Option :: None , username : :: std :: option :: Option :: None , role : :: std :: option :: Option :: None , } } fn push_value (__c : & mut Self :: Context , __f : :: rocket :: form :: prelude :: ValueField < '__f >) { __c . __parent = __f . name . parent () ; match __f . name . key_lossy () . as_str () { "username" => { { < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . username . get_or_insert_with (| | < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "role" => { { < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . role . get_or_insert_with (| | < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } __k if __k == "_method" || ! __c . __opts . strict => { } _ => __c . __errors . push (__f . unexpected ()) , } } # [allow (clippy :: let_unit_value , clippy :: type_complexity , clippy :: type_repetition_in_bounds , clippy :: used_underscore_binding)] fn push_data < 'life0 , 'life1 , 'async_trait > (__c : & 'life0 mut FromFormGeneratedContext < '__f > , __f : :: rocket :: form :: prelude :: DataField < '__f , 'life1 >) -> :: core :: pin :: Pin < Box < dyn :: core :: future :: Future < Output = () > + :: core :: marker :: Send + 'async_trait > > where '__f : 'async_trait , 'life0 : 'async_trait , 'life1 : 'async_trait { Box :: pin (async move { let __c = __c ; let __f = __f ; let _ : () = { __c . __parent = __f . name . parent () ; match __f . name . key_lossy () . as_str () { "username" => { { let _fut = < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . username . get_or_insert_with (| | < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "role" => { { let _fut = < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . role . get_or_insert_with (| | < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } __k if __k == "_method" || ! __c . __opts . strict => { } _ => __c . __errors . push (__f . unexpected ()) , } } ; }) } fn finalize (mut __c : Self :: Context) -> :: std :: result :: Result < Self , :: rocket :: form :: prelude :: Errors < '__f > > { # [allow (unused_imports)] use :: rocket :: form :: prelude :: validate :: * ; let username = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "username")) ; let __opts = __c . __opts ; __c . username . map_or_else (| | { < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| username | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | username) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (username) => :: std :: option :: Option :: Some (username) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let role = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "role")) ; let __opts = __c . __opts ; __c . role . map_or_else (| | { < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| role | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | role) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (role) => :: std :: option :: Option :: Some (role) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; if ! __c . __errors . is_empty () { return :: std :: result :: Result :: Err (__c . __errors) ; } let __o = Self { username : username . unwrap () , role : role . unwrap () , } ; if ! __c . __errors . is_empty () { return :: std :: result :: Result :: Err (__c . __errors) ; } Ok (__o) } } };
    #[allow(non_snake_case, unused_extern_crates, unused_imports)]
    fn _impl_as_changeset_for_updatepatchuser() {
        extern crate std;
        use diesel;
        use diesel::query_builder::AsChangeset;
        use diesel::prelude::*;
        impl<'update> AsChangeset for &'update UpdatePatchUser {
            type Target = users::table;
            type Changeset = <(
                std::option::Option<diesel::dsl::Eq<users::username, &'update String>>,
                std::option::Option<diesel::dsl::Eq<users::role, &'update String>>,
            ) as AsChangeset>::Changeset;
            fn as_changeset(self) -> Self::Changeset {
                (
                    self.username.as_ref().map(|x| users::username.eq(x)),
                    self.role.as_ref().map(|x| users::role.eq(x)),
                )
                    .as_changeset()
            }
        }
        impl<'update> AsChangeset for UpdatePatchUser {
            type Target = users::table;
            type Changeset = <(
                std::option::Option<diesel::dsl::Eq<users::username, String>>,
                std::option::Option<diesel::dsl::Eq<users::role, String>>,
            ) as AsChangeset>::Changeset;
            fn as_changeset(self) -> Self::Changeset {
                (
                    self.username.map(|x| users::username.eq(x)),
                    self.role.map(|x| users::role.eq(x)),
                )
                    .as_changeset()
            }
        }
    }
    #[allow(non_snake_case, unused_extern_crates, unused_imports)]
    fn _impl_queryable_for_updatepatchuser() {
        extern crate std;
        use diesel;
        use diesel::Queryable;
        impl<__DB: diesel::backend::Backend, __ST> Queryable<__ST, __DB> for UpdatePatchUser
        where
            (Option<String>, Option<String>): Queryable<__ST, __DB>,
        {
            type Row = <(Option<String>, Option<String>) as Queryable<__ST, __DB>>::Row;
            fn build(row: Self::Row) -> Self {
                let row: (Option<String>, Option<String>) = Queryable::build(row);
                Self {
                    username: (row.0.into()),
                    role: (row.1.into()),
                }
            }
        }
    }
    #[table_name = "users"]
    pub struct UpdatePutUser {
        pub id: i32,
        #[validate(email)]
        username: String,
        role: String,
        created_at: rp1::datetime::OffsetDateTime,
        updated_at: rp1::datetime::OffsetDateTime,
    }
    impl ::validator::Validate for UpdatePutUser {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_args(())
        }
    }
    #[allow(clippy::all)]
    impl<'v_a> ::validator::ValidateArgs<'v_a> for UpdatePutUser {
        type Args = ();
        #[allow(unused_mut)]
        #[allow(unused_variable)]
        fn validate_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            let mut errors = ::validator::ValidationErrors::new();
            if !::validator::validate_email(&self.username) {
                let mut err = ::validator::ValidationError::new("email");
                err.add_param(::std::borrow::Cow::from("value"), &&self.username);
                errors.add("username", err);
            }
            let mut result = if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            };
            result
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UpdatePutUser {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "username" => _serde::__private::Ok(__Field::__field1),
                            "role" => _serde::__private::Ok(__Field::__field2),
                            "created_at" => _serde::__private::Ok(__Field::__field3),
                            "updated_at" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"username" => _serde::__private::Ok(__Field::__field1),
                            b"role" => _serde::__private::Ok(__Field::__field2),
                            b"created_at" => _serde::__private::Ok(__Field::__field3),
                            b"updated_at" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UpdatePutUser>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UpdatePutUser;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct UpdatePutUser")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<i32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct UpdatePutUser with 5 elements",
                                        ),
                                    );
                                }
                            };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct UpdatePutUser with 5 elements",
                                        ),
                                    );
                                }
                            };
                        let __field2 =
                            match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct UpdatePutUser with 5 elements",
                                        ),
                                    );
                                }
                            };
                        let __field3 = match match _serde::de::SeqAccess::next_element::<
                            rp1::datetime::OffsetDateTime,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct UpdatePutUser with 5 elements",
                                ));
                            }
                        };
                        let __field4 = match match _serde::de::SeqAccess::next_element::<
                            rp1::datetime::OffsetDateTime,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct UpdatePutUser with 5 elements",
                                ));
                            }
                        };
                        _serde::__private::Ok(UpdatePutUser {
                            id: __field0,
                            username: __field1,
                            role: __field2,
                            created_at: __field3,
                            updated_at: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i32> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> =
                            _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> =
                            _serde::__private::None;
                        let mut __field3: _serde::__private::Option<rp1::datetime::OffsetDateTime> =
                            _serde::__private::None;
                        let mut __field4: _serde::__private::Option<rp1::datetime::OffsetDateTime> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<i32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "username",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<String>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "role",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<String>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "created_at",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            rp1::datetime::OffsetDateTime,
                                        >(&mut __map)
                                        {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "updated_at",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            rp1::datetime::OffsetDateTime,
                                        >(&mut __map)
                                        {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("username") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("role") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("created_at") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("updated_at") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(UpdatePutUser {
                            id: __field0,
                            username: __field1,
                            role: __field2,
                            created_at: __field3,
                            updated_at: __field4,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] =
                    &["id", "username", "role", "created_at", "updated_at"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UpdatePutUser",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UpdatePutUser>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_snake_case)]
    const _: () = { # [doc = r" Rocket generated FormForm context."] # [doc (hidden)] pub struct FromFormGeneratedContext < '__f > { __opts : :: rocket :: form :: prelude :: Options , __errors : :: rocket :: form :: prelude :: Errors < '__f > , __parent : :: std :: option :: Option < & '__f :: rocket :: form :: prelude :: Name > , id : :: std :: option :: Option < < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , username : :: std :: option :: Option < < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , role : :: std :: option :: Option < < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , created_at : :: std :: option :: Option < < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , updated_at : :: std :: option :: Option < < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , } # [allow (unused_imports)] use :: rocket :: http :: uncased :: AsUncased ; impl < '__f > :: rocket :: form :: prelude :: FromForm < '__f > for UpdatePutUser { type Context = FromFormGeneratedContext < '__f > ; fn init (__opts : :: rocket :: form :: prelude :: Options) -> Self :: Context { Self :: Context { __opts , __errors : :: rocket :: form :: prelude :: Errors :: new () , __parent : :: std :: option :: Option :: None , id : :: std :: option :: Option :: None , username : :: std :: option :: Option :: None , role : :: std :: option :: Option :: None , created_at : :: std :: option :: Option :: None , updated_at : :: std :: option :: Option :: None , } } fn push_value (__c : & mut Self :: Context , __f : :: rocket :: form :: prelude :: ValueField < '__f >) { __c . __parent = __f . name . parent () ; match __f . name . key_lossy () . as_str () { "id" => { { < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . id . get_or_insert_with (| | < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "username" => { { < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . username . get_or_insert_with (| | < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "role" => { { < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . role . get_or_insert_with (| | < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "created_at" => { { < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . created_at . get_or_insert_with (| | < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "updated_at" => { { < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . updated_at . get_or_insert_with (| | < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } __k if __k == "_method" || ! __c . __opts . strict => { } _ => __c . __errors . push (__f . unexpected ()) , } } # [allow (clippy :: let_unit_value , clippy :: type_complexity , clippy :: type_repetition_in_bounds , clippy :: used_underscore_binding)] fn push_data < 'life0 , 'life1 , 'async_trait > (__c : & 'life0 mut FromFormGeneratedContext < '__f > , __f : :: rocket :: form :: prelude :: DataField < '__f , 'life1 >) -> :: core :: pin :: Pin < Box < dyn :: core :: future :: Future < Output = () > + :: core :: marker :: Send + 'async_trait > > where '__f : 'async_trait , 'life0 : 'async_trait , 'life1 : 'async_trait { Box :: pin (async move { let __c = __c ; let __f = __f ; let _ : () = { __c . __parent = __f . name . parent () ; match __f . name . key_lossy () . as_str () { "id" => { { let _fut = < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . id . get_or_insert_with (| | < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "username" => { { let _fut = < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . username . get_or_insert_with (| | < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "role" => { { let _fut = < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . role . get_or_insert_with (| | < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "created_at" => { { let _fut = < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . created_at . get_or_insert_with (| | < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "updated_at" => { { let _fut = < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . updated_at . get_or_insert_with (| | < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } __k if __k == "_method" || ! __c . __opts . strict => { } _ => __c . __errors . push (__f . unexpected ()) , } } ; }) } fn finalize (mut __c : Self :: Context) -> :: std :: result :: Result < Self , :: rocket :: form :: prelude :: Errors < '__f > > { # [allow (unused_imports)] use :: rocket :: form :: prelude :: validate :: * ; let id = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "id")) ; let __opts = __c . __opts ; __c . id . map_or_else (| | { < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| id | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | id) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (id) => :: std :: option :: Option :: Some (id) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let username = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "username")) ; let __opts = __c . __opts ; __c . username . map_or_else (| | { < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| username | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | username) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (username) => :: std :: option :: Option :: Some (username) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let role = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "role")) ; let __opts = __c . __opts ; __c . role . map_or_else (| | { < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| role | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | role) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (role) => :: std :: option :: Option :: Some (role) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let created_at = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "created_at")) ; let __opts = __c . __opts ; __c . created_at . map_or_else (| | { < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| created_at | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | created_at) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (created_at) => :: std :: option :: Option :: Some (created_at) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let updated_at = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "updated_at")) ; let __opts = __c . __opts ; __c . updated_at . map_or_else (| | { < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| updated_at | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | updated_at) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (updated_at) => :: std :: option :: Option :: Some (updated_at) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; if ! __c . __errors . is_empty () { return :: std :: result :: Result :: Err (__c . __errors) ; } let __o = Self { id : id . unwrap () , username : username . unwrap () , role : role . unwrap () , created_at : created_at . unwrap () , updated_at : updated_at . unwrap () , } ; if ! __c . __errors . is_empty () { return :: std :: result :: Result :: Err (__c . __errors) ; } Ok (__o) } } };
    #[allow(non_snake_case, unused_extern_crates, unused_imports)]
    fn _impl_as_changeset_for_updateputuser() {
        extern crate std;
        use diesel;
        use diesel::query_builder::AsChangeset;
        use diesel::prelude::*;
        impl<'update> AsChangeset for &'update UpdatePutUser {
            type Target = users::table;
            type Changeset = <(
                diesel::dsl::Eq<users::username, &'update String>,
                diesel::dsl::Eq<users::role, &'update String>,
                diesel::dsl::Eq<users::created_at, &'update rp1::datetime::OffsetDateTime>,
                diesel::dsl::Eq<users::updated_at, &'update rp1::datetime::OffsetDateTime>,
            ) as AsChangeset>::Changeset;
            fn as_changeset(self) -> Self::Changeset {
                (
                    users::username.eq(&self.username),
                    users::role.eq(&self.role),
                    users::created_at.eq(&self.created_at),
                    users::updated_at.eq(&self.updated_at),
                )
                    .as_changeset()
            }
        }
        impl<'update> AsChangeset for UpdatePutUser {
            type Target = users::table;
            type Changeset = <(
                diesel::dsl::Eq<users::username, String>,
                diesel::dsl::Eq<users::role, String>,
                diesel::dsl::Eq<users::created_at, rp1::datetime::OffsetDateTime>,
                diesel::dsl::Eq<users::updated_at, rp1::datetime::OffsetDateTime>,
            ) as AsChangeset>::Changeset;
            fn as_changeset(self) -> Self::Changeset {
                (
                    users::username.eq(self.username),
                    users::role.eq(self.role),
                    users::created_at.eq(self.created_at),
                    users::updated_at.eq(self.updated_at),
                )
                    .as_changeset()
            }
        }
    }
    #[allow(non_snake_case, unused_extern_crates, unused_imports)]
    fn _impl_queryable_for_updateputuser() {
        extern crate std;
        use diesel;
        use diesel::Queryable;
        impl<__DB: diesel::backend::Backend, __ST> Queryable<__ST, __DB> for UpdatePutUser
        where
            (
                i32,
                String,
                String,
                rp1::datetime::OffsetDateTime,
                rp1::datetime::OffsetDateTime,
            ): Queryable<__ST, __DB>,
        {
            type Row = <(
                i32,
                String,
                String,
                rp1::datetime::OffsetDateTime,
                rp1::datetime::OffsetDateTime,
            ) as Queryable<__ST, __DB>>::Row;
            fn build(row: Self::Row) -> Self {
                let row: (
                    i32,
                    String,
                    String,
                    rp1::datetime::OffsetDateTime,
                    rp1::datetime::OffsetDateTime,
                ) = Queryable::build(row);
                Self {
                    id: (row.0.into()),
                    username: (row.1.into()),
                    role: (row.2.into()),
                    created_at: (row.3.into()),
                    updated_at: (row.4.into()),
                }
            }
        }
    }
    impl UpdatePutUser {
        pub fn create(base: &User, patch: &UpdatePatchUser) -> UpdatePutUser {
            let username = if let Some(ref v) = patch.username {
                v.clone()
            } else {
                base.username.clone()
            };
            let role = if let Some(ref v) = patch.role {
                v.clone()
            } else {
                base.role.clone()
            };
            UpdatePutUser {
                username,
                role,
                id: base.id.clone(),
                created_at: base.created_at.clone(),
                updated_at: base.updated_at.clone(),
            }
        }
        pub fn validate_update(&self, base: &User) -> ::rp1::CrudResult<()> {
            if self.id != base.id {
                return Err(::rp1::CrudError::UnchangeableField("id".to_owned()));
            }
            if self.created_at != base.created_at {
                return Err(::rp1::CrudError::UnchangeableField("created_at".to_owned()));
            }
            if self.updated_at != base.updated_at {
                return Err(::rp1::CrudError::UnchangeableField("updated_at".to_owned()));
            }
            Ok(())
        }
        pub fn into_patch(self, base: &User) -> UpdatePatchUser {
            UpdatePatchUser {
                username: if self.username == base.username {
                    None
                } else {
                    Some(self.username)
                },
                role: if self.role == base.role {
                    None
                } else {
                    Some(self.role)
                },
            }
        }
    }
    impl ::rp1::CrudUpdatable for User {
        type PatchType = UpdatePatchUser;
        type PutType = UpdatePutUser;
    }
    async fn update_put_fn_help(
        db: Db,
        id: i32,
        value: UpdatePutUser,
        auth_user: <User as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<User> {
        let row = db
            .run(move |conn| crate::schema::users::table.find(id).first::<User>(conn))
            .await?;
        if !<User as ::rp1::CheckPermissions>::allow_update(&row, &value, &auth_user) {
            return Err(::rp1::CrudError::NotFound);
        }
        value.validate_update(&row)?;
        use ::validator::Validate;
        value.validate()?;
        Ok(::rocket::serde::json::Json(
            db.run(move |conn| {
                diesel::update(crate::schema::users::table.find(id))
                    .set(&value)
                    .get_result(conn)
            })
            .await?,
        ))
    }
    async fn update_patch_fn_help(
        db: Db,
        id: i32,
        value: UpdatePatchUser,
        auth_user: <User as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<User> {
        let row = db
            .run(move |conn| crate::schema::users::table.find(id).first::<User>(conn))
            .await?;
        let put_value = UpdatePutUser::create(&row, &value);
        if !<User as ::rp1::CheckPermissions>::allow_update(&row, &put_value, &auth_user) {
            return Err(::rp1::CrudError::NotFound);
        }
        use ::validator::Validate;
        value.validate()?;
        Ok(::rocket::serde::json::Json(
            db.run(move |conn| {
                diesel::update(crate::schema::users::table.find(id))
                    .set(&value)
                    .get_result(conn)
            })
            .await?,
        ))
    }
    async fn update_patch_fn_json(
        db: Db,
        id: i32,
        value: ::rocket::serde::json::Json<UpdatePatchUser>,
        auth_user: <User as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<User> {
        let value = value.into_inner();
        update_patch_fn_help(db, id, value, auth_user).await
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct update_patch_fn_json {}
    /// Rocket code generated proxy static conversion implementations.
    impl update_patch_fn_json {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::user",
                                                "example/src/main.rs",
                                                40u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::user",
                                                "example/src/main.rs",
                                                40u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let __rocket_id: i32 = match __req.routed_segment(0usize) {
                        ::std::option::Option::Some(__s) => {
                            match <i32 as ::rocket::request::FromParam>::from_param(__s) {
                                ::std::result::Result::Ok(__v) => __v,
                                ::std::result::Result::Err(__error) => {
                                    return {
                                        {
                                            let lvl = ::log::Level::Warn;
                                            if lvl <= ::log::STATIC_MAX_LEVEL
                                                && lvl <= ::log::max_level()
                                            {
                                                :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , ": " , "` param guard parsed forwarding with error "] , & match (& "id" , & "i32" , & __error) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ;
                                            }
                                        };
                                        ::rocket::outcome::Outcome::Forward(__data)
                                    }
                                }
                            }
                        }
                        ::std::option::Option::None => {
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Internal invariant broken: dyn param not found."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::user", "example/src/main.rs", 43u32),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Please report this to the Rocket issue tracker."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::user", "example/src/main.rs", 43u32),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["https://github.com/SergioBenitez/Rocket/issues"],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::user", "example/src/main.rs", 43u32),
                                    );
                                }
                            };
                            return ::rocket::outcome::Outcome::Forward(__data);
                        }
                    };
                    let __rocket_value : :: rocket :: serde :: json :: Json < UpdatePatchUser > = match < :: rocket :: serde :: json :: Json < UpdatePatchUser > as :: rocket :: data :: FromData > :: from_data (__req , __data) . await { :: rocket :: outcome :: Outcome :: Success (__d) => __d , :: rocket :: outcome :: Outcome :: Forward (__d) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard is forwarding."] , & match (& ":: rocket :: serde :: json :: Json < UpdatePatchUser >" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__d) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard failed: " , "."] , & match (& ":: rocket :: serde :: json :: Json < UpdatePatchUser >" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let ___responder = update_patch_fn_json(
                        __rocket_db,
                        __rocket_id,
                        __rocket_value,
                        __rocket_auth_user,
                    )
                    .await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "update_patch_fn_json",
                method: ::rocket::http::Method::Patch,
                uri: "/<id>",
                handler: monomorphized_function,
                format: ::std::option::Option::Some(::rocket::http::MediaType::const_new(
                    "application",
                    "json",
                    &[],
                )),
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<i32>(),
                            type_name: std::any::type_name::<i32>(),
                            parent: None,
                            location: ("example/src/main.rs", 43u32, 13u32),
                            specialized: Resolve::<i32>::SPECIALIZED,
                            abort: Resolve::<i32>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized: Resolve::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<User>(),
                            type_name: std::any::type_name::<User>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 41u32, 8u32),
                            specialized: Resolve::<User>::SPECIALIZED,
                            abort: Resolve::<User>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::CrudJsonResult<User>>(),
                            type_name: std::any::type_name::<::rp1::CrudJsonResult<User>>(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized: Resolve::<::rp1::CrudJsonResult<User>>::SPECIALIZED,
                            abort: Resolve::<::rp1::CrudJsonResult<User>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<User>(),
                            type_name: std::any::type_name::<User>(),
                            parent: None
                                .or(Some(std::any::TypeId::of::<::rp1::CrudJsonResult<User>>())),
                            location: ("example/src/main.rs", 41u32, 8u32),
                            specialized: Resolve::<User>::SPECIALIZED,
                            abort: Resolve::<User>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_update_patch_fn_json_7502538002501609795 as rocket_uri_macro_update_patch_fn_json;
    async fn update_patch_fn_form(
        db: Db,
        id: i32,
        value: ::rocket::form::Form<UpdatePatchUser>,
        auth_user: <User as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<User> {
        let value = value.into_inner();
        update_patch_fn_help(db, id, value, auth_user).await
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct update_patch_fn_form {}
    /// Rocket code generated proxy static conversion implementations.
    impl update_patch_fn_form {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::user",
                                                "example/src/main.rs",
                                                40u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::user",
                                                "example/src/main.rs",
                                                40u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let __rocket_id: i32 = match __req.routed_segment(0usize) {
                        ::std::option::Option::Some(__s) => {
                            match <i32 as ::rocket::request::FromParam>::from_param(__s) {
                                ::std::result::Result::Ok(__v) => __v,
                                ::std::result::Result::Err(__error) => {
                                    return {
                                        {
                                            let lvl = ::log::Level::Warn;
                                            if lvl <= ::log::STATIC_MAX_LEVEL
                                                && lvl <= ::log::max_level()
                                            {
                                                :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , ": " , "` param guard parsed forwarding with error "] , & match (& "id" , & "i32" , & __error) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ;
                                            }
                                        };
                                        ::rocket::outcome::Outcome::Forward(__data)
                                    }
                                }
                            }
                        }
                        ::std::option::Option::None => {
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Internal invariant broken: dyn param not found."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::user", "example/src/main.rs", 43u32),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Please report this to the Rocket issue tracker."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::user", "example/src/main.rs", 43u32),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["https://github.com/SergioBenitez/Rocket/issues"],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::user", "example/src/main.rs", 43u32),
                                    );
                                }
                            };
                            return ::rocket::outcome::Outcome::Forward(__data);
                        }
                    };
                    let __rocket_value : :: rocket :: form :: Form < UpdatePatchUser > = match < :: rocket :: form :: Form < UpdatePatchUser > as :: rocket :: data :: FromData > :: from_data (__req , __data) . await { :: rocket :: outcome :: Outcome :: Success (__d) => __d , :: rocket :: outcome :: Outcome :: Forward (__d) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard is forwarding."] , & match (& ":: rocket :: form :: Form < UpdatePatchUser >" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__d) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard failed: " , "."] , & match (& ":: rocket :: form :: Form < UpdatePatchUser >" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let ___responder = update_patch_fn_form(
                        __rocket_db,
                        __rocket_id,
                        __rocket_value,
                        __rocket_auth_user,
                    )
                    .await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "update_patch_fn_form",
                method: ::rocket::http::Method::Patch,
                uri: "/<id>",
                handler: monomorphized_function,
                format: ::std::option::Option::Some(::rocket::http::MediaType::const_new(
                    "application",
                    "x-www-form-urlencoded",
                    &[],
                )),
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<i32>(),
                            type_name: std::any::type_name::<i32>(),
                            parent: None,
                            location: ("example/src/main.rs", 43u32, 13u32),
                            specialized: Resolve::<i32>::SPECIALIZED,
                            abort: Resolve::<i32>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized: Resolve::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<User>(),
                            type_name: std::any::type_name::<User>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 41u32, 8u32),
                            specialized: Resolve::<User>::SPECIALIZED,
                            abort: Resolve::<User>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::CrudJsonResult<User>>(),
                            type_name: std::any::type_name::<::rp1::CrudJsonResult<User>>(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized: Resolve::<::rp1::CrudJsonResult<User>>::SPECIALIZED,
                            abort: Resolve::<::rp1::CrudJsonResult<User>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<User>(),
                            type_name: std::any::type_name::<User>(),
                            parent: None
                                .or(Some(std::any::TypeId::of::<::rp1::CrudJsonResult<User>>())),
                            location: ("example/src/main.rs", 41u32, 8u32),
                            specialized: Resolve::<User>::SPECIALIZED,
                            abort: Resolve::<User>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_update_patch_fn_form_17919187377501702018 as rocket_uri_macro_update_patch_fn_form;
    async fn update_put_fn_json(
        db: Db,
        id: i32,
        value: ::rocket::serde::json::Json<UpdatePutUser>,
        auth_user: <User as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<User> {
        let value = value.into_inner();
        update_put_fn_help(db, id, value, auth_user).await
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct update_put_fn_json {}
    /// Rocket code generated proxy static conversion implementations.
    impl update_put_fn_json {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::user",
                                                "example/src/main.rs",
                                                40u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::user",
                                                "example/src/main.rs",
                                                40u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let __rocket_id: i32 = match __req.routed_segment(0usize) {
                        ::std::option::Option::Some(__s) => {
                            match <i32 as ::rocket::request::FromParam>::from_param(__s) {
                                ::std::result::Result::Ok(__v) => __v,
                                ::std::result::Result::Err(__error) => {
                                    return {
                                        {
                                            let lvl = ::log::Level::Warn;
                                            if lvl <= ::log::STATIC_MAX_LEVEL
                                                && lvl <= ::log::max_level()
                                            {
                                                :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , ": " , "` param guard parsed forwarding with error "] , & match (& "id" , & "i32" , & __error) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ;
                                            }
                                        };
                                        ::rocket::outcome::Outcome::Forward(__data)
                                    }
                                }
                            }
                        }
                        ::std::option::Option::None => {
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Internal invariant broken: dyn param not found."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::user", "example/src/main.rs", 43u32),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Please report this to the Rocket issue tracker."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::user", "example/src/main.rs", 43u32),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["https://github.com/SergioBenitez/Rocket/issues"],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::user", "example/src/main.rs", 43u32),
                                    );
                                }
                            };
                            return ::rocket::outcome::Outcome::Forward(__data);
                        }
                    };
                    let __rocket_value : :: rocket :: serde :: json :: Json < UpdatePutUser > = match < :: rocket :: serde :: json :: Json < UpdatePutUser > as :: rocket :: data :: FromData > :: from_data (__req , __data) . await { :: rocket :: outcome :: Outcome :: Success (__d) => __d , :: rocket :: outcome :: Outcome :: Forward (__d) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard is forwarding."] , & match (& ":: rocket :: serde :: json :: Json < UpdatePutUser >" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__d) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard failed: " , "."] , & match (& ":: rocket :: serde :: json :: Json < UpdatePutUser >" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let ___responder = update_put_fn_json(
                        __rocket_db,
                        __rocket_id,
                        __rocket_value,
                        __rocket_auth_user,
                    )
                    .await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "update_put_fn_json",
                method: ::rocket::http::Method::Put,
                uri: "/<id>",
                handler: monomorphized_function,
                format: ::std::option::Option::Some(::rocket::http::MediaType::const_new(
                    "application",
                    "json",
                    &[],
                )),
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<i32>(),
                            type_name: std::any::type_name::<i32>(),
                            parent: None,
                            location: ("example/src/main.rs", 43u32, 13u32),
                            specialized: Resolve::<i32>::SPECIALIZED,
                            abort: Resolve::<i32>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized: Resolve::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<User>(),
                            type_name: std::any::type_name::<User>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 41u32, 8u32),
                            specialized: Resolve::<User>::SPECIALIZED,
                            abort: Resolve::<User>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::CrudJsonResult<User>>(),
                            type_name: std::any::type_name::<::rp1::CrudJsonResult<User>>(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized: Resolve::<::rp1::CrudJsonResult<User>>::SPECIALIZED,
                            abort: Resolve::<::rp1::CrudJsonResult<User>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<User>(),
                            type_name: std::any::type_name::<User>(),
                            parent: None
                                .or(Some(std::any::TypeId::of::<::rp1::CrudJsonResult<User>>())),
                            location: ("example/src/main.rs", 41u32, 8u32),
                            specialized: Resolve::<User>::SPECIALIZED,
                            abort: Resolve::<User>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_update_put_fn_json_2567026173703949122 as rocket_uri_macro_update_put_fn_json;
    async fn update_put_fn_form(
        db: Db,
        id: i32,
        value: ::rocket::serde::json::Json<UpdatePutUser>,
        auth_user: <User as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<User> {
        let value = value.into_inner();
        update_put_fn_help(db, id, value, auth_user).await
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct update_put_fn_form {}
    /// Rocket code generated proxy static conversion implementations.
    impl update_put_fn_form {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::user",
                                                "example/src/main.rs",
                                                40u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::user",
                                                "example/src/main.rs",
                                                40u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let __rocket_id: i32 = match __req.routed_segment(0usize) {
                        ::std::option::Option::Some(__s) => {
                            match <i32 as ::rocket::request::FromParam>::from_param(__s) {
                                ::std::result::Result::Ok(__v) => __v,
                                ::std::result::Result::Err(__error) => {
                                    return {
                                        {
                                            let lvl = ::log::Level::Warn;
                                            if lvl <= ::log::STATIC_MAX_LEVEL
                                                && lvl <= ::log::max_level()
                                            {
                                                :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , ": " , "` param guard parsed forwarding with error "] , & match (& "id" , & "i32" , & __error) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ;
                                            }
                                        };
                                        ::rocket::outcome::Outcome::Forward(__data)
                                    }
                                }
                            }
                        }
                        ::std::option::Option::None => {
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Internal invariant broken: dyn param not found."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::user", "example/src/main.rs", 43u32),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Please report this to the Rocket issue tracker."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::user", "example/src/main.rs", 43u32),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["https://github.com/SergioBenitez/Rocket/issues"],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::user", "example/src/main.rs", 43u32),
                                    );
                                }
                            };
                            return ::rocket::outcome::Outcome::Forward(__data);
                        }
                    };
                    let __rocket_value : :: rocket :: serde :: json :: Json < UpdatePutUser > = match < :: rocket :: serde :: json :: Json < UpdatePutUser > as :: rocket :: data :: FromData > :: from_data (__req , __data) . await { :: rocket :: outcome :: Outcome :: Success (__d) => __d , :: rocket :: outcome :: Outcome :: Forward (__d) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard is forwarding."] , & match (& ":: rocket :: serde :: json :: Json < UpdatePutUser >" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__d) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard failed: " , "."] , & match (& ":: rocket :: serde :: json :: Json < UpdatePutUser >" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let ___responder = update_put_fn_form(
                        __rocket_db,
                        __rocket_id,
                        __rocket_value,
                        __rocket_auth_user,
                    )
                    .await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "update_put_fn_form",
                method: ::rocket::http::Method::Put,
                uri: "/<id>",
                handler: monomorphized_function,
                format: ::std::option::Option::Some(::rocket::http::MediaType::const_new(
                    "application",
                    "x-www-form-urlencoded",
                    &[],
                )),
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<i32>(),
                            type_name: std::any::type_name::<i32>(),
                            parent: None,
                            location: ("example/src/main.rs", 43u32, 13u32),
                            specialized: Resolve::<i32>::SPECIALIZED,
                            abort: Resolve::<i32>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized: Resolve::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<User>(),
                            type_name: std::any::type_name::<User>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 41u32, 8u32),
                            specialized: Resolve::<User>::SPECIALIZED,
                            abort: Resolve::<User>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::CrudJsonResult<User>>(),
                            type_name: std::any::type_name::<::rp1::CrudJsonResult<User>>(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized: Resolve::<::rp1::CrudJsonResult<User>>::SPECIALIZED,
                            abort: Resolve::<::rp1::CrudJsonResult<User>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<User>(),
                            type_name: std::any::type_name::<User>(),
                            parent: None
                                .or(Some(std::any::TypeId::of::<::rp1::CrudJsonResult<User>>())),
                            location: ("example/src/main.rs", 41u32, 8u32),
                            specialized: Resolve::<User>::SPECIALIZED,
                            abort: Resolve::<User>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_update_put_fn_form_12684093813034386669 as rocket_uri_macro_update_put_fn_form;
    async fn delete_fn(
        db: Db,
        id: i32,
        auth_user: <User as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudResult<::rocket::serde::json::Value> {
        let row = db
            .run(move |conn| crate::schema::users::table.find(id).first::<User>(conn))
            .await?;
        if !<User as ::rp1::CheckPermissions>::allow_delete(&row, &auth_user) {
            return Err(::rp1::CrudError::NotFound);
        }
        let deleted = db
            .run(move |conn| diesel::delete(crate::schema::users::table.find(id)).execute(conn))
            .await?;
        Ok(::serde_json::Value::Object({
            let mut object = ::serde_json::Map::new();
            let _ = object.insert(
                ("deleted").into(),
                ::serde_json::to_value(&deleted).unwrap(),
            );
            object
        }))
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct delete_fn {}
    /// Rocket code generated proxy static conversion implementations.
    impl delete_fn {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::user",
                                                "example/src/main.rs",
                                                40u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::user",
                                                "example/src/main.rs",
                                                40u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let __rocket_id: i32 = match __req.routed_segment(0usize) {
                        ::std::option::Option::Some(__s) => {
                            match <i32 as ::rocket::request::FromParam>::from_param(__s) {
                                ::std::result::Result::Ok(__v) => __v,
                                ::std::result::Result::Err(__error) => {
                                    return {
                                        {
                                            let lvl = ::log::Level::Warn;
                                            if lvl <= ::log::STATIC_MAX_LEVEL
                                                && lvl <= ::log::max_level()
                                            {
                                                :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , ": " , "` param guard parsed forwarding with error "] , & match (& "id" , & "i32" , & __error) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ;
                                            }
                                        };
                                        ::rocket::outcome::Outcome::Forward(__data)
                                    }
                                }
                            }
                        }
                        ::std::option::Option::None => {
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Internal invariant broken: dyn param not found."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::user", "example/src/main.rs", 43u32),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Please report this to the Rocket issue tracker."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::user", "example/src/main.rs", 43u32),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["https://github.com/SergioBenitez/Rocket/issues"],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::user", "example/src/main.rs", 43u32),
                                    );
                                }
                            };
                            return ::rocket::outcome::Outcome::Forward(__data);
                        }
                    };
                    let ___responder =
                        delete_fn(__rocket_db, __rocket_id, __rocket_auth_user).await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "delete_fn",
                method: ::rocket::http::Method::Delete,
                uri: "/<id>",
                handler: monomorphized_function,
                format: ::std::option::Option::None,
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<i32>(),
                            type_name: std::any::type_name::<i32>(),
                            parent: None,
                            location: ("example/src/main.rs", 43u32, 13u32),
                            specialized: Resolve::<i32>::SPECIALIZED,
                            abort: Resolve::<i32>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized: Resolve::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<User>(),
                            type_name: std::any::type_name::<User>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 41u32, 8u32),
                            specialized: Resolve::<User>::SPECIALIZED,
                            abort: Resolve::<User>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        :: rocket :: sentinel :: Sentry { type_id : std :: any :: TypeId :: of :: < :: rp1 :: CrudResult < :: rocket :: serde :: json :: Value > > () , type_name : std :: any :: type_name :: < :: rp1 :: CrudResult < :: rocket :: serde :: json :: Value > > () , parent : None , location : ("example/src/main.rs" , 40u32 , 1u32) , specialized : Resolve :: < :: rp1 :: CrudResult < :: rocket :: serde :: json :: Value > > :: SPECIALIZED , abort : Resolve :: < :: rp1 :: CrudResult < :: rocket :: serde :: json :: Value > > :: abort , }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rocket::serde::json::Value>(),
                            type_name: std::any::type_name::<::rocket::serde::json::Value>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                ::rp1::CrudResult<::rocket::serde::json::Value>,
                            >())),
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized: Resolve::<::rocket::serde::json::Value>::SPECIALIZED,
                            abort: Resolve::<::rocket::serde::json::Value>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_delete_fn_9156415448913159010 as rocket_uri_macro_delete_fn;
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    pub enum SortableFields {
        id,
        username,
        role,
        created_at,
        updated_at,
    }
    #[allow(non_snake_case)]
    const _: () = {
        #[allow(unused_imports)]
        use ::rocket::http::uncased::AsUncased;
        impl<'__v> ::rocket::form::prelude::FromFormField<'__v> for SortableFields {
            fn from_value(
                __f: ::rocket::form::prelude::ValueField<'__v>,
            ) -> Result<Self, ::rocket::form::prelude::Errors<'__v>> {
                if __f.value.as_uncased() == "id" {
                    return ::std::result::Result::Ok(SortableFields::id);
                }
                if __f.value.as_uncased() == "username" {
                    return ::std::result::Result::Ok(SortableFields::username);
                }
                if __f.value.as_uncased() == "role" {
                    return ::std::result::Result::Ok(SortableFields::role);
                }
                if __f.value.as_uncased() == "created_at" {
                    return ::std::result::Result::Ok(SortableFields::created_at);
                }
                if __f.value.as_uncased() == "updated_at" {
                    return ::std::result::Result::Ok(SortableFields::updated_at);
                }
                const OPTS: &'static [::std::borrow::Cow<'static, str>] = &[
                    ::std::borrow::Cow::Borrowed("id"),
                    ::std::borrow::Cow::Borrowed("username"),
                    ::std::borrow::Cow::Borrowed("role"),
                    ::std::borrow::Cow::Borrowed("created_at"),
                    ::std::borrow::Cow::Borrowed("updated_at"),
                ];
                let _error = ::rocket::form::prelude::Error::from(OPTS)
                    .with_name(__f.name)
                    .with_value(__f.value);
                ::std::result::Result::Err(_error)?
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::fmt::Debug for SortableFields {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&SortableFields::id,) => ::core::fmt::Formatter::write_str(f, "id"),
                (&SortableFields::username,) => ::core::fmt::Formatter::write_str(f, "username"),
                (&SortableFields::role,) => ::core::fmt::Formatter::write_str(f, "role"),
                (&SortableFields::created_at,) => {
                    ::core::fmt::Formatter::write_str(f, "created_at")
                }
                (&SortableFields::updated_at,) => {
                    ::core::fmt::Formatter::write_str(f, "updated_at")
                }
            }
        }
    }
    use ::rocket::request::{self, Request, FromRequest};
    pub struct UserFilterSpec {
        id: Vec<::rp1::FilterOperator<i32>>,
        username: Vec<::rp1::FilterOperator<String>>,
        role: Vec<::rp1::FilterOperator<String>>,
        created_at: Vec<::rp1::FilterOperator<rp1::datetime::OffsetDateTime>>,
        updated_at: Vec<::rp1::FilterOperator<rp1::datetime::OffsetDateTime>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for UserFilterSpec {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                UserFilterSpec {
                    id: ref __self_0_0,
                    username: ref __self_0_1,
                    role: ref __self_0_2,
                    created_at: ref __self_0_3,
                    updated_at: ref __self_0_4,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "UserFilterSpec");
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "id", &&(*__self_0_0));
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "username",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "role",
                        &&(*__self_0_2),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "created_at",
                        &&(*__self_0_3),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "updated_at",
                        &&(*__self_0_4),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::rp1::CrudFilterSpec for User {
        type FilterSpecType = UserFilterSpec;
    }
    impl Default for UserFilterSpec {
        fn default() -> UserFilterSpec {
            UserFilterSpec {
                id: ::alloc::vec::Vec::new(),
                username: ::alloc::vec::Vec::new(),
                role: ::alloc::vec::Vec::new(),
                created_at: ::alloc::vec::Vec::new(),
                updated_at: ::alloc::vec::Vec::new(),
            }
        }
    }
    #[doc(hidden)]
    pub struct FilterSpecContext<'r> {
        spec: UserFilterSpec,
        errors: ::rocket::form::Errors<'r>,
    }
    impl<'r> FilterSpecContext<'r> {
        fn push(&mut self, mut field_name: rocket::form::name::NameView<'r>, value: &'r str) {
            use std::convert::{TryFrom, TryInto};
            let field_filtered = match field_name.key() {
                Some(k) => k,
                None => {
                    self.errors
                        .push(::rocket::form::error::ErrorKind::Unexpected.into());
                    return;
                }
            };
            field_name.shift();
            let field_operator = field_name.key().map(|k| k.as_str()).unwrap_or("eq");
            match field_filtered.as_str() {
                "id" => match ::rp1::FilterOperator::try_parse(field_operator, value) {
                    Ok(v) => self.spec.id.push(v),
                    Err(e) => self.errors.push(::rp1::ParseError::from(e).into()),
                },
                "username" => match ::rp1::FilterOperator::try_parse(field_operator, value) {
                    Ok(v) => self.spec.username.push(v),
                    Err(e) => self.errors.push(::rp1::ParseError::from(e).into()),
                },
                "role" => match ::rp1::FilterOperator::try_parse(field_operator, value) {
                    Ok(v) => self.spec.role.push(v),
                    Err(e) => self.errors.push(::rp1::ParseError::from(e).into()),
                },
                "created_at" => match ::rp1::FilterOperator::try_parse(field_operator, value) {
                    Ok(v) => self.spec.created_at.push(v),
                    Err(e) => self.errors.push(::rp1::ParseError::from(e).into()),
                },
                "updated_at" => match ::rp1::FilterOperator::try_parse(field_operator, value) {
                    Ok(v) => self.spec.updated_at.push(v),
                    Err(e) => self.errors.push(::rp1::ParseError::from(e).into()),
                },
                _ => {
                    self.errors
                        .push(::rocket::form::error::ErrorKind::Unexpected.into());
                }
            };
        }
    }
    impl<'r> ::rocket::form::FromForm<'r> for UserFilterSpec {
        type Context = FilterSpecContext<'r>;
        fn init(opts: ::rocket::form::Options) -> Self::Context {
            FilterSpecContext {
                spec: Default::default(),
                errors: ::rocket::form::Errors::new(),
            }
        }
        fn push_value(ctxt: &mut Self::Context, field: ::rocket::form::ValueField<'r>) {
            ctxt.push(field.name, field.value);
        }
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn push_data<'life0, 'life1, 'async_trait>(
            ctxt: &'life0 mut Self::Context,
            field: ::rocket::form::DataField<'r, 'life1>,
        ) -> ::core::pin::Pin<
            Box<dyn ::core::future::Future<Output = ()> + ::core::marker::Send + 'async_trait>,
        >
        where
            'r: 'async_trait,
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                let ctxt = ctxt;
                let field = field;
                let _: () = {
                    use rocket::data::ToByteUnit;
                    let limit = 256.kibibytes();
                    let bytes = match field.data.open(limit).into_bytes().await {
                        Ok(b) => b,
                        Err(e) => {
                            ctxt.errors.push(e.into());
                            return;
                        }
                    };
                    if !bytes.is_complete() {
                        ctxt.errors
                            .push(rocket::form::error::ErrorKind::from((None, Some(limit))).into());
                        return;
                    }
                    let bytes = bytes.into_inner();
                    let bytes = {
                        struct Local<T>(T);
                        &field.request.local_cache(move || Local(bytes)).0
                    };
                    let data = match std::str::from_utf8(bytes) {
                        Ok(d) => d.into(),
                        Err(e) => {
                            ctxt.errors.push(e.into());
                            return;
                        }
                    };
                    ctxt.push(field.name, data);
                };
            })
        }
        fn finalize(ctxt: Self::Context) -> ::rocket::form::Result<'r, Self> {
            if ctxt.errors.is_empty() {
                Ok(ctxt.spec)
            } else {
                Err(ctxt.errors)
            }
        }
    }
    async fn list_fn(
        db: Db,
        sort: Vec<::rp1::SortSpec<SortableFields>>,
        filter: UserFilterSpec,
        offset: Option<i64>,
        limit: Option<i64>,
        auth_user: <User as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<Vec<User>> {
        let offset = i64::max(0, offset.unwrap_or(0));
        let limit = i64::max(1, i64::min(100i64, limit.unwrap_or(100i64)));
        let results = db
            .run(move |conn| {
                use ::rp1::SortDirection;
                use ::diesel::expression::Expression;
                let mut query = crate::schema::users::table
                    .offset(offset)
                    .limit(limit)
                    .into_boxed();
                for sort_spec in sort {
                    match sort_spec.field {
                        SortableFields::id => {
                            query = if sort_spec.direction == SortDirection::Asc {
                                query.then_order_by(crate::schema::users::columns::id.asc())
                            } else {
                                query.then_order_by(crate::schema::users::columns::id.desc())
                            };
                        }
                        SortableFields::username => {
                            query = if sort_spec.direction == SortDirection::Asc {
                                query.then_order_by(crate::schema::users::columns::username.asc())
                            } else {
                                query.then_order_by(crate::schema::users::columns::username.desc())
                            };
                        }
                        SortableFields::role => {
                            query = if sort_spec.direction == SortDirection::Asc {
                                query.then_order_by(crate::schema::users::columns::role.asc())
                            } else {
                                query.then_order_by(crate::schema::users::columns::role.desc())
                            };
                        }
                        SortableFields::created_at => {
                            query = if sort_spec.direction == SortDirection::Asc {
                                query.then_order_by(crate::schema::users::columns::created_at.asc())
                            } else {
                                query
                                    .then_order_by(crate::schema::users::columns::created_at.desc())
                            };
                        }
                        SortableFields::updated_at => {
                            query = if sort_spec.direction == SortDirection::Asc {
                                query.then_order_by(crate::schema::users::columns::updated_at.asc())
                            } else {
                                query
                                    .then_order_by(crate::schema::users::columns::updated_at.desc())
                            };
                        }
                    }
                }
                for op in filter.id.iter() {
                    use ::rp1::FilterOperator;
                    use crate::schema::users::columns;
                    query = match op {
                        FilterOperator::Eq(val) => query.filter(columns::id.eq(val)),
                        FilterOperator::Ne(val) => query.filter(columns::id.ne(val)),
                        FilterOperator::Gt(val) => query.filter(columns::id.gt(val)),
                        FilterOperator::Ge(val) => query.filter(columns::id.ge(val)),
                        FilterOperator::Lt(val) => query.filter(columns::id.lt(val)),
                        FilterOperator::Le(val) => query.filter(columns::id.le(val)),
                        FilterOperator::EqAny(val) => query.filter(columns::id.eq_any(val)),
                    };
                }
                for op in filter.username.iter() {
                    use ::rp1::FilterOperator;
                    use crate::schema::users::columns;
                    query = match op {
                        FilterOperator::Eq(val) => query.filter(columns::username.eq(val)),
                        FilterOperator::Ne(val) => query.filter(columns::username.ne(val)),
                        FilterOperator::Gt(val) => query.filter(columns::username.gt(val)),
                        FilterOperator::Ge(val) => query.filter(columns::username.ge(val)),
                        FilterOperator::Lt(val) => query.filter(columns::username.lt(val)),
                        FilterOperator::Le(val) => query.filter(columns::username.le(val)),
                        FilterOperator::EqAny(val) => query.filter(columns::username.eq_any(val)),
                    };
                }
                for op in filter.role.iter() {
                    use ::rp1::FilterOperator;
                    use crate::schema::users::columns;
                    query = match op {
                        FilterOperator::Eq(val) => query.filter(columns::role.eq(val)),
                        FilterOperator::Ne(val) => query.filter(columns::role.ne(val)),
                        FilterOperator::Gt(val) => query.filter(columns::role.gt(val)),
                        FilterOperator::Ge(val) => query.filter(columns::role.ge(val)),
                        FilterOperator::Lt(val) => query.filter(columns::role.lt(val)),
                        FilterOperator::Le(val) => query.filter(columns::role.le(val)),
                        FilterOperator::EqAny(val) => query.filter(columns::role.eq_any(val)),
                    };
                }
                for op in filter.created_at.iter() {
                    use ::rp1::FilterOperator;
                    use crate::schema::users::columns;
                    query = match op {
                        FilterOperator::Eq(val) => query.filter(columns::created_at.eq(val)),
                        FilterOperator::Ne(val) => query.filter(columns::created_at.ne(val)),
                        FilterOperator::Gt(val) => query.filter(columns::created_at.gt(val)),
                        FilterOperator::Ge(val) => query.filter(columns::created_at.ge(val)),
                        FilterOperator::Lt(val) => query.filter(columns::created_at.lt(val)),
                        FilterOperator::Le(val) => query.filter(columns::created_at.le(val)),
                        FilterOperator::EqAny(val) => query.filter(columns::created_at.eq_any(val)),
                    };
                }
                for op in filter.updated_at.iter() {
                    use ::rp1::FilterOperator;
                    use crate::schema::users::columns;
                    query = match op {
                        FilterOperator::Eq(val) => query.filter(columns::updated_at.eq(val)),
                        FilterOperator::Ne(val) => query.filter(columns::updated_at.ne(val)),
                        FilterOperator::Gt(val) => query.filter(columns::updated_at.gt(val)),
                        FilterOperator::Ge(val) => query.filter(columns::updated_at.ge(val)),
                        FilterOperator::Lt(val) => query.filter(columns::updated_at.lt(val)),
                        FilterOperator::Le(val) => query.filter(columns::updated_at.le(val)),
                        FilterOperator::EqAny(val) => query.filter(columns::updated_at.eq_any(val)),
                    };
                }
                let filter = <User as ::rp1::CheckPermissions>::filter_list(&auth_user);
                let query = filter.apply(query);
                query.map(|q| q.load(conn))
            })
            .await
            .ok_or_else(|| ::rp1::CrudError::Forbidden)??;
        Ok(::rocket::serde::json::Json(results))
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct list_fn {}
    /// Rocket code generated proxy static conversion implementations.
    impl list_fn {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::user",
                                                "example/src/main.rs",
                                                40u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::user",
                                                "example/src/main.rs",
                                                40u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< User as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::user" , "example/src/main.rs" , 40u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let mut __e = ::rocket::form::prelude::Errors::new();
                    let mut __rocket_sort =
                        <Vec<::rp1::SortSpec<SortableFields>> as ::rocket::form::FromForm>::init(
                            ::rocket::form::prelude::Options::Lenient,
                        );
                    let mut __rocket_offset = <Option<i64> as ::rocket::form::FromForm>::init(
                        ::rocket::form::prelude::Options::Lenient,
                    );
                    let mut __rocket_limit = <Option<i64> as ::rocket::form::FromForm>::init(
                        ::rocket::form::prelude::Options::Lenient,
                    );
                    let mut __rocket_filter = <UserFilterSpec as ::rocket::form::FromForm>::init(
                        ::rocket::form::prelude::Options::Lenient,
                    );
                    for _f in __req.query_fields() {
                        let _raw = (_f.name.source().as_str(), _f.value);
                        let _key = _f.name.key_lossy().as_str();
                        match (_raw , _key) { (_ , "sort") => < Vec < :: rp1 :: SortSpec < SortableFields > > as :: rocket :: form :: FromForm > :: push_value (& mut __rocket_sort , _f . shift ()) , (_ , "offset") => < Option < i64 > as :: rocket :: form :: FromForm > :: push_value (& mut __rocket_offset , _f . shift ()) , (_ , "limit") => < Option < i64 > as :: rocket :: form :: FromForm > :: push_value (& mut __rocket_limit , _f . shift ()) , (_ , "filter") => < UserFilterSpec as :: rocket :: form :: FromForm > :: push_value (& mut __rocket_filter , _f . shift ()) , _ => { } }
                    }
                    let __rocket_sort = match < Vec < :: rp1 :: SortSpec < SortableFields > > as :: rocket :: form :: FromForm > :: finalize (__rocket_sort) { :: std :: result :: Result :: Ok (_v) => :: std :: option :: Option :: Some (_v) , :: std :: result :: Result :: Err (_err) => { __e . extend (_err . with_name (:: rocket :: form :: prelude :: NameView :: new ("sort"))) ; :: std :: option :: Option :: None } } ;
                    let __rocket_offset = match <Option<i64> as ::rocket::form::FromForm>::finalize(
                        __rocket_offset,
                    ) {
                        ::std::result::Result::Ok(_v) => ::std::option::Option::Some(_v),
                        ::std::result::Result::Err(_err) => {
                            __e.extend(
                                _err.with_name(::rocket::form::prelude::NameView::new("offset")),
                            );
                            ::std::option::Option::None
                        }
                    };
                    let __rocket_limit =
                        match <Option<i64> as ::rocket::form::FromForm>::finalize(__rocket_limit) {
                            ::std::result::Result::Ok(_v) => ::std::option::Option::Some(_v),
                            ::std::result::Result::Err(_err) => {
                                __e.extend(
                                    _err.with_name(::rocket::form::prelude::NameView::new("limit")),
                                );
                                ::std::option::Option::None
                            }
                        };
                    let __rocket_filter =
                        match <UserFilterSpec as ::rocket::form::FromForm>::finalize(
                            __rocket_filter,
                        ) {
                            ::std::result::Result::Ok(_v) => ::std::option::Option::Some(_v),
                            ::std::result::Result::Err(_err) => {
                                __e.extend(
                                    _err.with_name(::rocket::form::prelude::NameView::new(
                                        "filter",
                                    )),
                                );
                                ::std::option::Option::None
                            }
                        };
                    if !__e.is_empty() {
                        {
                            let lvl = ::log::Level::Warn;
                            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                ::log::__private_api_log(
                                    ::core::fmt::Arguments::new_v1(
                                        &["query string failed to match declared route"],
                                        &match () {
                                            () => [],
                                        },
                                    ),
                                    lvl,
                                    &("_", "rp1_example::user", "example/src/main.rs", 40u32),
                                );
                            }
                        };
                        for _err in __e {
                            {
                                let lvl = ::log::Level::Warn;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &[""],
                                            &match (&_err,) {
                                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                                    arg0,
                                                    ::core::fmt::Display::fmt,
                                                )],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::user", "example/src/main.rs", 40u32),
                                    );
                                }
                            };
                        }
                        return ::rocket::outcome::Outcome::Forward(__data);
                    }
                    let __rocket_sort = __rocket_sort.unwrap();
                    let __rocket_offset = __rocket_offset.unwrap();
                    let __rocket_limit = __rocket_limit.unwrap();
                    let __rocket_filter = __rocket_filter.unwrap();
                    let ___responder = list_fn(
                        __rocket_db,
                        __rocket_sort,
                        __rocket_filter,
                        __rocket_offset,
                        __rocket_limit,
                        __rocket_auth_user,
                    )
                    .await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "list_fn",
                method: ::rocket::http::Method::Get,
                uri: "/?<sort>&<offset>&<limit>&<filter>",
                handler: monomorphized_function,
                format: ::std::option::Option::None,
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Vec<::rp1::SortSpec<SortableFields>>>(),
                            type_name: std::any::type_name::<Vec<::rp1::SortSpec<SortableFields>>>(
                            ),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized:
                                Resolve::<Vec<::rp1::SortSpec<SortableFields>>>::SPECIALIZED,
                            abort: Resolve::<Vec<::rp1::SortSpec<SortableFields>>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::SortSpec<SortableFields>>(),
                            type_name: std::any::type_name::<::rp1::SortSpec<SortableFields>>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                Vec<::rp1::SortSpec<SortableFields>>,
                            >())),
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized: Resolve::<::rp1::SortSpec<SortableFields>>::SPECIALIZED,
                            abort: Resolve::<::rp1::SortSpec<SortableFields>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<SortableFields>(),
                            type_name: std::any::type_name::<SortableFields>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                ::rp1::SortSpec<SortableFields>,
                            >())),
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized: Resolve::<SortableFields>::SPECIALIZED,
                            abort: Resolve::<SortableFields>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Option<i64>>(),
                            type_name: std::any::type_name::<Option<i64>>(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized: Resolve::<Option<i64>>::SPECIALIZED,
                            abort: Resolve::<Option<i64>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<i64>(),
                            type_name: std::any::type_name::<i64>(),
                            parent: None.or(Some(std::any::TypeId::of::<Option<i64>>())),
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized: Resolve::<i64>::SPECIALIZED,
                            abort: Resolve::<i64>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Option<i64>>(),
                            type_name: std::any::type_name::<Option<i64>>(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized: Resolve::<Option<i64>>::SPECIALIZED,
                            abort: Resolve::<Option<i64>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<i64>(),
                            type_name: std::any::type_name::<i64>(),
                            parent: None.or(Some(std::any::TypeId::of::<Option<i64>>())),
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized: Resolve::<i64>::SPECIALIZED,
                            abort: Resolve::<i64>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<UserFilterSpec>(),
                            type_name: std::any::type_name::<UserFilterSpec>(),
                            parent: None,
                            location: ("example/src/main.rs", 41u32, 8u32),
                            specialized: Resolve::<UserFilterSpec>::SPECIALIZED,
                            abort: Resolve::<UserFilterSpec>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized: Resolve::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<User>(),
                            type_name: std::any::type_name::<User>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <User as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 41u32, 8u32),
                            specialized: Resolve::<User>::SPECIALIZED,
                            abort: Resolve::<User>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::CrudJsonResult<Vec<User>>>(),
                            type_name: std::any::type_name::<::rp1::CrudJsonResult<Vec<User>>>(),
                            parent: None,
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized: Resolve::<::rp1::CrudJsonResult<Vec<User>>>::SPECIALIZED,
                            abort: Resolve::<::rp1::CrudJsonResult<Vec<User>>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Vec<User>>(),
                            type_name: std::any::type_name::<Vec<User>>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                ::rp1::CrudJsonResult<Vec<User>>,
                            >())),
                            location: ("example/src/main.rs", 40u32, 1u32),
                            specialized: Resolve::<Vec<User>>::SPECIALIZED,
                            abort: Resolve::<Vec<User>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<User>(),
                            type_name: std::any::type_name::<User>(),
                            parent: None.or(Some(std::any::TypeId::of::<Vec<User>>())),
                            location: ("example/src/main.rs", 41u32, 8u32),
                            specialized: Resolve::<User>::SPECIALIZED,
                            abort: Resolve::<User>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_list_fn_11966298891250558335 as rocket_uri_macro_list_fn;
    impl User {
        pub fn get_routes() -> Vec<::rocket::Route> {
            {
                let ___vec: ::std::vec::Vec<::rocket::Route> = <[_]>::into_vec(box [
                    {
                        let ___struct = create_fn_form {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                    {
                        let ___struct = create_fn_json {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                    {
                        let ___struct = read_fn {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                    {
                        let ___struct = update_patch_fn_json {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                    {
                        let ___struct = update_patch_fn_form {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                    {
                        let ___struct = update_put_fn_json {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                    {
                        let ___struct = update_put_fn_form {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                    {
                        let ___struct = delete_fn {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                    {
                        let ___struct = list_fn {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                ]);
                ___vec
            }
        }
    }
    impl ::rp1::CrudStruct for User {
        type TableType = crate::schema::users::table;
    }
}
use self::user::User;
mod post {
    use super::*;
    use diesel::prelude::*;
    use crate::schema::posts;
    pub struct Post {
        id: i32,
        title: String,
        subtitle: Option<String>,
        content: String,
        publish_date: rp1::datetime::Date,
        publish_time: rp1::datetime::Time,
        user_id: i32,
        created_at: rp1::datetime::OffsetDateTime,
        updated_at: rp1::datetime::OffsetDateTime,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Post {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Post",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "title",
                    &self.title,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "subtitle",
                    &self.subtitle,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "content",
                    &self.content,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "publish_date",
                    &self.publish_date,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "publish_time",
                    &self.publish_time,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "user_id",
                    &self.user_id,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "created_at",
                    &self.created_at,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "updated_at",
                    &self.updated_at,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[allow(non_snake_case, unused_extern_crates, unused_imports)]
    fn _impl_queryable_for_post() {
        extern crate std;
        use diesel;
        use diesel::Queryable;
        impl<__DB: diesel::backend::Backend, __ST> Queryable<__ST, __DB> for Post
        where
            (
                i32,
                String,
                Option<String>,
                String,
                rp1::datetime::Date,
                rp1::datetime::Time,
                i32,
                rp1::datetime::OffsetDateTime,
                rp1::datetime::OffsetDateTime,
            ): Queryable<__ST, __DB>,
        {
            type Row = <(
                i32,
                String,
                Option<String>,
                String,
                rp1::datetime::Date,
                rp1::datetime::Time,
                i32,
                rp1::datetime::OffsetDateTime,
                rp1::datetime::OffsetDateTime,
            ) as Queryable<__ST, __DB>>::Row;
            fn build(row: Self::Row) -> Self {
                let row: (
                    i32,
                    String,
                    Option<String>,
                    String,
                    rp1::datetime::Date,
                    rp1::datetime::Time,
                    i32,
                    rp1::datetime::OffsetDateTime,
                    rp1::datetime::OffsetDateTime,
                ) = Queryable::build(row);
                Self {
                    id: (row.0.into()),
                    title: (row.1.into()),
                    subtitle: (row.2.into()),
                    content: (row.3.into()),
                    publish_date: (row.4.into()),
                    publish_time: (row.5.into()),
                    user_id: (row.6.into()),
                    created_at: (row.7.into()),
                    updated_at: (row.8.into()),
                }
            }
        }
    }
    impl ::validator::Validate for Post {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_args(())
        }
    }
    #[allow(clippy::all)]
    impl<'v_a> ::validator::ValidateArgs<'v_a> for Post {
        type Args = ();
        #[allow(unused_mut)]
        #[allow(unused_variable)]
        fn validate_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            let mut errors = ::validator::ValidationErrors::new();
            let mut result = if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            };
            result
        }
    }
    #[table_name = "posts"]
    pub struct NewPost {
        title: String,
        subtitle: Option<String>,
        content: String,
        publish_date: rp1::datetime::Date,
        publish_time: rp1::datetime::Time,
        user_id: i32,
    }
    impl ::validator::Validate for NewPost {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_args(())
        }
    }
    #[allow(clippy::all)]
    impl<'v_a> ::validator::ValidateArgs<'v_a> for NewPost {
        type Args = ();
        #[allow(unused_mut)]
        #[allow(unused_variable)]
        fn validate_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            let mut errors = ::validator::ValidationErrors::new();
            let mut result = if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            };
            result
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for NewPost {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "title" => _serde::__private::Ok(__Field::__field0),
                            "subtitle" => _serde::__private::Ok(__Field::__field1),
                            "content" => _serde::__private::Ok(__Field::__field2),
                            "publish_date" => _serde::__private::Ok(__Field::__field3),
                            "publish_time" => _serde::__private::Ok(__Field::__field4),
                            "user_id" => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"title" => _serde::__private::Ok(__Field::__field0),
                            b"subtitle" => _serde::__private::Ok(__Field::__field1),
                            b"content" => _serde::__private::Ok(__Field::__field2),
                            b"publish_date" => _serde::__private::Ok(__Field::__field3),
                            b"publish_time" => _serde::__private::Ok(__Field::__field4),
                            b"user_id" => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<NewPost>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = NewPost;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct NewPost")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct NewPost with 6 elements",
                                        ),
                                    );
                                }
                            };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct NewPost with 6 elements",
                                ));
                            }
                        };
                        let __field2 =
                            match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct NewPost with 6 elements",
                                        ),
                                    );
                                }
                            };
                        let __field3 = match match _serde::de::SeqAccess::next_element::<
                            rp1::datetime::Date,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct NewPost with 6 elements",
                                ));
                            }
                        };
                        let __field4 = match match _serde::de::SeqAccess::next_element::<
                            rp1::datetime::Time,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct NewPost with 6 elements",
                                ));
                            }
                        };
                        let __field5 =
                            match match _serde::de::SeqAccess::next_element::<i32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct NewPost with 6 elements",
                                        ),
                                    );
                                }
                            };
                        _serde::__private::Ok(NewPost {
                            title: __field0,
                            subtitle: __field1,
                            content: __field2,
                            publish_date: __field3,
                            publish_time: __field4,
                            user_id: __field5,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<String>> =
                            _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> =
                            _serde::__private::None;
                        let mut __field3: _serde::__private::Option<rp1::datetime::Date> =
                            _serde::__private::None;
                        let mut __field4: _serde::__private::Option<rp1::datetime::Time> =
                            _serde::__private::None;
                        let mut __field5: _serde::__private::Option<i32> = _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "title",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<String>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "subtitle",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Option<String>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "content",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<String>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "publish_date",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<rp1::datetime::Date>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "publish_time",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<rp1::datetime::Time>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "user_id",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<i32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("title") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("subtitle") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("content") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("publish_date") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("publish_time") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("user_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(NewPost {
                            title: __field0,
                            subtitle: __field1,
                            content: __field2,
                            publish_date: __field3,
                            publish_time: __field4,
                            user_id: __field5,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &[
                    "title",
                    "subtitle",
                    "content",
                    "publish_date",
                    "publish_time",
                    "user_id",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "NewPost",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<NewPost>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_snake_case)]
    const _: () = { # [doc = r" Rocket generated FormForm context."] # [doc (hidden)] pub struct FromFormGeneratedContext < '__f > { __opts : :: rocket :: form :: prelude :: Options , __errors : :: rocket :: form :: prelude :: Errors < '__f > , __parent : :: std :: option :: Option < & '__f :: rocket :: form :: prelude :: Name > , title : :: std :: option :: Option < < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , subtitle : :: std :: option :: Option < < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , content : :: std :: option :: Option < < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , publish_date : :: std :: option :: Option < < rp1 :: datetime :: Date as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , publish_time : :: std :: option :: Option < < rp1 :: datetime :: Time as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , user_id : :: std :: option :: Option < < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , } # [allow (unused_imports)] use :: rocket :: http :: uncased :: AsUncased ; impl < '__f > :: rocket :: form :: prelude :: FromForm < '__f > for NewPost { type Context = FromFormGeneratedContext < '__f > ; fn init (__opts : :: rocket :: form :: prelude :: Options) -> Self :: Context { Self :: Context { __opts , __errors : :: rocket :: form :: prelude :: Errors :: new () , __parent : :: std :: option :: Option :: None , title : :: std :: option :: Option :: None , subtitle : :: std :: option :: Option :: None , content : :: std :: option :: Option :: None , publish_date : :: std :: option :: Option :: None , publish_time : :: std :: option :: Option :: None , user_id : :: std :: option :: Option :: None , } } fn push_value (__c : & mut Self :: Context , __f : :: rocket :: form :: prelude :: ValueField < '__f >) { __c . __parent = __f . name . parent () ; match __f . name . key_lossy () . as_str () { "title" => { { < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . title . get_or_insert_with (| | < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "subtitle" => { { < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . subtitle . get_or_insert_with (| | < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "content" => { { < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . content . get_or_insert_with (| | < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "publish_date" => { { < rp1 :: datetime :: Date as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . publish_date . get_or_insert_with (| | < rp1 :: datetime :: Date as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "publish_time" => { { < rp1 :: datetime :: Time as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . publish_time . get_or_insert_with (| | < rp1 :: datetime :: Time as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "user_id" => { { < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . user_id . get_or_insert_with (| | < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } __k if __k == "_method" || ! __c . __opts . strict => { } _ => __c . __errors . push (__f . unexpected ()) , } } # [allow (clippy :: let_unit_value , clippy :: type_complexity , clippy :: type_repetition_in_bounds , clippy :: used_underscore_binding)] fn push_data < 'life0 , 'life1 , 'async_trait > (__c : & 'life0 mut FromFormGeneratedContext < '__f > , __f : :: rocket :: form :: prelude :: DataField < '__f , 'life1 >) -> :: core :: pin :: Pin < Box < dyn :: core :: future :: Future < Output = () > + :: core :: marker :: Send + 'async_trait > > where '__f : 'async_trait , 'life0 : 'async_trait , 'life1 : 'async_trait { Box :: pin (async move { let __c = __c ; let __f = __f ; let _ : () = { __c . __parent = __f . name . parent () ; match __f . name . key_lossy () . as_str () { "title" => { { let _fut = < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . title . get_or_insert_with (| | < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "subtitle" => { { let _fut = < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . subtitle . get_or_insert_with (| | < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "content" => { { let _fut = < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . content . get_or_insert_with (| | < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "publish_date" => { { let _fut = < rp1 :: datetime :: Date as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . publish_date . get_or_insert_with (| | < rp1 :: datetime :: Date as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "publish_time" => { { let _fut = < rp1 :: datetime :: Time as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . publish_time . get_or_insert_with (| | < rp1 :: datetime :: Time as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "user_id" => { { let _fut = < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . user_id . get_or_insert_with (| | < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } __k if __k == "_method" || ! __c . __opts . strict => { } _ => __c . __errors . push (__f . unexpected ()) , } } ; }) } fn finalize (mut __c : Self :: Context) -> :: std :: result :: Result < Self , :: rocket :: form :: prelude :: Errors < '__f > > { # [allow (unused_imports)] use :: rocket :: form :: prelude :: validate :: * ; let title = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "title")) ; let __opts = __c . __opts ; __c . title . map_or_else (| | { < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| title | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | title) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (title) => :: std :: option :: Option :: Some (title) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let subtitle = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "subtitle")) ; let __opts = __c . __opts ; __c . subtitle . map_or_else (| | { < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| subtitle | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | subtitle) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (subtitle) => :: std :: option :: Option :: Some (subtitle) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let content = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "content")) ; let __opts = __c . __opts ; __c . content . map_or_else (| | { < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| content | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | content) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (content) => :: std :: option :: Option :: Some (content) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let publish_date = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "publish_date")) ; let __opts = __c . __opts ; __c . publish_date . map_or_else (| | { < rp1 :: datetime :: Date as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < rp1 :: datetime :: Date as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| publish_date | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | publish_date) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (publish_date) => :: std :: option :: Option :: Some (publish_date) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let publish_time = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "publish_time")) ; let __opts = __c . __opts ; __c . publish_time . map_or_else (| | { < rp1 :: datetime :: Time as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < rp1 :: datetime :: Time as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| publish_time | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | publish_time) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (publish_time) => :: std :: option :: Option :: Some (publish_time) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let user_id = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "user_id")) ; let __opts = __c . __opts ; __c . user_id . map_or_else (| | { < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| user_id | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | user_id) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (user_id) => :: std :: option :: Option :: Some (user_id) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; if ! __c . __errors . is_empty () { return :: std :: result :: Result :: Err (__c . __errors) ; } let __o = Self { title : title . unwrap () , subtitle : subtitle . unwrap () , content : content . unwrap () , publish_date : publish_date . unwrap () , publish_time : publish_time . unwrap () , user_id : user_id . unwrap () , } ; if ! __c . __errors . is_empty () { return :: std :: result :: Result :: Err (__c . __errors) ; } Ok (__o) } } };
    #[allow(non_snake_case, unused_extern_crates, unused_imports)]
    fn _impl_queryable_for_newpost() {
        extern crate std;
        use diesel;
        use diesel::Queryable;
        impl<__DB: diesel::backend::Backend, __ST> Queryable<__ST, __DB> for NewPost
        where
            (
                String,
                Option<String>,
                String,
                rp1::datetime::Date,
                rp1::datetime::Time,
                i32,
            ): Queryable<__ST, __DB>,
        {
            type Row = <(
                String,
                Option<String>,
                String,
                rp1::datetime::Date,
                rp1::datetime::Time,
                i32,
            ) as Queryable<__ST, __DB>>::Row;
            fn build(row: Self::Row) -> Self {
                let row: (
                    String,
                    Option<String>,
                    String,
                    rp1::datetime::Date,
                    rp1::datetime::Time,
                    i32,
                ) = Queryable::build(row);
                Self {
                    title: (row.0.into()),
                    subtitle: (row.1.into()),
                    content: (row.2.into()),
                    publish_date: (row.3.into()),
                    publish_time: (row.4.into()),
                    user_id: (row.5.into()),
                }
            }
        }
    }
    #[allow(non_snake_case, unused_extern_crates, unused_imports)]
    fn _impl_insertable_for_newpost() {
        extern crate std;
        use diesel;
        use diesel::insertable::Insertable;
        use diesel::query_builder::UndecoratedInsertRecord;
        use diesel::prelude::*;
        impl<'insert> Insertable<posts::table> for NewPost {
            type Values = <(
                std::option::Option<diesel::dsl::Eq<posts::title, String>>,
                std::option::Option<diesel::dsl::Eq<posts::subtitle, String>>,
                std::option::Option<diesel::dsl::Eq<posts::content, String>>,
                std::option::Option<diesel::dsl::Eq<posts::publish_date, rp1::datetime::Date>>,
                std::option::Option<diesel::dsl::Eq<posts::publish_time, rp1::datetime::Time>>,
                std::option::Option<diesel::dsl::Eq<posts::user_id, i32>>,
            ) as Insertable<posts::table>>::Values;
            fn values(self) -> Self::Values {
                (
                    std::option::Option::Some(posts::title.eq(self.title)),
                    self.subtitle.map(|x| posts::subtitle.eq(x)),
                    std::option::Option::Some(posts::content.eq(self.content)),
                    std::option::Option::Some(posts::publish_date.eq(self.publish_date)),
                    std::option::Option::Some(posts::publish_time.eq(self.publish_time)),
                    std::option::Option::Some(posts::user_id.eq(self.user_id)),
                )
                    .values()
            }
        }
        impl<'insert> Insertable<posts::table> for &'insert NewPost {
            type Values = <(
                std::option::Option<diesel::dsl::Eq<posts::title, &'insert String>>,
                std::option::Option<diesel::dsl::Eq<posts::subtitle, &'insert String>>,
                std::option::Option<diesel::dsl::Eq<posts::content, &'insert String>>,
                std::option::Option<
                    diesel::dsl::Eq<posts::publish_date, &'insert rp1::datetime::Date>,
                >,
                std::option::Option<
                    diesel::dsl::Eq<posts::publish_time, &'insert rp1::datetime::Time>,
                >,
                std::option::Option<diesel::dsl::Eq<posts::user_id, &'insert i32>>,
            ) as Insertable<posts::table>>::Values;
            fn values(self) -> Self::Values {
                (
                    std::option::Option::Some(posts::title.eq(&self.title)),
                    self.subtitle.as_ref().map(|x| posts::subtitle.eq(x)),
                    std::option::Option::Some(posts::content.eq(&self.content)),
                    std::option::Option::Some(posts::publish_date.eq(&self.publish_date)),
                    std::option::Option::Some(posts::publish_time.eq(&self.publish_time)),
                    std::option::Option::Some(posts::user_id.eq(&self.user_id)),
                )
                    .values()
            }
        }
        impl<'insert> UndecoratedInsertRecord<posts::table> for NewPost {}
    }
    impl ::rp1::CrudInsertable for Post {
        type InsertType = NewPost;
    }
    async fn create_fn_help(
        db: Db,
        value: NewPost,
        auth_user: <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<Post> {
        if !<Post as ::rp1::CheckPermissions>::allow_create(&value, &auth_user) {
            return Err(::rp1::CrudError::Forbidden);
        }
        use ::validator::Validate;
        value.validate()?;
        Ok(::rocket::serde::json::Json(
            db.run(move |conn| {
                diesel::insert_into(crate::schema::posts::table)
                    .values(&value)
                    .get_result(conn)
            })
            .await?,
        ))
    }
    async fn create_fn_json(
        db: Db,
        value: ::rocket::serde::json::Json<NewPost>,
        auth_user: <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<Post> {
        let value = value.into_inner();
        create_fn_help(db, value, auth_user).await
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct create_fn_json {}
    /// Rocket code generated proxy static conversion implementations.
    impl create_fn_json {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::post",
                                                "example/src/main.rs",
                                                53u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::post",
                                                "example/src/main.rs",
                                                53u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let __rocket_value : :: rocket :: serde :: json :: Json < NewPost > = match < :: rocket :: serde :: json :: Json < NewPost > as :: rocket :: data :: FromData > :: from_data (__req , __data) . await { :: rocket :: outcome :: Outcome :: Success (__d) => __d , :: rocket :: outcome :: Outcome :: Forward (__d) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard is forwarding."] , & match (& ":: rocket :: serde :: json :: Json < NewPost >" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__d) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard failed: " , "."] , & match (& ":: rocket :: serde :: json :: Json < NewPost >" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let ___responder =
                        create_fn_json(__rocket_db, __rocket_value, __rocket_auth_user).await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "create_fn_json",
                method: ::rocket::http::Method::Post,
                uri: "/",
                handler: monomorphized_function,
                format: ::std::option::Option::Some(::rocket::http::MediaType::const_new(
                    "application",
                    "json",
                    &[],
                )),
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized: Resolve::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Post>(),
                            type_name: std::any::type_name::<Post>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 54u32, 8u32),
                            specialized: Resolve::<Post>::SPECIALIZED,
                            abort: Resolve::<Post>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::CrudJsonResult<Post>>(),
                            type_name: std::any::type_name::<::rp1::CrudJsonResult<Post>>(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized: Resolve::<::rp1::CrudJsonResult<Post>>::SPECIALIZED,
                            abort: Resolve::<::rp1::CrudJsonResult<Post>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Post>(),
                            type_name: std::any::type_name::<Post>(),
                            parent: None
                                .or(Some(std::any::TypeId::of::<::rp1::CrudJsonResult<Post>>())),
                            location: ("example/src/main.rs", 54u32, 8u32),
                            specialized: Resolve::<Post>::SPECIALIZED,
                            abort: Resolve::<Post>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_create_fn_json_4051545916439470827 as rocket_uri_macro_create_fn_json;
    async fn create_fn_form(
        db: Db,
        value: ::rocket::form::Form<NewPost>,
        auth_user: <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<Post> {
        let value = value.into_inner();
        create_fn_help(db, value, auth_user).await
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct create_fn_form {}
    /// Rocket code generated proxy static conversion implementations.
    impl create_fn_form {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::post",
                                                "example/src/main.rs",
                                                53u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::post",
                                                "example/src/main.rs",
                                                53u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let __rocket_value: ::rocket::form::Form<NewPost> = match <::rocket::form::Form<
                        NewPost,
                    > as ::rocket::data::FromData>::from_data(
                        __req, __data
                    )
                    .await
                    {
                        ::rocket::outcome::Outcome::Success(__d) => __d,
                        ::rocket::outcome::Outcome::Forward(__d) => {
                            {
                                let lvl = ::log::Level::Warn;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["`", "` data guard is forwarding."],
                                            &match (&":: rocket :: form :: Form < NewPost >",) {
                                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                                    arg0,
                                                    ::core::fmt::Display::fmt,
                                                )],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::post", "example/src/main.rs", 53u32),
                                    );
                                }
                            };
                            return ::rocket::outcome::Outcome::Forward(__d);
                        }
                        ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                            {
                                let lvl = ::log::Level::Warn;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["`", "` data guard failed: ", "."],
                                            &match (&":: rocket :: form :: Form < NewPost >", &__e)
                                            {
                                                (arg0, arg1) => [
                                                    ::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    ),
                                                    ::core::fmt::ArgumentV1::new(
                                                        arg1,
                                                        ::core::fmt::Debug::fmt,
                                                    ),
                                                ],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::post", "example/src/main.rs", 53u32),
                                    );
                                }
                            };
                            return ::rocket::outcome::Outcome::Failure(__c);
                        }
                    };
                    let ___responder =
                        create_fn_form(__rocket_db, __rocket_value, __rocket_auth_user).await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "create_fn_form",
                method: ::rocket::http::Method::Post,
                uri: "/",
                handler: monomorphized_function,
                format: ::std::option::Option::Some(::rocket::http::MediaType::const_new(
                    "application",
                    "x-www-form-urlencoded",
                    &[],
                )),
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized: Resolve::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Post>(),
                            type_name: std::any::type_name::<Post>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 54u32, 8u32),
                            specialized: Resolve::<Post>::SPECIALIZED,
                            abort: Resolve::<Post>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::CrudJsonResult<Post>>(),
                            type_name: std::any::type_name::<::rp1::CrudJsonResult<Post>>(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized: Resolve::<::rp1::CrudJsonResult<Post>>::SPECIALIZED,
                            abort: Resolve::<::rp1::CrudJsonResult<Post>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Post>(),
                            type_name: std::any::type_name::<Post>(),
                            parent: None
                                .or(Some(std::any::TypeId::of::<::rp1::CrudJsonResult<Post>>())),
                            location: ("example/src/main.rs", 54u32, 8u32),
                            specialized: Resolve::<Post>::SPECIALIZED,
                            abort: Resolve::<Post>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_create_fn_form_14382131797871062302 as rocket_uri_macro_create_fn_form;
    async fn read_fn(
        db: Db,
        id: i32,
        auth_user: <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<Post> {
        let row = db
            .run(move |conn| crate::schema::posts::table.find(id).first::<Post>(conn))
            .await?;
        let row = if <Post as ::rp1::CheckPermissions>::allow_read(&row, &auth_user) {
            row
        } else {
            return Err(::rp1::CrudError::NotFound);
        };
        Ok(::rocket::serde::json::Json(row))
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct read_fn {}
    /// Rocket code generated proxy static conversion implementations.
    impl read_fn {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::post",
                                                "example/src/main.rs",
                                                53u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::post",
                                                "example/src/main.rs",
                                                53u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let __rocket_id: i32 = match __req.routed_segment(0usize) {
                        ::std::option::Option::Some(__s) => {
                            match <i32 as ::rocket::request::FromParam>::from_param(__s) {
                                ::std::result::Result::Ok(__v) => __v,
                                ::std::result::Result::Err(__error) => {
                                    return {
                                        {
                                            let lvl = ::log::Level::Warn;
                                            if lvl <= ::log::STATIC_MAX_LEVEL
                                                && lvl <= ::log::max_level()
                                            {
                                                :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , ": " , "` param guard parsed forwarding with error "] , & match (& "id" , & "i32" , & __error) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ;
                                            }
                                        };
                                        ::rocket::outcome::Outcome::Forward(__data)
                                    }
                                }
                            }
                        }
                        ::std::option::Option::None => {
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Internal invariant broken: dyn param not found."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::post", "example/src/main.rs", 56u32),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Please report this to the Rocket issue tracker."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::post", "example/src/main.rs", 56u32),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["https://github.com/SergioBenitez/Rocket/issues"],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::post", "example/src/main.rs", 56u32),
                                    );
                                }
                            };
                            return ::rocket::outcome::Outcome::Forward(__data);
                        }
                    };
                    let ___responder = read_fn(__rocket_db, __rocket_id, __rocket_auth_user).await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "read_fn",
                method: ::rocket::http::Method::Get,
                uri: "/<id>",
                handler: monomorphized_function,
                format: ::std::option::Option::None,
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<i32>(),
                            type_name: std::any::type_name::<i32>(),
                            parent: None,
                            location: ("example/src/main.rs", 56u32, 9u32),
                            specialized: Resolve::<i32>::SPECIALIZED,
                            abort: Resolve::<i32>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized: Resolve::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Post>(),
                            type_name: std::any::type_name::<Post>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 54u32, 8u32),
                            specialized: Resolve::<Post>::SPECIALIZED,
                            abort: Resolve::<Post>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::CrudJsonResult<Post>>(),
                            type_name: std::any::type_name::<::rp1::CrudJsonResult<Post>>(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized: Resolve::<::rp1::CrudJsonResult<Post>>::SPECIALIZED,
                            abort: Resolve::<::rp1::CrudJsonResult<Post>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Post>(),
                            type_name: std::any::type_name::<Post>(),
                            parent: None
                                .or(Some(std::any::TypeId::of::<::rp1::CrudJsonResult<Post>>())),
                            location: ("example/src/main.rs", 54u32, 8u32),
                            specialized: Resolve::<Post>::SPECIALIZED,
                            abort: Resolve::<Post>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_read_fn_8977072381141821625 as rocket_uri_macro_read_fn;
    #[table_name = "posts"]
    pub struct UpdatePatchPost {
        title: Option<String>,
        #[serde(default, deserialize_with = "::rp1::helper::double_option")]
        subtitle: Option<Option<String>>,
        content: Option<String>,
        publish_date: Option<rp1::datetime::Date>,
        publish_time: Option<rp1::datetime::Time>,
        user_id: Option<i32>,
    }
    impl ::validator::Validate for UpdatePatchPost {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_args(())
        }
    }
    #[allow(clippy::all)]
    impl<'v_a> ::validator::ValidateArgs<'v_a> for UpdatePatchPost {
        type Args = ();
        #[allow(unused_mut)]
        #[allow(unused_variable)]
        fn validate_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            let mut errors = ::validator::ValidationErrors::new();
            let mut result = if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            };
            result
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UpdatePatchPost {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "title" => _serde::__private::Ok(__Field::__field0),
                            "subtitle" => _serde::__private::Ok(__Field::__field1),
                            "content" => _serde::__private::Ok(__Field::__field2),
                            "publish_date" => _serde::__private::Ok(__Field::__field3),
                            "publish_time" => _serde::__private::Ok(__Field::__field4),
                            "user_id" => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"title" => _serde::__private::Ok(__Field::__field0),
                            b"subtitle" => _serde::__private::Ok(__Field::__field1),
                            b"content" => _serde::__private::Ok(__Field::__field2),
                            b"publish_date" => _serde::__private::Ok(__Field::__field3),
                            b"publish_time" => _serde::__private::Ok(__Field::__field4),
                            b"user_id" => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UpdatePatchPost>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UpdatePatchPost;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UpdatePatchPost",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct UpdatePatchPost with 6 elements",
                                ));
                            }
                        };
                        let __field1 = match {
                            struct __DeserializeWith<'de> {
                                value: Option<Option<String>>,
                                phantom: _serde::__private::PhantomData<UpdatePatchPost>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: match ::rp1::helper::double_option(__deserializer) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                match _serde::de::SeqAccess::next_element::<__DeserializeWith<'de>>(
                                    &mut __seq,
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                },
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => _serde::__private::Default::default(),
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct UpdatePatchPost with 6 elements",
                                ));
                            }
                        };
                        let __field3 = match match _serde::de::SeqAccess::next_element::<
                            Option<rp1::datetime::Date>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct UpdatePatchPost with 6 elements",
                                ));
                            }
                        };
                        let __field4 = match match _serde::de::SeqAccess::next_element::<
                            Option<rp1::datetime::Time>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct UpdatePatchPost with 6 elements",
                                ));
                            }
                        };
                        let __field5 = match match _serde::de::SeqAccess::next_element::<Option<i32>>(
                            &mut __seq,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    5usize,
                                    &"struct UpdatePatchPost with 6 elements",
                                ));
                            }
                        };
                        _serde::__private::Ok(UpdatePatchPost {
                            title: __field0,
                            subtitle: __field1,
                            content: __field2,
                            publish_date: __field3,
                            publish_time: __field4,
                            user_id: __field5,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Option<String>> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<Option<String>>> =
                            _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<String>> =
                            _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Option<rp1::datetime::Date>> =
                            _serde::__private::None;
                        let mut __field4: _serde::__private::Option<Option<rp1::datetime::Time>> =
                            _serde::__private::None;
                        let mut __field5: _serde::__private::Option<Option<i32>> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "title",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Option<String>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "subtitle",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some({
                                        struct __DeserializeWith<'de> {
                                            value: Option<Option<String>>,
                                            phantom:
                                                _serde::__private::PhantomData<UpdatePatchPost>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: match ::rp1::helper::double_option(
                                                        __deserializer,
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    },
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map)
                                        {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "content",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Option<String>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "publish_date",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<rp1::datetime::Date>,
                                        >(&mut __map)
                                        {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "publish_time",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<rp1::datetime::Time>,
                                        >(&mut __map)
                                        {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "user_id",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Option<i32>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("title") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => _serde::__private::Default::default(),
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("content") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("publish_date") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("publish_time") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("user_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(UpdatePatchPost {
                            title: __field0,
                            subtitle: __field1,
                            content: __field2,
                            publish_date: __field3,
                            publish_time: __field4,
                            user_id: __field5,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &[
                    "title",
                    "subtitle",
                    "content",
                    "publish_date",
                    "publish_time",
                    "user_id",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UpdatePatchPost",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UpdatePatchPost>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_snake_case)]
    const _: () = { # [doc = r" Rocket generated FormForm context."] # [doc (hidden)] pub struct FromFormGeneratedContext < '__f > { __opts : :: rocket :: form :: prelude :: Options , __errors : :: rocket :: form :: prelude :: Errors < '__f > , __parent : :: std :: option :: Option < & '__f :: rocket :: form :: prelude :: Name > , title : :: std :: option :: Option < < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , subtitle : :: std :: option :: Option < < Option < Option < String > > as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , content : :: std :: option :: Option < < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , publish_date : :: std :: option :: Option < < Option < rp1 :: datetime :: Date > as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , publish_time : :: std :: option :: Option < < Option < rp1 :: datetime :: Time > as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , user_id : :: std :: option :: Option < < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , } # [allow (unused_imports)] use :: rocket :: http :: uncased :: AsUncased ; impl < '__f > :: rocket :: form :: prelude :: FromForm < '__f > for UpdatePatchPost { type Context = FromFormGeneratedContext < '__f > ; fn init (__opts : :: rocket :: form :: prelude :: Options) -> Self :: Context { Self :: Context { __opts , __errors : :: rocket :: form :: prelude :: Errors :: new () , __parent : :: std :: option :: Option :: None , title : :: std :: option :: Option :: None , subtitle : :: std :: option :: Option :: None , content : :: std :: option :: Option :: None , publish_date : :: std :: option :: Option :: None , publish_time : :: std :: option :: Option :: None , user_id : :: std :: option :: Option :: None , } } fn push_value (__c : & mut Self :: Context , __f : :: rocket :: form :: prelude :: ValueField < '__f >) { __c . __parent = __f . name . parent () ; match __f . name . key_lossy () . as_str () { "title" => { { < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . title . get_or_insert_with (| | < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "subtitle" => { { < Option < Option < String > > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . subtitle . get_or_insert_with (| | < Option < Option < String > > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "content" => { { < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . content . get_or_insert_with (| | < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "publish_date" => { { < Option < rp1 :: datetime :: Date > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . publish_date . get_or_insert_with (| | < Option < rp1 :: datetime :: Date > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "publish_time" => { { < Option < rp1 :: datetime :: Time > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . publish_time . get_or_insert_with (| | < Option < rp1 :: datetime :: Time > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "user_id" => { { < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . user_id . get_or_insert_with (| | < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } __k if __k == "_method" || ! __c . __opts . strict => { } _ => __c . __errors . push (__f . unexpected ()) , } } # [allow (clippy :: let_unit_value , clippy :: type_complexity , clippy :: type_repetition_in_bounds , clippy :: used_underscore_binding)] fn push_data < 'life0 , 'life1 , 'async_trait > (__c : & 'life0 mut FromFormGeneratedContext < '__f > , __f : :: rocket :: form :: prelude :: DataField < '__f , 'life1 >) -> :: core :: pin :: Pin < Box < dyn :: core :: future :: Future < Output = () > + :: core :: marker :: Send + 'async_trait > > where '__f : 'async_trait , 'life0 : 'async_trait , 'life1 : 'async_trait { Box :: pin (async move { let __c = __c ; let __f = __f ; let _ : () = { __c . __parent = __f . name . parent () ; match __f . name . key_lossy () . as_str () { "title" => { { let _fut = < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . title . get_or_insert_with (| | < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "subtitle" => { { let _fut = < Option < Option < String > > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . subtitle . get_or_insert_with (| | < Option < Option < String > > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "content" => { { let _fut = < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . content . get_or_insert_with (| | < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "publish_date" => { { let _fut = < Option < rp1 :: datetime :: Date > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . publish_date . get_or_insert_with (| | < Option < rp1 :: datetime :: Date > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "publish_time" => { { let _fut = < Option < rp1 :: datetime :: Time > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . publish_time . get_or_insert_with (| | < Option < rp1 :: datetime :: Time > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "user_id" => { { let _fut = < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . user_id . get_or_insert_with (| | < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } __k if __k == "_method" || ! __c . __opts . strict => { } _ => __c . __errors . push (__f . unexpected ()) , } } ; }) } fn finalize (mut __c : Self :: Context) -> :: std :: result :: Result < Self , :: rocket :: form :: prelude :: Errors < '__f > > { # [allow (unused_imports)] use :: rocket :: form :: prelude :: validate :: * ; let title = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "title")) ; let __opts = __c . __opts ; __c . title . map_or_else (| | { < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| title | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | title) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (title) => :: std :: option :: Option :: Some (title) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let subtitle = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "subtitle")) ; let __opts = __c . __opts ; __c . subtitle . map_or_else (| | { < Option < Option < String > > as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < Option < Option < String > > as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| subtitle | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | subtitle) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (subtitle) => :: std :: option :: Option :: Some (subtitle) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let content = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "content")) ; let __opts = __c . __opts ; __c . content . map_or_else (| | { < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| content | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | content) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (content) => :: std :: option :: Option :: Some (content) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let publish_date = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "publish_date")) ; let __opts = __c . __opts ; __c . publish_date . map_or_else (| | { < Option < rp1 :: datetime :: Date > as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < Option < rp1 :: datetime :: Date > as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| publish_date | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | publish_date) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (publish_date) => :: std :: option :: Option :: Some (publish_date) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let publish_time = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "publish_time")) ; let __opts = __c . __opts ; __c . publish_time . map_or_else (| | { < Option < rp1 :: datetime :: Time > as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < Option < rp1 :: datetime :: Time > as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| publish_time | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | publish_time) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (publish_time) => :: std :: option :: Option :: Some (publish_time) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let user_id = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "user_id")) ; let __opts = __c . __opts ; __c . user_id . map_or_else (| | { < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| user_id | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | user_id) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (user_id) => :: std :: option :: Option :: Some (user_id) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; if ! __c . __errors . is_empty () { return :: std :: result :: Result :: Err (__c . __errors) ; } let __o = Self { title : title . unwrap () , subtitle : subtitle . unwrap () , content : content . unwrap () , publish_date : publish_date . unwrap () , publish_time : publish_time . unwrap () , user_id : user_id . unwrap () , } ; if ! __c . __errors . is_empty () { return :: std :: result :: Result :: Err (__c . __errors) ; } Ok (__o) } } };
    #[allow(non_snake_case, unused_extern_crates, unused_imports)]
    fn _impl_as_changeset_for_updatepatchpost() {
        extern crate std;
        use diesel;
        use diesel::query_builder::AsChangeset;
        use diesel::prelude::*;
        impl<'update> AsChangeset for &'update UpdatePatchPost {
            type Target = posts::table;
            type Changeset = <(
                std::option::Option<diesel::dsl::Eq<posts::title, &'update String>>,
                std::option::Option<diesel::dsl::Eq<posts::subtitle, &'update Option<String>>>,
                std::option::Option<diesel::dsl::Eq<posts::content, &'update String>>,
                std::option::Option<
                    diesel::dsl::Eq<posts::publish_date, &'update rp1::datetime::Date>,
                >,
                std::option::Option<
                    diesel::dsl::Eq<posts::publish_time, &'update rp1::datetime::Time>,
                >,
                std::option::Option<diesel::dsl::Eq<posts::user_id, &'update i32>>,
            ) as AsChangeset>::Changeset;
            fn as_changeset(self) -> Self::Changeset {
                (
                    self.title.as_ref().map(|x| posts::title.eq(x)),
                    self.subtitle.as_ref().map(|x| posts::subtitle.eq(x)),
                    self.content.as_ref().map(|x| posts::content.eq(x)),
                    self.publish_date
                        .as_ref()
                        .map(|x| posts::publish_date.eq(x)),
                    self.publish_time
                        .as_ref()
                        .map(|x| posts::publish_time.eq(x)),
                    self.user_id.as_ref().map(|x| posts::user_id.eq(x)),
                )
                    .as_changeset()
            }
        }
        impl<'update> AsChangeset for UpdatePatchPost {
            type Target = posts::table;
            type Changeset = <(
                std::option::Option<diesel::dsl::Eq<posts::title, String>>,
                std::option::Option<diesel::dsl::Eq<posts::subtitle, Option<String>>>,
                std::option::Option<diesel::dsl::Eq<posts::content, String>>,
                std::option::Option<diesel::dsl::Eq<posts::publish_date, rp1::datetime::Date>>,
                std::option::Option<diesel::dsl::Eq<posts::publish_time, rp1::datetime::Time>>,
                std::option::Option<diesel::dsl::Eq<posts::user_id, i32>>,
            ) as AsChangeset>::Changeset;
            fn as_changeset(self) -> Self::Changeset {
                (
                    self.title.map(|x| posts::title.eq(x)),
                    self.subtitle.map(|x| posts::subtitle.eq(x)),
                    self.content.map(|x| posts::content.eq(x)),
                    self.publish_date.map(|x| posts::publish_date.eq(x)),
                    self.publish_time.map(|x| posts::publish_time.eq(x)),
                    self.user_id.map(|x| posts::user_id.eq(x)),
                )
                    .as_changeset()
            }
        }
    }
    #[allow(non_snake_case, unused_extern_crates, unused_imports)]
    fn _impl_queryable_for_updatepatchpost() {
        extern crate std;
        use diesel;
        use diesel::Queryable;
        impl<__DB: diesel::backend::Backend, __ST> Queryable<__ST, __DB> for UpdatePatchPost
        where
            (
                Option<String>,
                Option<Option<String>>,
                Option<String>,
                Option<rp1::datetime::Date>,
                Option<rp1::datetime::Time>,
                Option<i32>,
            ): Queryable<__ST, __DB>,
        {
            type Row = <(
                Option<String>,
                Option<Option<String>>,
                Option<String>,
                Option<rp1::datetime::Date>,
                Option<rp1::datetime::Time>,
                Option<i32>,
            ) as Queryable<__ST, __DB>>::Row;
            fn build(row: Self::Row) -> Self {
                let row: (
                    Option<String>,
                    Option<Option<String>>,
                    Option<String>,
                    Option<rp1::datetime::Date>,
                    Option<rp1::datetime::Time>,
                    Option<i32>,
                ) = Queryable::build(row);
                Self {
                    title: (row.0.into()),
                    subtitle: (row.1.into()),
                    content: (row.2.into()),
                    publish_date: (row.3.into()),
                    publish_time: (row.4.into()),
                    user_id: (row.5.into()),
                }
            }
        }
    }
    #[table_name = "posts"]
    pub struct UpdatePutPost {
        id: i32,
        title: String,
        subtitle: Option<String>,
        content: String,
        publish_date: rp1::datetime::Date,
        publish_time: rp1::datetime::Time,
        user_id: i32,
        created_at: rp1::datetime::OffsetDateTime,
        updated_at: rp1::datetime::OffsetDateTime,
    }
    impl ::validator::Validate for UpdatePutPost {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_args(())
        }
    }
    #[allow(clippy::all)]
    impl<'v_a> ::validator::ValidateArgs<'v_a> for UpdatePutPost {
        type Args = ();
        #[allow(unused_mut)]
        #[allow(unused_variable)]
        fn validate_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            let mut errors = ::validator::ValidationErrors::new();
            let mut result = if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            };
            result
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UpdatePutPost {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "title" => _serde::__private::Ok(__Field::__field1),
                            "subtitle" => _serde::__private::Ok(__Field::__field2),
                            "content" => _serde::__private::Ok(__Field::__field3),
                            "publish_date" => _serde::__private::Ok(__Field::__field4),
                            "publish_time" => _serde::__private::Ok(__Field::__field5),
                            "user_id" => _serde::__private::Ok(__Field::__field6),
                            "created_at" => _serde::__private::Ok(__Field::__field7),
                            "updated_at" => _serde::__private::Ok(__Field::__field8),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"title" => _serde::__private::Ok(__Field::__field1),
                            b"subtitle" => _serde::__private::Ok(__Field::__field2),
                            b"content" => _serde::__private::Ok(__Field::__field3),
                            b"publish_date" => _serde::__private::Ok(__Field::__field4),
                            b"publish_time" => _serde::__private::Ok(__Field::__field5),
                            b"user_id" => _serde::__private::Ok(__Field::__field6),
                            b"created_at" => _serde::__private::Ok(__Field::__field7),
                            b"updated_at" => _serde::__private::Ok(__Field::__field8),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UpdatePutPost>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UpdatePutPost;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct UpdatePutPost")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<i32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct UpdatePutPost with 9 elements",
                                        ),
                                    );
                                }
                            };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct UpdatePutPost with 9 elements",
                                        ),
                                    );
                                }
                            };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct UpdatePutPost with 9 elements",
                                ));
                            }
                        };
                        let __field3 =
                            match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct UpdatePutPost with 9 elements",
                                        ),
                                    );
                                }
                            };
                        let __field4 = match match _serde::de::SeqAccess::next_element::<
                            rp1::datetime::Date,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct UpdatePutPost with 9 elements",
                                ));
                            }
                        };
                        let __field5 = match match _serde::de::SeqAccess::next_element::<
                            rp1::datetime::Time,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    5usize,
                                    &"struct UpdatePutPost with 9 elements",
                                ));
                            }
                        };
                        let __field6 =
                            match match _serde::de::SeqAccess::next_element::<i32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct UpdatePutPost with 9 elements",
                                        ),
                                    );
                                }
                            };
                        let __field7 = match match _serde::de::SeqAccess::next_element::<
                            rp1::datetime::OffsetDateTime,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    7usize,
                                    &"struct UpdatePutPost with 9 elements",
                                ));
                            }
                        };
                        let __field8 = match match _serde::de::SeqAccess::next_element::<
                            rp1::datetime::OffsetDateTime,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    8usize,
                                    &"struct UpdatePutPost with 9 elements",
                                ));
                            }
                        };
                        _serde::__private::Ok(UpdatePutPost {
                            id: __field0,
                            title: __field1,
                            subtitle: __field2,
                            content: __field3,
                            publish_date: __field4,
                            publish_time: __field5,
                            user_id: __field6,
                            created_at: __field7,
                            updated_at: __field8,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i32> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> =
                            _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<String>> =
                            _serde::__private::None;
                        let mut __field3: _serde::__private::Option<String> =
                            _serde::__private::None;
                        let mut __field4: _serde::__private::Option<rp1::datetime::Date> =
                            _serde::__private::None;
                        let mut __field5: _serde::__private::Option<rp1::datetime::Time> =
                            _serde::__private::None;
                        let mut __field6: _serde::__private::Option<i32> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<rp1::datetime::OffsetDateTime> =
                            _serde::__private::None;
                        let mut __field8: _serde::__private::Option<rp1::datetime::OffsetDateTime> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<i32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "title",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<String>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "subtitle",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Option<String>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "content",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<String>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "publish_date",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<rp1::datetime::Date>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "publish_time",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<rp1::datetime::Time>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "user_id",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<i32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "created_at",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            rp1::datetime::OffsetDateTime,
                                        >(&mut __map)
                                        {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "updated_at",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            rp1::datetime::OffsetDateTime,
                                        >(&mut __map)
                                        {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("title") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("subtitle") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("content") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("publish_date") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("publish_time") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("user_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("created_at") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("updated_at") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(UpdatePutPost {
                            id: __field0,
                            title: __field1,
                            subtitle: __field2,
                            content: __field3,
                            publish_date: __field4,
                            publish_time: __field5,
                            user_id: __field6,
                            created_at: __field7,
                            updated_at: __field8,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &[
                    "id",
                    "title",
                    "subtitle",
                    "content",
                    "publish_date",
                    "publish_time",
                    "user_id",
                    "created_at",
                    "updated_at",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UpdatePutPost",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UpdatePutPost>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_snake_case)]
    const _: () = { # [doc = r" Rocket generated FormForm context."] # [doc (hidden)] pub struct FromFormGeneratedContext < '__f > { __opts : :: rocket :: form :: prelude :: Options , __errors : :: rocket :: form :: prelude :: Errors < '__f > , __parent : :: std :: option :: Option < & '__f :: rocket :: form :: prelude :: Name > , id : :: std :: option :: Option < < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , title : :: std :: option :: Option < < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , subtitle : :: std :: option :: Option < < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , content : :: std :: option :: Option < < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , publish_date : :: std :: option :: Option < < rp1 :: datetime :: Date as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , publish_time : :: std :: option :: Option < < rp1 :: datetime :: Time as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , user_id : :: std :: option :: Option < < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , created_at : :: std :: option :: Option < < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , updated_at : :: std :: option :: Option < < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , } # [allow (unused_imports)] use :: rocket :: http :: uncased :: AsUncased ; impl < '__f > :: rocket :: form :: prelude :: FromForm < '__f > for UpdatePutPost { type Context = FromFormGeneratedContext < '__f > ; fn init (__opts : :: rocket :: form :: prelude :: Options) -> Self :: Context { Self :: Context { __opts , __errors : :: rocket :: form :: prelude :: Errors :: new () , __parent : :: std :: option :: Option :: None , id : :: std :: option :: Option :: None , title : :: std :: option :: Option :: None , subtitle : :: std :: option :: Option :: None , content : :: std :: option :: Option :: None , publish_date : :: std :: option :: Option :: None , publish_time : :: std :: option :: Option :: None , user_id : :: std :: option :: Option :: None , created_at : :: std :: option :: Option :: None , updated_at : :: std :: option :: Option :: None , } } fn push_value (__c : & mut Self :: Context , __f : :: rocket :: form :: prelude :: ValueField < '__f >) { __c . __parent = __f . name . parent () ; match __f . name . key_lossy () . as_str () { "id" => { { < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . id . get_or_insert_with (| | < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "title" => { { < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . title . get_or_insert_with (| | < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "subtitle" => { { < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . subtitle . get_or_insert_with (| | < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "content" => { { < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . content . get_or_insert_with (| | < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "publish_date" => { { < rp1 :: datetime :: Date as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . publish_date . get_or_insert_with (| | < rp1 :: datetime :: Date as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "publish_time" => { { < rp1 :: datetime :: Time as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . publish_time . get_or_insert_with (| | < rp1 :: datetime :: Time as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "user_id" => { { < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . user_id . get_or_insert_with (| | < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "created_at" => { { < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . created_at . get_or_insert_with (| | < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "updated_at" => { { < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . updated_at . get_or_insert_with (| | < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } __k if __k == "_method" || ! __c . __opts . strict => { } _ => __c . __errors . push (__f . unexpected ()) , } } # [allow (clippy :: let_unit_value , clippy :: type_complexity , clippy :: type_repetition_in_bounds , clippy :: used_underscore_binding)] fn push_data < 'life0 , 'life1 , 'async_trait > (__c : & 'life0 mut FromFormGeneratedContext < '__f > , __f : :: rocket :: form :: prelude :: DataField < '__f , 'life1 >) -> :: core :: pin :: Pin < Box < dyn :: core :: future :: Future < Output = () > + :: core :: marker :: Send + 'async_trait > > where '__f : 'async_trait , 'life0 : 'async_trait , 'life1 : 'async_trait { Box :: pin (async move { let __c = __c ; let __f = __f ; let _ : () = { __c . __parent = __f . name . parent () ; match __f . name . key_lossy () . as_str () { "id" => { { let _fut = < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . id . get_or_insert_with (| | < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "title" => { { let _fut = < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . title . get_or_insert_with (| | < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "subtitle" => { { let _fut = < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . subtitle . get_or_insert_with (| | < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "content" => { { let _fut = < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . content . get_or_insert_with (| | < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "publish_date" => { { let _fut = < rp1 :: datetime :: Date as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . publish_date . get_or_insert_with (| | < rp1 :: datetime :: Date as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "publish_time" => { { let _fut = < rp1 :: datetime :: Time as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . publish_time . get_or_insert_with (| | < rp1 :: datetime :: Time as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "user_id" => { { let _fut = < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . user_id . get_or_insert_with (| | < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "created_at" => { { let _fut = < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . created_at . get_or_insert_with (| | < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "updated_at" => { { let _fut = < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . updated_at . get_or_insert_with (| | < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } __k if __k == "_method" || ! __c . __opts . strict => { } _ => __c . __errors . push (__f . unexpected ()) , } } ; }) } fn finalize (mut __c : Self :: Context) -> :: std :: result :: Result < Self , :: rocket :: form :: prelude :: Errors < '__f > > { # [allow (unused_imports)] use :: rocket :: form :: prelude :: validate :: * ; let id = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "id")) ; let __opts = __c . __opts ; __c . id . map_or_else (| | { < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| id | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | id) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (id) => :: std :: option :: Option :: Some (id) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let title = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "title")) ; let __opts = __c . __opts ; __c . title . map_or_else (| | { < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| title | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | title) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (title) => :: std :: option :: Option :: Some (title) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let subtitle = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "subtitle")) ; let __opts = __c . __opts ; __c . subtitle . map_or_else (| | { < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| subtitle | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | subtitle) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (subtitle) => :: std :: option :: Option :: Some (subtitle) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let content = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "content")) ; let __opts = __c . __opts ; __c . content . map_or_else (| | { < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| content | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | content) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (content) => :: std :: option :: Option :: Some (content) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let publish_date = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "publish_date")) ; let __opts = __c . __opts ; __c . publish_date . map_or_else (| | { < rp1 :: datetime :: Date as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < rp1 :: datetime :: Date as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| publish_date | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | publish_date) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (publish_date) => :: std :: option :: Option :: Some (publish_date) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let publish_time = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "publish_time")) ; let __opts = __c . __opts ; __c . publish_time . map_or_else (| | { < rp1 :: datetime :: Time as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < rp1 :: datetime :: Time as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| publish_time | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | publish_time) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (publish_time) => :: std :: option :: Option :: Some (publish_time) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let user_id = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "user_id")) ; let __opts = __c . __opts ; __c . user_id . map_or_else (| | { < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| user_id | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | user_id) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (user_id) => :: std :: option :: Option :: Some (user_id) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let created_at = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "created_at")) ; let __opts = __c . __opts ; __c . created_at . map_or_else (| | { < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| created_at | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | created_at) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (created_at) => :: std :: option :: Option :: Some (created_at) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let updated_at = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "updated_at")) ; let __opts = __c . __opts ; __c . updated_at . map_or_else (| | { < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| updated_at | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | updated_at) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (updated_at) => :: std :: option :: Option :: Some (updated_at) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; if ! __c . __errors . is_empty () { return :: std :: result :: Result :: Err (__c . __errors) ; } let __o = Self { id : id . unwrap () , title : title . unwrap () , subtitle : subtitle . unwrap () , content : content . unwrap () , publish_date : publish_date . unwrap () , publish_time : publish_time . unwrap () , user_id : user_id . unwrap () , created_at : created_at . unwrap () , updated_at : updated_at . unwrap () , } ; if ! __c . __errors . is_empty () { return :: std :: result :: Result :: Err (__c . __errors) ; } Ok (__o) } } };
    #[allow(non_snake_case, unused_extern_crates, unused_imports)]
    fn _impl_as_changeset_for_updateputpost() {
        extern crate std;
        use diesel;
        use diesel::query_builder::AsChangeset;
        use diesel::prelude::*;
        impl<'update> AsChangeset for &'update UpdatePutPost {
            type Target = posts::table;
            type Changeset = <(
                diesel::dsl::Eq<posts::title, &'update String>,
                std::option::Option<diesel::dsl::Eq<posts::subtitle, &'update String>>,
                diesel::dsl::Eq<posts::content, &'update String>,
                diesel::dsl::Eq<posts::publish_date, &'update rp1::datetime::Date>,
                diesel::dsl::Eq<posts::publish_time, &'update rp1::datetime::Time>,
                diesel::dsl::Eq<posts::user_id, &'update i32>,
                diesel::dsl::Eq<posts::created_at, &'update rp1::datetime::OffsetDateTime>,
                diesel::dsl::Eq<posts::updated_at, &'update rp1::datetime::OffsetDateTime>,
            ) as AsChangeset>::Changeset;
            fn as_changeset(self) -> Self::Changeset {
                (
                    posts::title.eq(&self.title),
                    self.subtitle.as_ref().map(|x| posts::subtitle.eq(x)),
                    posts::content.eq(&self.content),
                    posts::publish_date.eq(&self.publish_date),
                    posts::publish_time.eq(&self.publish_time),
                    posts::user_id.eq(&self.user_id),
                    posts::created_at.eq(&self.created_at),
                    posts::updated_at.eq(&self.updated_at),
                )
                    .as_changeset()
            }
        }
        impl<'update> AsChangeset for UpdatePutPost {
            type Target = posts::table;
            type Changeset = <(
                diesel::dsl::Eq<posts::title, String>,
                std::option::Option<diesel::dsl::Eq<posts::subtitle, String>>,
                diesel::dsl::Eq<posts::content, String>,
                diesel::dsl::Eq<posts::publish_date, rp1::datetime::Date>,
                diesel::dsl::Eq<posts::publish_time, rp1::datetime::Time>,
                diesel::dsl::Eq<posts::user_id, i32>,
                diesel::dsl::Eq<posts::created_at, rp1::datetime::OffsetDateTime>,
                diesel::dsl::Eq<posts::updated_at, rp1::datetime::OffsetDateTime>,
            ) as AsChangeset>::Changeset;
            fn as_changeset(self) -> Self::Changeset {
                (
                    posts::title.eq(self.title),
                    self.subtitle.map(|x| posts::subtitle.eq(x)),
                    posts::content.eq(self.content),
                    posts::publish_date.eq(self.publish_date),
                    posts::publish_time.eq(self.publish_time),
                    posts::user_id.eq(self.user_id),
                    posts::created_at.eq(self.created_at),
                    posts::updated_at.eq(self.updated_at),
                )
                    .as_changeset()
            }
        }
    }
    #[allow(non_snake_case, unused_extern_crates, unused_imports)]
    fn _impl_queryable_for_updateputpost() {
        extern crate std;
        use diesel;
        use diesel::Queryable;
        impl<__DB: diesel::backend::Backend, __ST> Queryable<__ST, __DB> for UpdatePutPost
        where
            (
                i32,
                String,
                Option<String>,
                String,
                rp1::datetime::Date,
                rp1::datetime::Time,
                i32,
                rp1::datetime::OffsetDateTime,
                rp1::datetime::OffsetDateTime,
            ): Queryable<__ST, __DB>,
        {
            type Row = <(
                i32,
                String,
                Option<String>,
                String,
                rp1::datetime::Date,
                rp1::datetime::Time,
                i32,
                rp1::datetime::OffsetDateTime,
                rp1::datetime::OffsetDateTime,
            ) as Queryable<__ST, __DB>>::Row;
            fn build(row: Self::Row) -> Self {
                let row: (
                    i32,
                    String,
                    Option<String>,
                    String,
                    rp1::datetime::Date,
                    rp1::datetime::Time,
                    i32,
                    rp1::datetime::OffsetDateTime,
                    rp1::datetime::OffsetDateTime,
                ) = Queryable::build(row);
                Self {
                    id: (row.0.into()),
                    title: (row.1.into()),
                    subtitle: (row.2.into()),
                    content: (row.3.into()),
                    publish_date: (row.4.into()),
                    publish_time: (row.5.into()),
                    user_id: (row.6.into()),
                    created_at: (row.7.into()),
                    updated_at: (row.8.into()),
                }
            }
        }
    }
    impl UpdatePutPost {
        pub fn create(base: &Post, patch: &UpdatePatchPost) -> UpdatePutPost {
            let title = if let Some(ref v) = patch.title {
                v.clone()
            } else {
                base.title.clone()
            };
            let subtitle = if let Some(ref v) = patch.subtitle {
                v.clone()
            } else {
                base.subtitle.clone()
            };
            let content = if let Some(ref v) = patch.content {
                v.clone()
            } else {
                base.content.clone()
            };
            let publish_date = if let Some(ref v) = patch.publish_date {
                v.clone()
            } else {
                base.publish_date.clone()
            };
            let publish_time = if let Some(ref v) = patch.publish_time {
                v.clone()
            } else {
                base.publish_time.clone()
            };
            let user_id = if let Some(ref v) = patch.user_id {
                v.clone()
            } else {
                base.user_id.clone()
            };
            UpdatePutPost {
                title,
                subtitle,
                content,
                publish_date,
                publish_time,
                user_id,
                id: base.id.clone(),
                created_at: base.created_at.clone(),
                updated_at: base.updated_at.clone(),
            }
        }
        pub fn validate_update(&self, base: &Post) -> ::rp1::CrudResult<()> {
            if self.id != base.id {
                return Err(::rp1::CrudError::UnchangeableField("id".to_owned()));
            }
            if self.created_at != base.created_at {
                return Err(::rp1::CrudError::UnchangeableField("created_at".to_owned()));
            }
            if self.updated_at != base.updated_at {
                return Err(::rp1::CrudError::UnchangeableField("updated_at".to_owned()));
            }
            Ok(())
        }
        pub fn into_patch(self, base: &Post) -> UpdatePatchPost {
            UpdatePatchPost {
                title: if self.title == base.title {
                    None
                } else {
                    Some(self.title)
                },
                subtitle: if self.subtitle == base.subtitle {
                    None
                } else {
                    Some(self.subtitle)
                },
                content: if self.content == base.content {
                    None
                } else {
                    Some(self.content)
                },
                publish_date: if self.publish_date == base.publish_date {
                    None
                } else {
                    Some(self.publish_date)
                },
                publish_time: if self.publish_time == base.publish_time {
                    None
                } else {
                    Some(self.publish_time)
                },
                user_id: if self.user_id == base.user_id {
                    None
                } else {
                    Some(self.user_id)
                },
            }
        }
    }
    impl ::rp1::CrudUpdatable for Post {
        type PatchType = UpdatePatchPost;
        type PutType = UpdatePutPost;
    }
    async fn update_put_fn_help(
        db: Db,
        id: i32,
        value: UpdatePutPost,
        auth_user: <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<Post> {
        let row = db
            .run(move |conn| crate::schema::posts::table.find(id).first::<Post>(conn))
            .await?;
        if !<Post as ::rp1::CheckPermissions>::allow_update(&row, &value, &auth_user) {
            return Err(::rp1::CrudError::NotFound);
        }
        value.validate_update(&row)?;
        use ::validator::Validate;
        value.validate()?;
        Ok(::rocket::serde::json::Json(
            db.run(move |conn| {
                diesel::update(crate::schema::posts::table.find(id))
                    .set(&value)
                    .get_result(conn)
            })
            .await?,
        ))
    }
    async fn update_patch_fn_help(
        db: Db,
        id: i32,
        value: UpdatePatchPost,
        auth_user: <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<Post> {
        let row = db
            .run(move |conn| crate::schema::posts::table.find(id).first::<Post>(conn))
            .await?;
        let put_value = UpdatePutPost::create(&row, &value);
        if !<Post as ::rp1::CheckPermissions>::allow_update(&row, &put_value, &auth_user) {
            return Err(::rp1::CrudError::NotFound);
        }
        use ::validator::Validate;
        value.validate()?;
        Ok(::rocket::serde::json::Json(
            db.run(move |conn| {
                diesel::update(crate::schema::posts::table.find(id))
                    .set(&value)
                    .get_result(conn)
            })
            .await?,
        ))
    }
    async fn update_patch_fn_json(
        db: Db,
        id: i32,
        value: ::rocket::serde::json::Json<UpdatePatchPost>,
        auth_user: <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<Post> {
        let value = value.into_inner();
        update_patch_fn_help(db, id, value, auth_user).await
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct update_patch_fn_json {}
    /// Rocket code generated proxy static conversion implementations.
    impl update_patch_fn_json {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::post",
                                                "example/src/main.rs",
                                                53u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::post",
                                                "example/src/main.rs",
                                                53u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let __rocket_id: i32 = match __req.routed_segment(0usize) {
                        ::std::option::Option::Some(__s) => {
                            match <i32 as ::rocket::request::FromParam>::from_param(__s) {
                                ::std::result::Result::Ok(__v) => __v,
                                ::std::result::Result::Err(__error) => {
                                    return {
                                        {
                                            let lvl = ::log::Level::Warn;
                                            if lvl <= ::log::STATIC_MAX_LEVEL
                                                && lvl <= ::log::max_level()
                                            {
                                                :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , ": " , "` param guard parsed forwarding with error "] , & match (& "id" , & "i32" , & __error) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ;
                                            }
                                        };
                                        ::rocket::outcome::Outcome::Forward(__data)
                                    }
                                }
                            }
                        }
                        ::std::option::Option::None => {
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Internal invariant broken: dyn param not found."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::post", "example/src/main.rs", 56u32),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Please report this to the Rocket issue tracker."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::post", "example/src/main.rs", 56u32),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["https://github.com/SergioBenitez/Rocket/issues"],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::post", "example/src/main.rs", 56u32),
                                    );
                                }
                            };
                            return ::rocket::outcome::Outcome::Forward(__data);
                        }
                    };
                    let __rocket_value : :: rocket :: serde :: json :: Json < UpdatePatchPost > = match < :: rocket :: serde :: json :: Json < UpdatePatchPost > as :: rocket :: data :: FromData > :: from_data (__req , __data) . await { :: rocket :: outcome :: Outcome :: Success (__d) => __d , :: rocket :: outcome :: Outcome :: Forward (__d) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard is forwarding."] , & match (& ":: rocket :: serde :: json :: Json < UpdatePatchPost >" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__d) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard failed: " , "."] , & match (& ":: rocket :: serde :: json :: Json < UpdatePatchPost >" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let ___responder = update_patch_fn_json(
                        __rocket_db,
                        __rocket_id,
                        __rocket_value,
                        __rocket_auth_user,
                    )
                    .await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "update_patch_fn_json",
                method: ::rocket::http::Method::Patch,
                uri: "/<id>",
                handler: monomorphized_function,
                format: ::std::option::Option::Some(::rocket::http::MediaType::const_new(
                    "application",
                    "json",
                    &[],
                )),
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<i32>(),
                            type_name: std::any::type_name::<i32>(),
                            parent: None,
                            location: ("example/src/main.rs", 56u32, 9u32),
                            specialized: Resolve::<i32>::SPECIALIZED,
                            abort: Resolve::<i32>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized: Resolve::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Post>(),
                            type_name: std::any::type_name::<Post>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 54u32, 8u32),
                            specialized: Resolve::<Post>::SPECIALIZED,
                            abort: Resolve::<Post>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::CrudJsonResult<Post>>(),
                            type_name: std::any::type_name::<::rp1::CrudJsonResult<Post>>(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized: Resolve::<::rp1::CrudJsonResult<Post>>::SPECIALIZED,
                            abort: Resolve::<::rp1::CrudJsonResult<Post>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Post>(),
                            type_name: std::any::type_name::<Post>(),
                            parent: None
                                .or(Some(std::any::TypeId::of::<::rp1::CrudJsonResult<Post>>())),
                            location: ("example/src/main.rs", 54u32, 8u32),
                            specialized: Resolve::<Post>::SPECIALIZED,
                            abort: Resolve::<Post>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_update_patch_fn_json_10688097563383592408 as rocket_uri_macro_update_patch_fn_json;
    async fn update_patch_fn_form(
        db: Db,
        id: i32,
        value: ::rocket::form::Form<UpdatePatchPost>,
        auth_user: <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<Post> {
        let value = value.into_inner();
        update_patch_fn_help(db, id, value, auth_user).await
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct update_patch_fn_form {}
    /// Rocket code generated proxy static conversion implementations.
    impl update_patch_fn_form {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::post",
                                                "example/src/main.rs",
                                                53u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::post",
                                                "example/src/main.rs",
                                                53u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let __rocket_id: i32 = match __req.routed_segment(0usize) {
                        ::std::option::Option::Some(__s) => {
                            match <i32 as ::rocket::request::FromParam>::from_param(__s) {
                                ::std::result::Result::Ok(__v) => __v,
                                ::std::result::Result::Err(__error) => {
                                    return {
                                        {
                                            let lvl = ::log::Level::Warn;
                                            if lvl <= ::log::STATIC_MAX_LEVEL
                                                && lvl <= ::log::max_level()
                                            {
                                                :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , ": " , "` param guard parsed forwarding with error "] , & match (& "id" , & "i32" , & __error) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ;
                                            }
                                        };
                                        ::rocket::outcome::Outcome::Forward(__data)
                                    }
                                }
                            }
                        }
                        ::std::option::Option::None => {
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Internal invariant broken: dyn param not found."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::post", "example/src/main.rs", 56u32),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Please report this to the Rocket issue tracker."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::post", "example/src/main.rs", 56u32),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["https://github.com/SergioBenitez/Rocket/issues"],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::post", "example/src/main.rs", 56u32),
                                    );
                                }
                            };
                            return ::rocket::outcome::Outcome::Forward(__data);
                        }
                    };
                    let __rocket_value : :: rocket :: form :: Form < UpdatePatchPost > = match < :: rocket :: form :: Form < UpdatePatchPost > as :: rocket :: data :: FromData > :: from_data (__req , __data) . await { :: rocket :: outcome :: Outcome :: Success (__d) => __d , :: rocket :: outcome :: Outcome :: Forward (__d) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard is forwarding."] , & match (& ":: rocket :: form :: Form < UpdatePatchPost >" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__d) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard failed: " , "."] , & match (& ":: rocket :: form :: Form < UpdatePatchPost >" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let ___responder = update_patch_fn_form(
                        __rocket_db,
                        __rocket_id,
                        __rocket_value,
                        __rocket_auth_user,
                    )
                    .await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "update_patch_fn_form",
                method: ::rocket::http::Method::Patch,
                uri: "/<id>",
                handler: monomorphized_function,
                format: ::std::option::Option::Some(::rocket::http::MediaType::const_new(
                    "application",
                    "x-www-form-urlencoded",
                    &[],
                )),
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<i32>(),
                            type_name: std::any::type_name::<i32>(),
                            parent: None,
                            location: ("example/src/main.rs", 56u32, 9u32),
                            specialized: Resolve::<i32>::SPECIALIZED,
                            abort: Resolve::<i32>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized: Resolve::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Post>(),
                            type_name: std::any::type_name::<Post>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 54u32, 8u32),
                            specialized: Resolve::<Post>::SPECIALIZED,
                            abort: Resolve::<Post>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::CrudJsonResult<Post>>(),
                            type_name: std::any::type_name::<::rp1::CrudJsonResult<Post>>(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized: Resolve::<::rp1::CrudJsonResult<Post>>::SPECIALIZED,
                            abort: Resolve::<::rp1::CrudJsonResult<Post>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Post>(),
                            type_name: std::any::type_name::<Post>(),
                            parent: None
                                .or(Some(std::any::TypeId::of::<::rp1::CrudJsonResult<Post>>())),
                            location: ("example/src/main.rs", 54u32, 8u32),
                            specialized: Resolve::<Post>::SPECIALIZED,
                            abort: Resolve::<Post>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_update_patch_fn_form_8818295953209428047 as rocket_uri_macro_update_patch_fn_form;
    async fn update_put_fn_json(
        db: Db,
        id: i32,
        value: ::rocket::serde::json::Json<UpdatePutPost>,
        auth_user: <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<Post> {
        let value = value.into_inner();
        update_put_fn_help(db, id, value, auth_user).await
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct update_put_fn_json {}
    /// Rocket code generated proxy static conversion implementations.
    impl update_put_fn_json {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::post",
                                                "example/src/main.rs",
                                                53u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::post",
                                                "example/src/main.rs",
                                                53u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let __rocket_id: i32 = match __req.routed_segment(0usize) {
                        ::std::option::Option::Some(__s) => {
                            match <i32 as ::rocket::request::FromParam>::from_param(__s) {
                                ::std::result::Result::Ok(__v) => __v,
                                ::std::result::Result::Err(__error) => {
                                    return {
                                        {
                                            let lvl = ::log::Level::Warn;
                                            if lvl <= ::log::STATIC_MAX_LEVEL
                                                && lvl <= ::log::max_level()
                                            {
                                                :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , ": " , "` param guard parsed forwarding with error "] , & match (& "id" , & "i32" , & __error) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ;
                                            }
                                        };
                                        ::rocket::outcome::Outcome::Forward(__data)
                                    }
                                }
                            }
                        }
                        ::std::option::Option::None => {
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Internal invariant broken: dyn param not found."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::post", "example/src/main.rs", 56u32),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Please report this to the Rocket issue tracker."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::post", "example/src/main.rs", 56u32),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["https://github.com/SergioBenitez/Rocket/issues"],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::post", "example/src/main.rs", 56u32),
                                    );
                                }
                            };
                            return ::rocket::outcome::Outcome::Forward(__data);
                        }
                    };
                    let __rocket_value : :: rocket :: serde :: json :: Json < UpdatePutPost > = match < :: rocket :: serde :: json :: Json < UpdatePutPost > as :: rocket :: data :: FromData > :: from_data (__req , __data) . await { :: rocket :: outcome :: Outcome :: Success (__d) => __d , :: rocket :: outcome :: Outcome :: Forward (__d) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard is forwarding."] , & match (& ":: rocket :: serde :: json :: Json < UpdatePutPost >" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__d) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard failed: " , "."] , & match (& ":: rocket :: serde :: json :: Json < UpdatePutPost >" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let ___responder = update_put_fn_json(
                        __rocket_db,
                        __rocket_id,
                        __rocket_value,
                        __rocket_auth_user,
                    )
                    .await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "update_put_fn_json",
                method: ::rocket::http::Method::Put,
                uri: "/<id>",
                handler: monomorphized_function,
                format: ::std::option::Option::Some(::rocket::http::MediaType::const_new(
                    "application",
                    "json",
                    &[],
                )),
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<i32>(),
                            type_name: std::any::type_name::<i32>(),
                            parent: None,
                            location: ("example/src/main.rs", 56u32, 9u32),
                            specialized: Resolve::<i32>::SPECIALIZED,
                            abort: Resolve::<i32>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized: Resolve::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Post>(),
                            type_name: std::any::type_name::<Post>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 54u32, 8u32),
                            specialized: Resolve::<Post>::SPECIALIZED,
                            abort: Resolve::<Post>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::CrudJsonResult<Post>>(),
                            type_name: std::any::type_name::<::rp1::CrudJsonResult<Post>>(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized: Resolve::<::rp1::CrudJsonResult<Post>>::SPECIALIZED,
                            abort: Resolve::<::rp1::CrudJsonResult<Post>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Post>(),
                            type_name: std::any::type_name::<Post>(),
                            parent: None
                                .or(Some(std::any::TypeId::of::<::rp1::CrudJsonResult<Post>>())),
                            location: ("example/src/main.rs", 54u32, 8u32),
                            specialized: Resolve::<Post>::SPECIALIZED,
                            abort: Resolve::<Post>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_update_put_fn_json_11483154154003803484 as rocket_uri_macro_update_put_fn_json;
    async fn update_put_fn_form(
        db: Db,
        id: i32,
        value: ::rocket::serde::json::Json<UpdatePutPost>,
        auth_user: <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<Post> {
        let value = value.into_inner();
        update_put_fn_help(db, id, value, auth_user).await
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct update_put_fn_form {}
    /// Rocket code generated proxy static conversion implementations.
    impl update_put_fn_form {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::post",
                                                "example/src/main.rs",
                                                53u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::post",
                                                "example/src/main.rs",
                                                53u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let __rocket_id: i32 = match __req.routed_segment(0usize) {
                        ::std::option::Option::Some(__s) => {
                            match <i32 as ::rocket::request::FromParam>::from_param(__s) {
                                ::std::result::Result::Ok(__v) => __v,
                                ::std::result::Result::Err(__error) => {
                                    return {
                                        {
                                            let lvl = ::log::Level::Warn;
                                            if lvl <= ::log::STATIC_MAX_LEVEL
                                                && lvl <= ::log::max_level()
                                            {
                                                :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , ": " , "` param guard parsed forwarding with error "] , & match (& "id" , & "i32" , & __error) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ;
                                            }
                                        };
                                        ::rocket::outcome::Outcome::Forward(__data)
                                    }
                                }
                            }
                        }
                        ::std::option::Option::None => {
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Internal invariant broken: dyn param not found."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::post", "example/src/main.rs", 56u32),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Please report this to the Rocket issue tracker."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::post", "example/src/main.rs", 56u32),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["https://github.com/SergioBenitez/Rocket/issues"],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::post", "example/src/main.rs", 56u32),
                                    );
                                }
                            };
                            return ::rocket::outcome::Outcome::Forward(__data);
                        }
                    };
                    let __rocket_value : :: rocket :: serde :: json :: Json < UpdatePutPost > = match < :: rocket :: serde :: json :: Json < UpdatePutPost > as :: rocket :: data :: FromData > :: from_data (__req , __data) . await { :: rocket :: outcome :: Outcome :: Success (__d) => __d , :: rocket :: outcome :: Outcome :: Forward (__d) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard is forwarding."] , & match (& ":: rocket :: serde :: json :: Json < UpdatePutPost >" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__d) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard failed: " , "."] , & match (& ":: rocket :: serde :: json :: Json < UpdatePutPost >" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let ___responder = update_put_fn_form(
                        __rocket_db,
                        __rocket_id,
                        __rocket_value,
                        __rocket_auth_user,
                    )
                    .await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "update_put_fn_form",
                method: ::rocket::http::Method::Put,
                uri: "/<id>",
                handler: monomorphized_function,
                format: ::std::option::Option::Some(::rocket::http::MediaType::const_new(
                    "application",
                    "x-www-form-urlencoded",
                    &[],
                )),
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<i32>(),
                            type_name: std::any::type_name::<i32>(),
                            parent: None,
                            location: ("example/src/main.rs", 56u32, 9u32),
                            specialized: Resolve::<i32>::SPECIALIZED,
                            abort: Resolve::<i32>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized: Resolve::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Post>(),
                            type_name: std::any::type_name::<Post>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 54u32, 8u32),
                            specialized: Resolve::<Post>::SPECIALIZED,
                            abort: Resolve::<Post>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::CrudJsonResult<Post>>(),
                            type_name: std::any::type_name::<::rp1::CrudJsonResult<Post>>(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized: Resolve::<::rp1::CrudJsonResult<Post>>::SPECIALIZED,
                            abort: Resolve::<::rp1::CrudJsonResult<Post>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Post>(),
                            type_name: std::any::type_name::<Post>(),
                            parent: None
                                .or(Some(std::any::TypeId::of::<::rp1::CrudJsonResult<Post>>())),
                            location: ("example/src/main.rs", 54u32, 8u32),
                            specialized: Resolve::<Post>::SPECIALIZED,
                            abort: Resolve::<Post>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_update_put_fn_form_1178743118699988312 as rocket_uri_macro_update_put_fn_form;
    async fn delete_fn(
        db: Db,
        id: i32,
        auth_user: <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudResult<::rocket::serde::json::Value> {
        let row = db
            .run(move |conn| crate::schema::posts::table.find(id).first::<Post>(conn))
            .await?;
        if !<Post as ::rp1::CheckPermissions>::allow_delete(&row, &auth_user) {
            return Err(::rp1::CrudError::NotFound);
        }
        let deleted = db
            .run(move |conn| diesel::delete(crate::schema::posts::table.find(id)).execute(conn))
            .await?;
        Ok(::serde_json::Value::Object({
            let mut object = ::serde_json::Map::new();
            let _ = object.insert(
                ("deleted").into(),
                ::serde_json::to_value(&deleted).unwrap(),
            );
            object
        }))
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct delete_fn {}
    /// Rocket code generated proxy static conversion implementations.
    impl delete_fn {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::post",
                                                "example/src/main.rs",
                                                53u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::post",
                                                "example/src/main.rs",
                                                53u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let __rocket_id: i32 = match __req.routed_segment(0usize) {
                        ::std::option::Option::Some(__s) => {
                            match <i32 as ::rocket::request::FromParam>::from_param(__s) {
                                ::std::result::Result::Ok(__v) => __v,
                                ::std::result::Result::Err(__error) => {
                                    return {
                                        {
                                            let lvl = ::log::Level::Warn;
                                            if lvl <= ::log::STATIC_MAX_LEVEL
                                                && lvl <= ::log::max_level()
                                            {
                                                :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , ": " , "` param guard parsed forwarding with error "] , & match (& "id" , & "i32" , & __error) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ;
                                            }
                                        };
                                        ::rocket::outcome::Outcome::Forward(__data)
                                    }
                                }
                            }
                        }
                        ::std::option::Option::None => {
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Internal invariant broken: dyn param not found."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::post", "example/src/main.rs", 56u32),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Please report this to the Rocket issue tracker."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::post", "example/src/main.rs", 56u32),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["https://github.com/SergioBenitez/Rocket/issues"],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::post", "example/src/main.rs", 56u32),
                                    );
                                }
                            };
                            return ::rocket::outcome::Outcome::Forward(__data);
                        }
                    };
                    let ___responder =
                        delete_fn(__rocket_db, __rocket_id, __rocket_auth_user).await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "delete_fn",
                method: ::rocket::http::Method::Delete,
                uri: "/<id>",
                handler: monomorphized_function,
                format: ::std::option::Option::None,
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<i32>(),
                            type_name: std::any::type_name::<i32>(),
                            parent: None,
                            location: ("example/src/main.rs", 56u32, 9u32),
                            specialized: Resolve::<i32>::SPECIALIZED,
                            abort: Resolve::<i32>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized: Resolve::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Post>(),
                            type_name: std::any::type_name::<Post>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 54u32, 8u32),
                            specialized: Resolve::<Post>::SPECIALIZED,
                            abort: Resolve::<Post>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        :: rocket :: sentinel :: Sentry { type_id : std :: any :: TypeId :: of :: < :: rp1 :: CrudResult < :: rocket :: serde :: json :: Value > > () , type_name : std :: any :: type_name :: < :: rp1 :: CrudResult < :: rocket :: serde :: json :: Value > > () , parent : None , location : ("example/src/main.rs" , 53u32 , 1u32) , specialized : Resolve :: < :: rp1 :: CrudResult < :: rocket :: serde :: json :: Value > > :: SPECIALIZED , abort : Resolve :: < :: rp1 :: CrudResult < :: rocket :: serde :: json :: Value > > :: abort , }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rocket::serde::json::Value>(),
                            type_name: std::any::type_name::<::rocket::serde::json::Value>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                ::rp1::CrudResult<::rocket::serde::json::Value>,
                            >())),
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized: Resolve::<::rocket::serde::json::Value>::SPECIALIZED,
                            abort: Resolve::<::rocket::serde::json::Value>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_delete_fn_15274514882328096603 as rocket_uri_macro_delete_fn;
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    pub enum SortableFields {
        id,
        title,
        subtitle,
        content,
        publish_date,
        publish_time,
        user_id,
        created_at,
        updated_at,
    }
    #[allow(non_snake_case)]
    const _: () = {
        #[allow(unused_imports)]
        use ::rocket::http::uncased::AsUncased;
        impl<'__v> ::rocket::form::prelude::FromFormField<'__v> for SortableFields {
            fn from_value(
                __f: ::rocket::form::prelude::ValueField<'__v>,
            ) -> Result<Self, ::rocket::form::prelude::Errors<'__v>> {
                if __f.value.as_uncased() == "id" {
                    return ::std::result::Result::Ok(SortableFields::id);
                }
                if __f.value.as_uncased() == "title" {
                    return ::std::result::Result::Ok(SortableFields::title);
                }
                if __f.value.as_uncased() == "subtitle" {
                    return ::std::result::Result::Ok(SortableFields::subtitle);
                }
                if __f.value.as_uncased() == "content" {
                    return ::std::result::Result::Ok(SortableFields::content);
                }
                if __f.value.as_uncased() == "publish_date" {
                    return ::std::result::Result::Ok(SortableFields::publish_date);
                }
                if __f.value.as_uncased() == "publish_time" {
                    return ::std::result::Result::Ok(SortableFields::publish_time);
                }
                if __f.value.as_uncased() == "user_id" {
                    return ::std::result::Result::Ok(SortableFields::user_id);
                }
                if __f.value.as_uncased() == "created_at" {
                    return ::std::result::Result::Ok(SortableFields::created_at);
                }
                if __f.value.as_uncased() == "updated_at" {
                    return ::std::result::Result::Ok(SortableFields::updated_at);
                }
                const OPTS: &'static [::std::borrow::Cow<'static, str>] = &[
                    ::std::borrow::Cow::Borrowed("id"),
                    ::std::borrow::Cow::Borrowed("title"),
                    ::std::borrow::Cow::Borrowed("subtitle"),
                    ::std::borrow::Cow::Borrowed("content"),
                    ::std::borrow::Cow::Borrowed("publish_date"),
                    ::std::borrow::Cow::Borrowed("publish_time"),
                    ::std::borrow::Cow::Borrowed("user_id"),
                    ::std::borrow::Cow::Borrowed("created_at"),
                    ::std::borrow::Cow::Borrowed("updated_at"),
                ];
                let _error = ::rocket::form::prelude::Error::from(OPTS)
                    .with_name(__f.name)
                    .with_value(__f.value);
                ::std::result::Result::Err(_error)?
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::fmt::Debug for SortableFields {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&SortableFields::id,) => ::core::fmt::Formatter::write_str(f, "id"),
                (&SortableFields::title,) => ::core::fmt::Formatter::write_str(f, "title"),
                (&SortableFields::subtitle,) => ::core::fmt::Formatter::write_str(f, "subtitle"),
                (&SortableFields::content,) => ::core::fmt::Formatter::write_str(f, "content"),
                (&SortableFields::publish_date,) => {
                    ::core::fmt::Formatter::write_str(f, "publish_date")
                }
                (&SortableFields::publish_time,) => {
                    ::core::fmt::Formatter::write_str(f, "publish_time")
                }
                (&SortableFields::user_id,) => ::core::fmt::Formatter::write_str(f, "user_id"),
                (&SortableFields::created_at,) => {
                    ::core::fmt::Formatter::write_str(f, "created_at")
                }
                (&SortableFields::updated_at,) => {
                    ::core::fmt::Formatter::write_str(f, "updated_at")
                }
            }
        }
    }
    use ::rocket::request::{self, Request, FromRequest};
    pub struct PostFilterSpec {
        id: Vec<::rp1::FilterOperator<i32>>,
        title: Vec<::rp1::FilterOperator<String>>,
        subtitle: Vec<::rp1::FilterOperator<Option<String>>>,
        content: Vec<::rp1::FilterOperator<String>>,
        publish_date: Vec<::rp1::FilterOperator<rp1::datetime::Date>>,
        publish_time: Vec<::rp1::FilterOperator<rp1::datetime::Time>>,
        user_id: Vec<::rp1::FilterOperator<i32>>,
        created_at: Vec<::rp1::FilterOperator<rp1::datetime::OffsetDateTime>>,
        updated_at: Vec<::rp1::FilterOperator<rp1::datetime::OffsetDateTime>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for PostFilterSpec {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                PostFilterSpec {
                    id: ref __self_0_0,
                    title: ref __self_0_1,
                    subtitle: ref __self_0_2,
                    content: ref __self_0_3,
                    publish_date: ref __self_0_4,
                    publish_time: ref __self_0_5,
                    user_id: ref __self_0_6,
                    created_at: ref __self_0_7,
                    updated_at: ref __self_0_8,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "PostFilterSpec");
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "id", &&(*__self_0_0));
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "title",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "subtitle",
                        &&(*__self_0_2),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "content",
                        &&(*__self_0_3),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "publish_date",
                        &&(*__self_0_4),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "publish_time",
                        &&(*__self_0_5),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "user_id",
                        &&(*__self_0_6),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "created_at",
                        &&(*__self_0_7),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "updated_at",
                        &&(*__self_0_8),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::rp1::CrudFilterSpec for Post {
        type FilterSpecType = PostFilterSpec;
    }
    impl Default for PostFilterSpec {
        fn default() -> PostFilterSpec {
            PostFilterSpec {
                id: ::alloc::vec::Vec::new(),
                title: ::alloc::vec::Vec::new(),
                subtitle: ::alloc::vec::Vec::new(),
                content: ::alloc::vec::Vec::new(),
                publish_date: ::alloc::vec::Vec::new(),
                publish_time: ::alloc::vec::Vec::new(),
                user_id: ::alloc::vec::Vec::new(),
                created_at: ::alloc::vec::Vec::new(),
                updated_at: ::alloc::vec::Vec::new(),
            }
        }
    }
    #[doc(hidden)]
    pub struct FilterSpecContext<'r> {
        spec: PostFilterSpec,
        errors: ::rocket::form::Errors<'r>,
    }
    impl<'r> FilterSpecContext<'r> {
        fn push(&mut self, mut field_name: rocket::form::name::NameView<'r>, value: &'r str) {
            use std::convert::{TryFrom, TryInto};
            let field_filtered = match field_name.key() {
                Some(k) => k,
                None => {
                    self.errors
                        .push(::rocket::form::error::ErrorKind::Unexpected.into());
                    return;
                }
            };
            field_name.shift();
            let field_operator = field_name.key().map(|k| k.as_str()).unwrap_or("eq");
            match field_filtered.as_str() {
                "id" => match ::rp1::FilterOperator::try_parse(field_operator, value) {
                    Ok(v) => self.spec.id.push(v),
                    Err(e) => self.errors.push(::rp1::ParseError::from(e).into()),
                },
                "title" => match ::rp1::FilterOperator::try_parse(field_operator, value) {
                    Ok(v) => self.spec.title.push(v),
                    Err(e) => self.errors.push(::rp1::ParseError::from(e).into()),
                },
                "subtitle" => {
                    if value == "" {
                        match ::rp1::FilterOperator::from_none(field_operator) {
                            Ok(v) => self.spec.subtitle.push(v),
                            Err(e) => self.errors.push(::rp1::ParseError::from(e).into()),
                        }
                    } else {
                        match ::rp1::FilterOperator::try_parse_option(field_operator, value) {
                            Ok(v) => self.spec.subtitle.push(v),
                            Err(e) => self.errors.push(::rp1::ParseError::from(e).into()),
                        }
                    }
                }
                "content" => match ::rp1::FilterOperator::try_parse(field_operator, value) {
                    Ok(v) => self.spec.content.push(v),
                    Err(e) => self.errors.push(::rp1::ParseError::from(e).into()),
                },
                "publish_date" => match ::rp1::FilterOperator::try_parse(field_operator, value) {
                    Ok(v) => self.spec.publish_date.push(v),
                    Err(e) => self.errors.push(::rp1::ParseError::from(e).into()),
                },
                "publish_time" => match ::rp1::FilterOperator::try_parse(field_operator, value) {
                    Ok(v) => self.spec.publish_time.push(v),
                    Err(e) => self.errors.push(::rp1::ParseError::from(e).into()),
                },
                "user_id" => match ::rp1::FilterOperator::try_parse(field_operator, value) {
                    Ok(v) => self.spec.user_id.push(v),
                    Err(e) => self.errors.push(::rp1::ParseError::from(e).into()),
                },
                "created_at" => match ::rp1::FilterOperator::try_parse(field_operator, value) {
                    Ok(v) => self.spec.created_at.push(v),
                    Err(e) => self.errors.push(::rp1::ParseError::from(e).into()),
                },
                "updated_at" => match ::rp1::FilterOperator::try_parse(field_operator, value) {
                    Ok(v) => self.spec.updated_at.push(v),
                    Err(e) => self.errors.push(::rp1::ParseError::from(e).into()),
                },
                _ => {
                    self.errors
                        .push(::rocket::form::error::ErrorKind::Unexpected.into());
                }
            };
        }
    }
    impl<'r> ::rocket::form::FromForm<'r> for PostFilterSpec {
        type Context = FilterSpecContext<'r>;
        fn init(opts: ::rocket::form::Options) -> Self::Context {
            FilterSpecContext {
                spec: Default::default(),
                errors: ::rocket::form::Errors::new(),
            }
        }
        fn push_value(ctxt: &mut Self::Context, field: ::rocket::form::ValueField<'r>) {
            ctxt.push(field.name, field.value);
        }
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn push_data<'life0, 'life1, 'async_trait>(
            ctxt: &'life0 mut Self::Context,
            field: ::rocket::form::DataField<'r, 'life1>,
        ) -> ::core::pin::Pin<
            Box<dyn ::core::future::Future<Output = ()> + ::core::marker::Send + 'async_trait>,
        >
        where
            'r: 'async_trait,
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                let ctxt = ctxt;
                let field = field;
                let _: () = {
                    use rocket::data::ToByteUnit;
                    let limit = 256.kibibytes();
                    let bytes = match field.data.open(limit).into_bytes().await {
                        Ok(b) => b,
                        Err(e) => {
                            ctxt.errors.push(e.into());
                            return;
                        }
                    };
                    if !bytes.is_complete() {
                        ctxt.errors
                            .push(rocket::form::error::ErrorKind::from((None, Some(limit))).into());
                        return;
                    }
                    let bytes = bytes.into_inner();
                    let bytes = {
                        struct Local<T>(T);
                        &field.request.local_cache(move || Local(bytes)).0
                    };
                    let data = match std::str::from_utf8(bytes) {
                        Ok(d) => d.into(),
                        Err(e) => {
                            ctxt.errors.push(e.into());
                            return;
                        }
                    };
                    ctxt.push(field.name, data);
                };
            })
        }
        fn finalize(ctxt: Self::Context) -> ::rocket::form::Result<'r, Self> {
            if ctxt.errors.is_empty() {
                Ok(ctxt.spec)
            } else {
                Err(ctxt.errors)
            }
        }
    }
    async fn list_fn(
        db: Db,
        sort: Vec<::rp1::SortSpec<SortableFields>>,
        filter: PostFilterSpec,
        offset: Option<i64>,
        limit: Option<i64>,
        auth_user: <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<Vec<Post>> {
        let offset = i64::max(0, offset.unwrap_or(0));
        let limit = i64::max(1, i64::min(100i64, limit.unwrap_or(100i64)));
        let results = db
            .run(move |conn| {
                use ::rp1::SortDirection;
                use ::diesel::expression::Expression;
                let mut query = crate::schema::posts::table
                    .offset(offset)
                    .limit(limit)
                    .into_boxed();
                for sort_spec in sort {
                    match sort_spec.field {
                        SortableFields::id => {
                            query = if sort_spec.direction == SortDirection::Asc {
                                query.then_order_by(crate::schema::posts::columns::id.asc())
                            } else {
                                query.then_order_by(crate::schema::posts::columns::id.desc())
                            };
                        }
                        SortableFields::title => {
                            query = if sort_spec.direction == SortDirection::Asc {
                                query.then_order_by(crate::schema::posts::columns::title.asc())
                            } else {
                                query.then_order_by(crate::schema::posts::columns::title.desc())
                            };
                        }
                        SortableFields::subtitle => {
                            query = if sort_spec.direction == SortDirection::Asc {
                                query.then_order_by(crate::schema::posts::columns::subtitle.asc())
                            } else {
                                query.then_order_by(crate::schema::posts::columns::subtitle.desc())
                            };
                        }
                        SortableFields::content => {
                            query = if sort_spec.direction == SortDirection::Asc {
                                query.then_order_by(crate::schema::posts::columns::content.asc())
                            } else {
                                query.then_order_by(crate::schema::posts::columns::content.desc())
                            };
                        }
                        SortableFields::publish_date => {
                            query = if sort_spec.direction == SortDirection::Asc {
                                query.then_order_by(
                                    crate::schema::posts::columns::publish_date.asc(),
                                )
                            } else {
                                query.then_order_by(
                                    crate::schema::posts::columns::publish_date.desc(),
                                )
                            };
                        }
                        SortableFields::publish_time => {
                            query = if sort_spec.direction == SortDirection::Asc {
                                query.then_order_by(
                                    crate::schema::posts::columns::publish_time.asc(),
                                )
                            } else {
                                query.then_order_by(
                                    crate::schema::posts::columns::publish_time.desc(),
                                )
                            };
                        }
                        SortableFields::user_id => {
                            query = if sort_spec.direction == SortDirection::Asc {
                                query.then_order_by(crate::schema::posts::columns::user_id.asc())
                            } else {
                                query.then_order_by(crate::schema::posts::columns::user_id.desc())
                            };
                        }
                        SortableFields::created_at => {
                            query = if sort_spec.direction == SortDirection::Asc {
                                query.then_order_by(crate::schema::posts::columns::created_at.asc())
                            } else {
                                query
                                    .then_order_by(crate::schema::posts::columns::created_at.desc())
                            };
                        }
                        SortableFields::updated_at => {
                            query = if sort_spec.direction == SortDirection::Asc {
                                query.then_order_by(crate::schema::posts::columns::updated_at.asc())
                            } else {
                                query
                                    .then_order_by(crate::schema::posts::columns::updated_at.desc())
                            };
                        }
                    }
                }
                for op in filter.id.iter() {
                    use ::rp1::FilterOperator;
                    use crate::schema::posts::columns;
                    query = match op {
                        FilterOperator::Eq(val) => query.filter(columns::id.eq(val)),
                        FilterOperator::Ne(val) => query.filter(columns::id.ne(val)),
                        FilterOperator::Gt(val) => query.filter(columns::id.gt(val)),
                        FilterOperator::Ge(val) => query.filter(columns::id.ge(val)),
                        FilterOperator::Lt(val) => query.filter(columns::id.lt(val)),
                        FilterOperator::Le(val) => query.filter(columns::id.le(val)),
                        FilterOperator::EqAny(val) => query.filter(columns::id.eq_any(val)),
                    };
                }
                for op in filter.title.iter() {
                    use ::rp1::FilterOperator;
                    use crate::schema::posts::columns;
                    query = match op {
                        FilterOperator::Eq(val) => query.filter(columns::title.eq(val)),
                        FilterOperator::Ne(val) => query.filter(columns::title.ne(val)),
                        FilterOperator::Gt(val) => query.filter(columns::title.gt(val)),
                        FilterOperator::Ge(val) => query.filter(columns::title.ge(val)),
                        FilterOperator::Lt(val) => query.filter(columns::title.lt(val)),
                        FilterOperator::Le(val) => query.filter(columns::title.le(val)),
                        FilterOperator::EqAny(val) => query.filter(columns::title.eq_any(val)),
                    };
                }
                for op in filter.subtitle.iter() {
                    use ::rp1::FilterOperator;
                    use crate::schema::posts::columns;
                    query = match op {
                        FilterOperator::Eq(val) => query.filter(columns::subtitle.eq(val)),
                        FilterOperator::Ne(val) => query.filter(columns::subtitle.ne(val)),
                        FilterOperator::Gt(val) => query.filter(columns::subtitle.gt(val)),
                        FilterOperator::Ge(val) => query.filter(columns::subtitle.ge(val)),
                        FilterOperator::Lt(val) => query.filter(columns::subtitle.lt(val)),
                        FilterOperator::Le(val) => query.filter(columns::subtitle.le(val)),
                        FilterOperator::EqAny(val) => query.filter(columns::subtitle.eq_any(val)),
                    };
                }
                for op in filter.content.iter() {
                    use ::rp1::FilterOperator;
                    use crate::schema::posts::columns;
                    query = match op {
                        FilterOperator::Eq(val) => query.filter(columns::content.eq(val)),
                        FilterOperator::Ne(val) => query.filter(columns::content.ne(val)),
                        FilterOperator::Gt(val) => query.filter(columns::content.gt(val)),
                        FilterOperator::Ge(val) => query.filter(columns::content.ge(val)),
                        FilterOperator::Lt(val) => query.filter(columns::content.lt(val)),
                        FilterOperator::Le(val) => query.filter(columns::content.le(val)),
                        FilterOperator::EqAny(val) => query.filter(columns::content.eq_any(val)),
                    };
                }
                for op in filter.publish_date.iter() {
                    use ::rp1::FilterOperator;
                    use crate::schema::posts::columns;
                    query = match op {
                        FilterOperator::Eq(val) => query.filter(columns::publish_date.eq(val)),
                        FilterOperator::Ne(val) => query.filter(columns::publish_date.ne(val)),
                        FilterOperator::Gt(val) => query.filter(columns::publish_date.gt(val)),
                        FilterOperator::Ge(val) => query.filter(columns::publish_date.ge(val)),
                        FilterOperator::Lt(val) => query.filter(columns::publish_date.lt(val)),
                        FilterOperator::Le(val) => query.filter(columns::publish_date.le(val)),
                        FilterOperator::EqAny(val) => {
                            query.filter(columns::publish_date.eq_any(val))
                        }
                    };
                }
                for op in filter.publish_time.iter() {
                    use ::rp1::FilterOperator;
                    use crate::schema::posts::columns;
                    query = match op {
                        FilterOperator::Eq(val) => query.filter(columns::publish_time.eq(val)),
                        FilterOperator::Ne(val) => query.filter(columns::publish_time.ne(val)),
                        FilterOperator::Gt(val) => query.filter(columns::publish_time.gt(val)),
                        FilterOperator::Ge(val) => query.filter(columns::publish_time.ge(val)),
                        FilterOperator::Lt(val) => query.filter(columns::publish_time.lt(val)),
                        FilterOperator::Le(val) => query.filter(columns::publish_time.le(val)),
                        FilterOperator::EqAny(val) => {
                            query.filter(columns::publish_time.eq_any(val))
                        }
                    };
                }
                for op in filter.user_id.iter() {
                    use ::rp1::FilterOperator;
                    use crate::schema::posts::columns;
                    query = match op {
                        FilterOperator::Eq(val) => query.filter(columns::user_id.eq(val)),
                        FilterOperator::Ne(val) => query.filter(columns::user_id.ne(val)),
                        FilterOperator::Gt(val) => query.filter(columns::user_id.gt(val)),
                        FilterOperator::Ge(val) => query.filter(columns::user_id.ge(val)),
                        FilterOperator::Lt(val) => query.filter(columns::user_id.lt(val)),
                        FilterOperator::Le(val) => query.filter(columns::user_id.le(val)),
                        FilterOperator::EqAny(val) => query.filter(columns::user_id.eq_any(val)),
                    };
                }
                for op in filter.created_at.iter() {
                    use ::rp1::FilterOperator;
                    use crate::schema::posts::columns;
                    query = match op {
                        FilterOperator::Eq(val) => query.filter(columns::created_at.eq(val)),
                        FilterOperator::Ne(val) => query.filter(columns::created_at.ne(val)),
                        FilterOperator::Gt(val) => query.filter(columns::created_at.gt(val)),
                        FilterOperator::Ge(val) => query.filter(columns::created_at.ge(val)),
                        FilterOperator::Lt(val) => query.filter(columns::created_at.lt(val)),
                        FilterOperator::Le(val) => query.filter(columns::created_at.le(val)),
                        FilterOperator::EqAny(val) => query.filter(columns::created_at.eq_any(val)),
                    };
                }
                for op in filter.updated_at.iter() {
                    use ::rp1::FilterOperator;
                    use crate::schema::posts::columns;
                    query = match op {
                        FilterOperator::Eq(val) => query.filter(columns::updated_at.eq(val)),
                        FilterOperator::Ne(val) => query.filter(columns::updated_at.ne(val)),
                        FilterOperator::Gt(val) => query.filter(columns::updated_at.gt(val)),
                        FilterOperator::Ge(val) => query.filter(columns::updated_at.ge(val)),
                        FilterOperator::Lt(val) => query.filter(columns::updated_at.lt(val)),
                        FilterOperator::Le(val) => query.filter(columns::updated_at.le(val)),
                        FilterOperator::EqAny(val) => query.filter(columns::updated_at.eq_any(val)),
                    };
                }
                let filter = <Post as ::rp1::CheckPermissions>::filter_list(&auth_user);
                let query = filter.apply(query);
                query.map(|q| q.load(conn))
            })
            .await
            .ok_or_else(|| ::rp1::CrudError::Forbidden)??;
        Ok(::rocket::serde::json::Json(results))
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct list_fn {}
    /// Rocket code generated proxy static conversion implementations.
    impl list_fn {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::post",
                                                "example/src/main.rs",
                                                53u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::post",
                                                "example/src/main.rs",
                                                53u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< Post as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::post" , "example/src/main.rs" , 53u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let mut __e = ::rocket::form::prelude::Errors::new();
                    let mut __rocket_sort =
                        <Vec<::rp1::SortSpec<SortableFields>> as ::rocket::form::FromForm>::init(
                            ::rocket::form::prelude::Options::Lenient,
                        );
                    let mut __rocket_offset = <Option<i64> as ::rocket::form::FromForm>::init(
                        ::rocket::form::prelude::Options::Lenient,
                    );
                    let mut __rocket_limit = <Option<i64> as ::rocket::form::FromForm>::init(
                        ::rocket::form::prelude::Options::Lenient,
                    );
                    let mut __rocket_filter = <PostFilterSpec as ::rocket::form::FromForm>::init(
                        ::rocket::form::prelude::Options::Lenient,
                    );
                    for _f in __req.query_fields() {
                        let _raw = (_f.name.source().as_str(), _f.value);
                        let _key = _f.name.key_lossy().as_str();
                        match (_raw , _key) { (_ , "sort") => < Vec < :: rp1 :: SortSpec < SortableFields > > as :: rocket :: form :: FromForm > :: push_value (& mut __rocket_sort , _f . shift ()) , (_ , "offset") => < Option < i64 > as :: rocket :: form :: FromForm > :: push_value (& mut __rocket_offset , _f . shift ()) , (_ , "limit") => < Option < i64 > as :: rocket :: form :: FromForm > :: push_value (& mut __rocket_limit , _f . shift ()) , (_ , "filter") => < PostFilterSpec as :: rocket :: form :: FromForm > :: push_value (& mut __rocket_filter , _f . shift ()) , _ => { } }
                    }
                    let __rocket_sort = match < Vec < :: rp1 :: SortSpec < SortableFields > > as :: rocket :: form :: FromForm > :: finalize (__rocket_sort) { :: std :: result :: Result :: Ok (_v) => :: std :: option :: Option :: Some (_v) , :: std :: result :: Result :: Err (_err) => { __e . extend (_err . with_name (:: rocket :: form :: prelude :: NameView :: new ("sort"))) ; :: std :: option :: Option :: None } } ;
                    let __rocket_offset = match <Option<i64> as ::rocket::form::FromForm>::finalize(
                        __rocket_offset,
                    ) {
                        ::std::result::Result::Ok(_v) => ::std::option::Option::Some(_v),
                        ::std::result::Result::Err(_err) => {
                            __e.extend(
                                _err.with_name(::rocket::form::prelude::NameView::new("offset")),
                            );
                            ::std::option::Option::None
                        }
                    };
                    let __rocket_limit =
                        match <Option<i64> as ::rocket::form::FromForm>::finalize(__rocket_limit) {
                            ::std::result::Result::Ok(_v) => ::std::option::Option::Some(_v),
                            ::std::result::Result::Err(_err) => {
                                __e.extend(
                                    _err.with_name(::rocket::form::prelude::NameView::new("limit")),
                                );
                                ::std::option::Option::None
                            }
                        };
                    let __rocket_filter =
                        match <PostFilterSpec as ::rocket::form::FromForm>::finalize(
                            __rocket_filter,
                        ) {
                            ::std::result::Result::Ok(_v) => ::std::option::Option::Some(_v),
                            ::std::result::Result::Err(_err) => {
                                __e.extend(
                                    _err.with_name(::rocket::form::prelude::NameView::new(
                                        "filter",
                                    )),
                                );
                                ::std::option::Option::None
                            }
                        };
                    if !__e.is_empty() {
                        {
                            let lvl = ::log::Level::Warn;
                            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                ::log::__private_api_log(
                                    ::core::fmt::Arguments::new_v1(
                                        &["query string failed to match declared route"],
                                        &match () {
                                            () => [],
                                        },
                                    ),
                                    lvl,
                                    &("_", "rp1_example::post", "example/src/main.rs", 53u32),
                                );
                            }
                        };
                        for _err in __e {
                            {
                                let lvl = ::log::Level::Warn;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &[""],
                                            &match (&_err,) {
                                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                                    arg0,
                                                    ::core::fmt::Display::fmt,
                                                )],
                                            },
                                        ),
                                        lvl,
                                        &("_", "rp1_example::post", "example/src/main.rs", 53u32),
                                    );
                                }
                            };
                        }
                        return ::rocket::outcome::Outcome::Forward(__data);
                    }
                    let __rocket_sort = __rocket_sort.unwrap();
                    let __rocket_offset = __rocket_offset.unwrap();
                    let __rocket_limit = __rocket_limit.unwrap();
                    let __rocket_filter = __rocket_filter.unwrap();
                    let ___responder = list_fn(
                        __rocket_db,
                        __rocket_sort,
                        __rocket_filter,
                        __rocket_offset,
                        __rocket_limit,
                        __rocket_auth_user,
                    )
                    .await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "list_fn",
                method: ::rocket::http::Method::Get,
                uri: "/?<sort>&<offset>&<limit>&<filter>",
                handler: monomorphized_function,
                format: ::std::option::Option::None,
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Vec<::rp1::SortSpec<SortableFields>>>(),
                            type_name: std::any::type_name::<Vec<::rp1::SortSpec<SortableFields>>>(
                            ),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized:
                                Resolve::<Vec<::rp1::SortSpec<SortableFields>>>::SPECIALIZED,
                            abort: Resolve::<Vec<::rp1::SortSpec<SortableFields>>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::SortSpec<SortableFields>>(),
                            type_name: std::any::type_name::<::rp1::SortSpec<SortableFields>>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                Vec<::rp1::SortSpec<SortableFields>>,
                            >())),
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized: Resolve::<::rp1::SortSpec<SortableFields>>::SPECIALIZED,
                            abort: Resolve::<::rp1::SortSpec<SortableFields>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<SortableFields>(),
                            type_name: std::any::type_name::<SortableFields>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                ::rp1::SortSpec<SortableFields>,
                            >())),
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized: Resolve::<SortableFields>::SPECIALIZED,
                            abort: Resolve::<SortableFields>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Option<i64>>(),
                            type_name: std::any::type_name::<Option<i64>>(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized: Resolve::<Option<i64>>::SPECIALIZED,
                            abort: Resolve::<Option<i64>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<i64>(),
                            type_name: std::any::type_name::<i64>(),
                            parent: None.or(Some(std::any::TypeId::of::<Option<i64>>())),
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized: Resolve::<i64>::SPECIALIZED,
                            abort: Resolve::<i64>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Option<i64>>(),
                            type_name: std::any::type_name::<Option<i64>>(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized: Resolve::<Option<i64>>::SPECIALIZED,
                            abort: Resolve::<Option<i64>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<i64>(),
                            type_name: std::any::type_name::<i64>(),
                            parent: None.or(Some(std::any::TypeId::of::<Option<i64>>())),
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized: Resolve::<i64>::SPECIALIZED,
                            abort: Resolve::<i64>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<PostFilterSpec>(),
                            type_name: std::any::type_name::<PostFilterSpec>(),
                            parent: None,
                            location: ("example/src/main.rs", 54u32, 8u32),
                            specialized: Resolve::<PostFilterSpec>::SPECIALIZED,
                            abort: Resolve::<PostFilterSpec>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized: Resolve::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Post>(),
                            type_name: std::any::type_name::<Post>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <Post as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 54u32, 8u32),
                            specialized: Resolve::<Post>::SPECIALIZED,
                            abort: Resolve::<Post>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::CrudJsonResult<Vec<Post>>>(),
                            type_name: std::any::type_name::<::rp1::CrudJsonResult<Vec<Post>>>(),
                            parent: None,
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized: Resolve::<::rp1::CrudJsonResult<Vec<Post>>>::SPECIALIZED,
                            abort: Resolve::<::rp1::CrudJsonResult<Vec<Post>>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Vec<Post>>(),
                            type_name: std::any::type_name::<Vec<Post>>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                ::rp1::CrudJsonResult<Vec<Post>>,
                            >())),
                            location: ("example/src/main.rs", 53u32, 1u32),
                            specialized: Resolve::<Vec<Post>>::SPECIALIZED,
                            abort: Resolve::<Vec<Post>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Post>(),
                            type_name: std::any::type_name::<Post>(),
                            parent: None.or(Some(std::any::TypeId::of::<Vec<Post>>())),
                            location: ("example/src/main.rs", 54u32, 8u32),
                            specialized: Resolve::<Post>::SPECIALIZED,
                            abort: Resolve::<Post>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_list_fn_11505824499617826374 as rocket_uri_macro_list_fn;
    impl Post {
        pub fn get_routes() -> Vec<::rocket::Route> {
            {
                let ___vec: ::std::vec::Vec<::rocket::Route> = <[_]>::into_vec(box [
                    {
                        let ___struct = create_fn_form {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                    {
                        let ___struct = create_fn_json {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                    {
                        let ___struct = read_fn {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                    {
                        let ___struct = update_patch_fn_json {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                    {
                        let ___struct = update_patch_fn_form {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                    {
                        let ___struct = update_put_fn_json {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                    {
                        let ___struct = update_put_fn_form {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                    {
                        let ___struct = delete_fn {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                    {
                        let ___struct = list_fn {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                ]);
                ___vec
            }
        }
    }
    impl ::rp1::CrudStruct for Post {
        type TableType = crate::schema::posts::table;
    }
}
use self::post::Post;
mod comment {
    use super::*;
    use diesel::prelude::*;
    use crate::schema::comments;
    pub struct Comment {
        id: i32,
        content: String,
        #[serde(default)]
        approved: bool,
        post_id: i32,
        user_id: Option<i32>,
        anonymous_user: Option<String>,
        created_at: rp1::datetime::OffsetDateTime,
        updated_at: rp1::datetime::OffsetDateTime,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Comment {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Comment",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "content",
                    &self.content,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "approved",
                    &self.approved,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "post_id",
                    &self.post_id,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "user_id",
                    &self.user_id,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "anonymous_user",
                    &self.anonymous_user,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "created_at",
                    &self.created_at,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "updated_at",
                    &self.updated_at,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[allow(non_snake_case, unused_extern_crates, unused_imports)]
    fn _impl_queryable_for_comment() {
        extern crate std;
        use diesel;
        use diesel::Queryable;
        impl<__DB: diesel::backend::Backend, __ST> Queryable<__ST, __DB> for Comment
        where
            (
                i32,
                String,
                bool,
                i32,
                Option<i32>,
                Option<String>,
                rp1::datetime::OffsetDateTime,
                rp1::datetime::OffsetDateTime,
            ): Queryable<__ST, __DB>,
        {
            type Row = <(
                i32,
                String,
                bool,
                i32,
                Option<i32>,
                Option<String>,
                rp1::datetime::OffsetDateTime,
                rp1::datetime::OffsetDateTime,
            ) as Queryable<__ST, __DB>>::Row;
            fn build(row: Self::Row) -> Self {
                let row: (
                    i32,
                    String,
                    bool,
                    i32,
                    Option<i32>,
                    Option<String>,
                    rp1::datetime::OffsetDateTime,
                    rp1::datetime::OffsetDateTime,
                ) = Queryable::build(row);
                Self {
                    id: (row.0.into()),
                    content: (row.1.into()),
                    approved: (row.2.into()),
                    post_id: (row.3.into()),
                    user_id: (row.4.into()),
                    anonymous_user: (row.5.into()),
                    created_at: (row.6.into()),
                    updated_at: (row.7.into()),
                }
            }
        }
    }
    impl ::validator::Validate for Comment {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_args(())
        }
    }
    #[allow(clippy::all)]
    impl<'v_a> ::validator::ValidateArgs<'v_a> for Comment {
        type Args = ();
        #[allow(unused_mut)]
        #[allow(unused_variable)]
        fn validate_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            let mut errors = ::validator::ValidationErrors::new();
            let mut result = if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            };
            result
        }
    }
    #[table_name = "comments"]
    pub struct NewComment {
        content: String,
        #[serde(default)]
        approved: bool,
        post_id: i32,
        user_id: Option<i32>,
        anonymous_user: Option<String>,
    }
    impl ::validator::Validate for NewComment {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_args(())
        }
    }
    #[allow(clippy::all)]
    impl<'v_a> ::validator::ValidateArgs<'v_a> for NewComment {
        type Args = ();
        #[allow(unused_mut)]
        #[allow(unused_variable)]
        fn validate_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            let mut errors = ::validator::ValidationErrors::new();
            let mut result = if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            };
            result
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for NewComment {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "content" => _serde::__private::Ok(__Field::__field0),
                            "approved" => _serde::__private::Ok(__Field::__field1),
                            "post_id" => _serde::__private::Ok(__Field::__field2),
                            "user_id" => _serde::__private::Ok(__Field::__field3),
                            "anonymous_user" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"content" => _serde::__private::Ok(__Field::__field0),
                            b"approved" => _serde::__private::Ok(__Field::__field1),
                            b"post_id" => _serde::__private::Ok(__Field::__field2),
                            b"user_id" => _serde::__private::Ok(__Field::__field3),
                            b"anonymous_user" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<NewComment>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = NewComment;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct NewComment")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct NewComment with 5 elements",
                                        ),
                                    );
                                }
                            };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<bool>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => _serde::__private::Default::default(),
                            };
                        let __field2 =
                            match match _serde::de::SeqAccess::next_element::<i32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct NewComment with 5 elements",
                                        ),
                                    );
                                }
                            };
                        let __field3 = match match _serde::de::SeqAccess::next_element::<Option<i32>>(
                            &mut __seq,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct NewComment with 5 elements",
                                ));
                            }
                        };
                        let __field4 = match match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct NewComment with 5 elements",
                                ));
                            }
                        };
                        _serde::__private::Ok(NewComment {
                            content: __field0,
                            approved: __field1,
                            post_id: __field2,
                            user_id: __field3,
                            anonymous_user: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<i32> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Option<i32>> =
                            _serde::__private::None;
                        let mut __field4: _serde::__private::Option<Option<String>> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "content",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<String>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "approved",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<bool>(&mut __map)
                                        {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "post_id",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<i32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "user_id",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Option<i32>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "anonymous_user",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Option<String>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("content") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => _serde::__private::Default::default(),
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("post_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("user_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("anonymous_user") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(NewComment {
                            content: __field0,
                            approved: __field1,
                            post_id: __field2,
                            user_id: __field3,
                            anonymous_user: __field4,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &[
                    "content",
                    "approved",
                    "post_id",
                    "user_id",
                    "anonymous_user",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "NewComment",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<NewComment>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_snake_case)]
    const _: () = { # [doc = r" Rocket generated FormForm context."] # [doc (hidden)] pub struct FromFormGeneratedContext < '__f > { __opts : :: rocket :: form :: prelude :: Options , __errors : :: rocket :: form :: prelude :: Errors < '__f > , __parent : :: std :: option :: Option < & '__f :: rocket :: form :: prelude :: Name > , content : :: std :: option :: Option < < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , approved : :: std :: option :: Option < < bool as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , post_id : :: std :: option :: Option < < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , user_id : :: std :: option :: Option < < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , anonymous_user : :: std :: option :: Option < < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , } # [allow (unused_imports)] use :: rocket :: http :: uncased :: AsUncased ; impl < '__f > :: rocket :: form :: prelude :: FromForm < '__f > for NewComment { type Context = FromFormGeneratedContext < '__f > ; fn init (__opts : :: rocket :: form :: prelude :: Options) -> Self :: Context { Self :: Context { __opts , __errors : :: rocket :: form :: prelude :: Errors :: new () , __parent : :: std :: option :: Option :: None , content : :: std :: option :: Option :: None , approved : :: std :: option :: Option :: None , post_id : :: std :: option :: Option :: None , user_id : :: std :: option :: Option :: None , anonymous_user : :: std :: option :: Option :: None , } } fn push_value (__c : & mut Self :: Context , __f : :: rocket :: form :: prelude :: ValueField < '__f >) { __c . __parent = __f . name . parent () ; match __f . name . key_lossy () . as_str () { "content" => { { < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . content . get_or_insert_with (| | < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "approved" => { { < bool as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . approved . get_or_insert_with (| | < bool as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "post_id" => { { < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . post_id . get_or_insert_with (| | < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "user_id" => { { < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . user_id . get_or_insert_with (| | < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "anonymous_user" => { { < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . anonymous_user . get_or_insert_with (| | < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } __k if __k == "_method" || ! __c . __opts . strict => { } _ => __c . __errors . push (__f . unexpected ()) , } } # [allow (clippy :: let_unit_value , clippy :: type_complexity , clippy :: type_repetition_in_bounds , clippy :: used_underscore_binding)] fn push_data < 'life0 , 'life1 , 'async_trait > (__c : & 'life0 mut FromFormGeneratedContext < '__f > , __f : :: rocket :: form :: prelude :: DataField < '__f , 'life1 >) -> :: core :: pin :: Pin < Box < dyn :: core :: future :: Future < Output = () > + :: core :: marker :: Send + 'async_trait > > where '__f : 'async_trait , 'life0 : 'async_trait , 'life1 : 'async_trait { Box :: pin (async move { let __c = __c ; let __f = __f ; let _ : () = { __c . __parent = __f . name . parent () ; match __f . name . key_lossy () . as_str () { "content" => { { let _fut = < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . content . get_or_insert_with (| | < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "approved" => { { let _fut = < bool as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . approved . get_or_insert_with (| | < bool as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "post_id" => { { let _fut = < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . post_id . get_or_insert_with (| | < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "user_id" => { { let _fut = < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . user_id . get_or_insert_with (| | < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "anonymous_user" => { { let _fut = < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . anonymous_user . get_or_insert_with (| | < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } __k if __k == "_method" || ! __c . __opts . strict => { } _ => __c . __errors . push (__f . unexpected ()) , } } ; }) } fn finalize (mut __c : Self :: Context) -> :: std :: result :: Result < Self , :: rocket :: form :: prelude :: Errors < '__f > > { # [allow (unused_imports)] use :: rocket :: form :: prelude :: validate :: * ; let content = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "content")) ; let __opts = __c . __opts ; __c . content . map_or_else (| | { < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| content | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | content) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (content) => :: std :: option :: Option :: Some (content) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let approved = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "approved")) ; let __opts = __c . __opts ; __c . approved . map_or_else (| | { < bool as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < bool as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| approved | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | approved) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (approved) => :: std :: option :: Option :: Some (approved) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let post_id = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "post_id")) ; let __opts = __c . __opts ; __c . post_id . map_or_else (| | { < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| post_id | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | post_id) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (post_id) => :: std :: option :: Option :: Some (post_id) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let user_id = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "user_id")) ; let __opts = __c . __opts ; __c . user_id . map_or_else (| | { < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| user_id | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | user_id) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (user_id) => :: std :: option :: Option :: Some (user_id) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let anonymous_user = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "anonymous_user")) ; let __opts = __c . __opts ; __c . anonymous_user . map_or_else (| | { < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| anonymous_user | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | anonymous_user) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (anonymous_user) => :: std :: option :: Option :: Some (anonymous_user) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; if ! __c . __errors . is_empty () { return :: std :: result :: Result :: Err (__c . __errors) ; } let __o = Self { content : content . unwrap () , approved : approved . unwrap () , post_id : post_id . unwrap () , user_id : user_id . unwrap () , anonymous_user : anonymous_user . unwrap () , } ; if ! __c . __errors . is_empty () { return :: std :: result :: Result :: Err (__c . __errors) ; } Ok (__o) } } };
    #[allow(non_snake_case, unused_extern_crates, unused_imports)]
    fn _impl_queryable_for_newcomment() {
        extern crate std;
        use diesel;
        use diesel::Queryable;
        impl<__DB: diesel::backend::Backend, __ST> Queryable<__ST, __DB> for NewComment
        where
            (String, bool, i32, Option<i32>, Option<String>): Queryable<__ST, __DB>,
        {
            type Row =
                <(String, bool, i32, Option<i32>, Option<String>) as Queryable<__ST, __DB>>::Row;
            fn build(row: Self::Row) -> Self {
                let row: (String, bool, i32, Option<i32>, Option<String>) = Queryable::build(row);
                Self {
                    content: (row.0.into()),
                    approved: (row.1.into()),
                    post_id: (row.2.into()),
                    user_id: (row.3.into()),
                    anonymous_user: (row.4.into()),
                }
            }
        }
    }
    #[allow(non_snake_case, unused_extern_crates, unused_imports)]
    fn _impl_insertable_for_newcomment() {
        extern crate std;
        use diesel;
        use diesel::insertable::Insertable;
        use diesel::query_builder::UndecoratedInsertRecord;
        use diesel::prelude::*;
        impl<'insert> Insertable<comments::table> for NewComment {
            type Values = <(
                std::option::Option<diesel::dsl::Eq<comments::content, String>>,
                std::option::Option<diesel::dsl::Eq<comments::approved, bool>>,
                std::option::Option<diesel::dsl::Eq<comments::post_id, i32>>,
                std::option::Option<diesel::dsl::Eq<comments::user_id, i32>>,
                std::option::Option<diesel::dsl::Eq<comments::anonymous_user, String>>,
            ) as Insertable<comments::table>>::Values;
            fn values(self) -> Self::Values {
                (
                    std::option::Option::Some(comments::content.eq(self.content)),
                    std::option::Option::Some(comments::approved.eq(self.approved)),
                    std::option::Option::Some(comments::post_id.eq(self.post_id)),
                    self.user_id.map(|x| comments::user_id.eq(x)),
                    self.anonymous_user.map(|x| comments::anonymous_user.eq(x)),
                )
                    .values()
            }
        }
        impl<'insert> Insertable<comments::table> for &'insert NewComment {
            type Values = <(
                std::option::Option<diesel::dsl::Eq<comments::content, &'insert String>>,
                std::option::Option<diesel::dsl::Eq<comments::approved, &'insert bool>>,
                std::option::Option<diesel::dsl::Eq<comments::post_id, &'insert i32>>,
                std::option::Option<diesel::dsl::Eq<comments::user_id, &'insert i32>>,
                std::option::Option<diesel::dsl::Eq<comments::anonymous_user, &'insert String>>,
            ) as Insertable<comments::table>>::Values;
            fn values(self) -> Self::Values {
                (
                    std::option::Option::Some(comments::content.eq(&self.content)),
                    std::option::Option::Some(comments::approved.eq(&self.approved)),
                    std::option::Option::Some(comments::post_id.eq(&self.post_id)),
                    self.user_id.as_ref().map(|x| comments::user_id.eq(x)),
                    self.anonymous_user
                        .as_ref()
                        .map(|x| comments::anonymous_user.eq(x)),
                )
                    .values()
            }
        }
        impl<'insert> UndecoratedInsertRecord<comments::table> for NewComment {}
    }
    impl ::rp1::CrudInsertable for Comment {
        type InsertType = NewComment;
    }
    async fn create_fn_help(
        db: Db,
        value: NewComment,
        auth_user: <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<Comment> {
        if !<Comment as ::rp1::CheckPermissions>::allow_create(&value, &auth_user) {
            return Err(::rp1::CrudError::Forbidden);
        }
        use ::validator::Validate;
        value.validate()?;
        Ok(::rocket::serde::json::Json(
            db.run(move |conn| {
                diesel::insert_into(crate::schema::comments::table)
                    .values(&value)
                    .get_result(conn)
            })
            .await?,
        ))
    }
    async fn create_fn_json(
        db: Db,
        value: ::rocket::serde::json::Json<NewComment>,
        auth_user: <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<Comment> {
        let value = value.into_inner();
        create_fn_help(db, value, auth_user).await
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct create_fn_json {}
    /// Rocket code generated proxy static conversion implementations.
    impl create_fn_json {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::comment",
                                                "example/src/main.rs",
                                                69u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::comment",
                                                "example/src/main.rs",
                                                69u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let __rocket_value : :: rocket :: serde :: json :: Json < NewComment > = match < :: rocket :: serde :: json :: Json < NewComment > as :: rocket :: data :: FromData > :: from_data (__req , __data) . await { :: rocket :: outcome :: Outcome :: Success (__d) => __d , :: rocket :: outcome :: Outcome :: Forward (__d) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard is forwarding."] , & match (& ":: rocket :: serde :: json :: Json < NewComment >" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__d) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard failed: " , "."] , & match (& ":: rocket :: serde :: json :: Json < NewComment >" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let ___responder =
                        create_fn_json(__rocket_db, __rocket_value, __rocket_auth_user).await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "create_fn_json",
                method: ::rocket::http::Method::Post,
                uri: "/",
                handler: monomorphized_function,
                format: ::std::option::Option::Some(::rocket::http::MediaType::const_new(
                    "application",
                    "json",
                    &[],
                )),
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized: Resolve::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Comment>(),
                            type_name: std::any::type_name::<Comment>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 70u32, 8u32),
                            specialized: Resolve::<Comment>::SPECIALIZED,
                            abort: Resolve::<Comment>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::CrudJsonResult<Comment>>(),
                            type_name: std::any::type_name::<::rp1::CrudJsonResult<Comment>>(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized: Resolve::<::rp1::CrudJsonResult<Comment>>::SPECIALIZED,
                            abort: Resolve::<::rp1::CrudJsonResult<Comment>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Comment>(),
                            type_name: std::any::type_name::<Comment>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                ::rp1::CrudJsonResult<Comment>,
                            >())),
                            location: ("example/src/main.rs", 70u32, 8u32),
                            specialized: Resolve::<Comment>::SPECIALIZED,
                            abort: Resolve::<Comment>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_create_fn_json_16831171753656062303 as rocket_uri_macro_create_fn_json;
    async fn create_fn_form(
        db: Db,
        value: ::rocket::form::Form<NewComment>,
        auth_user: <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<Comment> {
        let value = value.into_inner();
        create_fn_help(db, value, auth_user).await
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct create_fn_form {}
    /// Rocket code generated proxy static conversion implementations.
    impl create_fn_form {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::comment",
                                                "example/src/main.rs",
                                                69u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::comment",
                                                "example/src/main.rs",
                                                69u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let __rocket_value : :: rocket :: form :: Form < NewComment > = match < :: rocket :: form :: Form < NewComment > as :: rocket :: data :: FromData > :: from_data (__req , __data) . await { :: rocket :: outcome :: Outcome :: Success (__d) => __d , :: rocket :: outcome :: Outcome :: Forward (__d) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard is forwarding."] , & match (& ":: rocket :: form :: Form < NewComment >" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__d) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard failed: " , "."] , & match (& ":: rocket :: form :: Form < NewComment >" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let ___responder =
                        create_fn_form(__rocket_db, __rocket_value, __rocket_auth_user).await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "create_fn_form",
                method: ::rocket::http::Method::Post,
                uri: "/",
                handler: monomorphized_function,
                format: ::std::option::Option::Some(::rocket::http::MediaType::const_new(
                    "application",
                    "x-www-form-urlencoded",
                    &[],
                )),
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized: Resolve::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Comment>(),
                            type_name: std::any::type_name::<Comment>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 70u32, 8u32),
                            specialized: Resolve::<Comment>::SPECIALIZED,
                            abort: Resolve::<Comment>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::CrudJsonResult<Comment>>(),
                            type_name: std::any::type_name::<::rp1::CrudJsonResult<Comment>>(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized: Resolve::<::rp1::CrudJsonResult<Comment>>::SPECIALIZED,
                            abort: Resolve::<::rp1::CrudJsonResult<Comment>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Comment>(),
                            type_name: std::any::type_name::<Comment>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                ::rp1::CrudJsonResult<Comment>,
                            >())),
                            location: ("example/src/main.rs", 70u32, 8u32),
                            specialized: Resolve::<Comment>::SPECIALIZED,
                            abort: Resolve::<Comment>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_create_fn_form_9133966715285017500 as rocket_uri_macro_create_fn_form;
    async fn read_fn(
        db: Db,
        id: i32,
        auth_user: <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<Comment> {
        let row = db
            .run(move |conn| {
                crate::schema::comments::table
                    .find(id)
                    .first::<Comment>(conn)
            })
            .await?;
        let row = if <Comment as ::rp1::CheckPermissions>::allow_read(&row, &auth_user) {
            row
        } else {
            return Err(::rp1::CrudError::NotFound);
        };
        Ok(::rocket::serde::json::Json(row))
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct read_fn {}
    /// Rocket code generated proxy static conversion implementations.
    impl read_fn {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::comment",
                                                "example/src/main.rs",
                                                69u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::comment",
                                                "example/src/main.rs",
                                                69u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let __rocket_id: i32 = match __req.routed_segment(0usize) {
                        ::std::option::Option::Some(__s) => {
                            match <i32 as ::rocket::request::FromParam>::from_param(__s) {
                                ::std::result::Result::Ok(__v) => __v,
                                ::std::result::Result::Err(__error) => {
                                    return {
                                        {
                                            let lvl = ::log::Level::Warn;
                                            if lvl <= ::log::STATIC_MAX_LEVEL
                                                && lvl <= ::log::max_level()
                                            {
                                                :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , ": " , "` param guard parsed forwarding with error "] , & match (& "id" , & "i32" , & __error) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ;
                                            }
                                        };
                                        ::rocket::outcome::Outcome::Forward(__data)
                                    }
                                }
                            }
                        }
                        ::std::option::Option::None => {
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Internal invariant broken: dyn param not found."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &(
                                            "_",
                                            "rp1_example::comment",
                                            "example/src/main.rs",
                                            72u32,
                                        ),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Please report this to the Rocket issue tracker."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &(
                                            "_",
                                            "rp1_example::comment",
                                            "example/src/main.rs",
                                            72u32,
                                        ),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["https://github.com/SergioBenitez/Rocket/issues"],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &(
                                            "_",
                                            "rp1_example::comment",
                                            "example/src/main.rs",
                                            72u32,
                                        ),
                                    );
                                }
                            };
                            return ::rocket::outcome::Outcome::Forward(__data);
                        }
                    };
                    let ___responder = read_fn(__rocket_db, __rocket_id, __rocket_auth_user).await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "read_fn",
                method: ::rocket::http::Method::Get,
                uri: "/<id>",
                handler: monomorphized_function,
                format: ::std::option::Option::None,
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<i32>(),
                            type_name: std::any::type_name::<i32>(),
                            parent: None,
                            location: ("example/src/main.rs", 72u32, 9u32),
                            specialized: Resolve::<i32>::SPECIALIZED,
                            abort: Resolve::<i32>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized: Resolve::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Comment>(),
                            type_name: std::any::type_name::<Comment>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 70u32, 8u32),
                            specialized: Resolve::<Comment>::SPECIALIZED,
                            abort: Resolve::<Comment>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::CrudJsonResult<Comment>>(),
                            type_name: std::any::type_name::<::rp1::CrudJsonResult<Comment>>(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized: Resolve::<::rp1::CrudJsonResult<Comment>>::SPECIALIZED,
                            abort: Resolve::<::rp1::CrudJsonResult<Comment>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Comment>(),
                            type_name: std::any::type_name::<Comment>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                ::rp1::CrudJsonResult<Comment>,
                            >())),
                            location: ("example/src/main.rs", 70u32, 8u32),
                            specialized: Resolve::<Comment>::SPECIALIZED,
                            abort: Resolve::<Comment>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_read_fn_9380204364092856823 as rocket_uri_macro_read_fn;
    #[table_name = "comments"]
    pub struct UpdatePatchComment {
        content: Option<String>,
        #[serde(default)]
        approved: Option<bool>,
        post_id: Option<i32>,
        #[serde(default, deserialize_with = "::rp1::helper::double_option")]
        user_id: Option<Option<i32>>,
        #[serde(default, deserialize_with = "::rp1::helper::double_option")]
        anonymous_user: Option<Option<String>>,
    }
    impl ::validator::Validate for UpdatePatchComment {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_args(())
        }
    }
    #[allow(clippy::all)]
    impl<'v_a> ::validator::ValidateArgs<'v_a> for UpdatePatchComment {
        type Args = ();
        #[allow(unused_mut)]
        #[allow(unused_variable)]
        fn validate_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            let mut errors = ::validator::ValidationErrors::new();
            let mut result = if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            };
            result
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UpdatePatchComment {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "content" => _serde::__private::Ok(__Field::__field0),
                            "approved" => _serde::__private::Ok(__Field::__field1),
                            "post_id" => _serde::__private::Ok(__Field::__field2),
                            "user_id" => _serde::__private::Ok(__Field::__field3),
                            "anonymous_user" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"content" => _serde::__private::Ok(__Field::__field0),
                            b"approved" => _serde::__private::Ok(__Field::__field1),
                            b"post_id" => _serde::__private::Ok(__Field::__field2),
                            b"user_id" => _serde::__private::Ok(__Field::__field3),
                            b"anonymous_user" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UpdatePatchComment>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UpdatePatchComment;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UpdatePatchComment",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct UpdatePatchComment with 5 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<Option<bool>>(
                            &mut __seq,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => _serde::__private::Default::default(),
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<Option<i32>>(
                            &mut __seq,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct UpdatePatchComment with 5 elements",
                                ));
                            }
                        };
                        let __field3 = match {
                            struct __DeserializeWith<'de> {
                                value: Option<Option<i32>>,
                                phantom: _serde::__private::PhantomData<UpdatePatchComment>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: match ::rp1::helper::double_option(__deserializer) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                match _serde::de::SeqAccess::next_element::<__DeserializeWith<'de>>(
                                    &mut __seq,
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                },
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => _serde::__private::Default::default(),
                        };
                        let __field4 = match {
                            struct __DeserializeWith<'de> {
                                value: Option<Option<String>>,
                                phantom: _serde::__private::PhantomData<UpdatePatchComment>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: match ::rp1::helper::double_option(__deserializer) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                match _serde::de::SeqAccess::next_element::<__DeserializeWith<'de>>(
                                    &mut __seq,
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                },
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => _serde::__private::Default::default(),
                        };
                        _serde::__private::Ok(UpdatePatchComment {
                            content: __field0,
                            approved: __field1,
                            post_id: __field2,
                            user_id: __field3,
                            anonymous_user: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Option<String>> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<bool>> =
                            _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<i32>> =
                            _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Option<Option<i32>>> =
                            _serde::__private::None;
                        let mut __field4: _serde::__private::Option<Option<Option<String>>> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "content",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Option<String>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "approved",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Option<bool>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "post_id",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Option<i32>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "user_id",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some({
                                        struct __DeserializeWith<'de> {
                                            value: Option<Option<i32>>,
                                            phantom:
                                                _serde::__private::PhantomData<UpdatePatchComment>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: match ::rp1::helper::double_option(
                                                        __deserializer,
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    },
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map)
                                        {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "anonymous_user",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some({
                                        struct __DeserializeWith<'de> {
                                            value: Option<Option<String>>,
                                            phantom:
                                                _serde::__private::PhantomData<UpdatePatchComment>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: match ::rp1::helper::double_option(
                                                        __deserializer,
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    },
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map)
                                        {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("content") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => _serde::__private::Default::default(),
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("post_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => _serde::__private::Default::default(),
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => _serde::__private::Default::default(),
                        };
                        _serde::__private::Ok(UpdatePatchComment {
                            content: __field0,
                            approved: __field1,
                            post_id: __field2,
                            user_id: __field3,
                            anonymous_user: __field4,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &[
                    "content",
                    "approved",
                    "post_id",
                    "user_id",
                    "anonymous_user",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UpdatePatchComment",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UpdatePatchComment>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_snake_case)]
    const _: () = { # [doc = r" Rocket generated FormForm context."] # [doc (hidden)] pub struct FromFormGeneratedContext < '__f > { __opts : :: rocket :: form :: prelude :: Options , __errors : :: rocket :: form :: prelude :: Errors < '__f > , __parent : :: std :: option :: Option < & '__f :: rocket :: form :: prelude :: Name > , content : :: std :: option :: Option < < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , approved : :: std :: option :: Option < < Option < bool > as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , post_id : :: std :: option :: Option < < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , user_id : :: std :: option :: Option < < Option < Option < i32 > > as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , anonymous_user : :: std :: option :: Option < < Option < Option < String > > as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , } # [allow (unused_imports)] use :: rocket :: http :: uncased :: AsUncased ; impl < '__f > :: rocket :: form :: prelude :: FromForm < '__f > for UpdatePatchComment { type Context = FromFormGeneratedContext < '__f > ; fn init (__opts : :: rocket :: form :: prelude :: Options) -> Self :: Context { Self :: Context { __opts , __errors : :: rocket :: form :: prelude :: Errors :: new () , __parent : :: std :: option :: Option :: None , content : :: std :: option :: Option :: None , approved : :: std :: option :: Option :: None , post_id : :: std :: option :: Option :: None , user_id : :: std :: option :: Option :: None , anonymous_user : :: std :: option :: Option :: None , } } fn push_value (__c : & mut Self :: Context , __f : :: rocket :: form :: prelude :: ValueField < '__f >) { __c . __parent = __f . name . parent () ; match __f . name . key_lossy () . as_str () { "content" => { { < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . content . get_or_insert_with (| | < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "approved" => { { < Option < bool > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . approved . get_or_insert_with (| | < Option < bool > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "post_id" => { { < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . post_id . get_or_insert_with (| | < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "user_id" => { { < Option < Option < i32 > > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . user_id . get_or_insert_with (| | < Option < Option < i32 > > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "anonymous_user" => { { < Option < Option < String > > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . anonymous_user . get_or_insert_with (| | < Option < Option < String > > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } __k if __k == "_method" || ! __c . __opts . strict => { } _ => __c . __errors . push (__f . unexpected ()) , } } # [allow (clippy :: let_unit_value , clippy :: type_complexity , clippy :: type_repetition_in_bounds , clippy :: used_underscore_binding)] fn push_data < 'life0 , 'life1 , 'async_trait > (__c : & 'life0 mut FromFormGeneratedContext < '__f > , __f : :: rocket :: form :: prelude :: DataField < '__f , 'life1 >) -> :: core :: pin :: Pin < Box < dyn :: core :: future :: Future < Output = () > + :: core :: marker :: Send + 'async_trait > > where '__f : 'async_trait , 'life0 : 'async_trait , 'life1 : 'async_trait { Box :: pin (async move { let __c = __c ; let __f = __f ; let _ : () = { __c . __parent = __f . name . parent () ; match __f . name . key_lossy () . as_str () { "content" => { { let _fut = < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . content . get_or_insert_with (| | < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "approved" => { { let _fut = < Option < bool > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . approved . get_or_insert_with (| | < Option < bool > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "post_id" => { { let _fut = < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . post_id . get_or_insert_with (| | < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "user_id" => { { let _fut = < Option < Option < i32 > > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . user_id . get_or_insert_with (| | < Option < Option < i32 > > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "anonymous_user" => { { let _fut = < Option < Option < String > > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . anonymous_user . get_or_insert_with (| | < Option < Option < String > > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } __k if __k == "_method" || ! __c . __opts . strict => { } _ => __c . __errors . push (__f . unexpected ()) , } } ; }) } fn finalize (mut __c : Self :: Context) -> :: std :: result :: Result < Self , :: rocket :: form :: prelude :: Errors < '__f > > { # [allow (unused_imports)] use :: rocket :: form :: prelude :: validate :: * ; let content = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "content")) ; let __opts = __c . __opts ; __c . content . map_or_else (| | { < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| content | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | content) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (content) => :: std :: option :: Option :: Some (content) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let approved = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "approved")) ; let __opts = __c . __opts ; __c . approved . map_or_else (| | { < Option < bool > as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < Option < bool > as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| approved | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | approved) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (approved) => :: std :: option :: Option :: Some (approved) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let post_id = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "post_id")) ; let __opts = __c . __opts ; __c . post_id . map_or_else (| | { < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| post_id | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | post_id) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (post_id) => :: std :: option :: Option :: Some (post_id) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let user_id = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "user_id")) ; let __opts = __c . __opts ; __c . user_id . map_or_else (| | { < Option < Option < i32 > > as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < Option < Option < i32 > > as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| user_id | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | user_id) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (user_id) => :: std :: option :: Option :: Some (user_id) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let anonymous_user = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "anonymous_user")) ; let __opts = __c . __opts ; __c . anonymous_user . map_or_else (| | { < Option < Option < String > > as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < Option < Option < String > > as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| anonymous_user | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | anonymous_user) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (anonymous_user) => :: std :: option :: Option :: Some (anonymous_user) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; if ! __c . __errors . is_empty () { return :: std :: result :: Result :: Err (__c . __errors) ; } let __o = Self { content : content . unwrap () , approved : approved . unwrap () , post_id : post_id . unwrap () , user_id : user_id . unwrap () , anonymous_user : anonymous_user . unwrap () , } ; if ! __c . __errors . is_empty () { return :: std :: result :: Result :: Err (__c . __errors) ; } Ok (__o) } } };
    #[allow(non_snake_case, unused_extern_crates, unused_imports)]
    fn _impl_as_changeset_for_updatepatchcomment() {
        extern crate std;
        use diesel;
        use diesel::query_builder::AsChangeset;
        use diesel::prelude::*;
        impl<'update> AsChangeset for &'update UpdatePatchComment {
            type Target = comments::table;
            type Changeset = <(
                std::option::Option<diesel::dsl::Eq<comments::content, &'update String>>,
                std::option::Option<diesel::dsl::Eq<comments::approved, &'update bool>>,
                std::option::Option<diesel::dsl::Eq<comments::post_id, &'update i32>>,
                std::option::Option<diesel::dsl::Eq<comments::user_id, &'update Option<i32>>>,
                std::option::Option<
                    diesel::dsl::Eq<comments::anonymous_user, &'update Option<String>>,
                >,
            ) as AsChangeset>::Changeset;
            fn as_changeset(self) -> Self::Changeset {
                (
                    self.content.as_ref().map(|x| comments::content.eq(x)),
                    self.approved.as_ref().map(|x| comments::approved.eq(x)),
                    self.post_id.as_ref().map(|x| comments::post_id.eq(x)),
                    self.user_id.as_ref().map(|x| comments::user_id.eq(x)),
                    self.anonymous_user
                        .as_ref()
                        .map(|x| comments::anonymous_user.eq(x)),
                )
                    .as_changeset()
            }
        }
        impl<'update> AsChangeset for UpdatePatchComment {
            type Target = comments::table;
            type Changeset = <(
                std::option::Option<diesel::dsl::Eq<comments::content, String>>,
                std::option::Option<diesel::dsl::Eq<comments::approved, bool>>,
                std::option::Option<diesel::dsl::Eq<comments::post_id, i32>>,
                std::option::Option<diesel::dsl::Eq<comments::user_id, Option<i32>>>,
                std::option::Option<diesel::dsl::Eq<comments::anonymous_user, Option<String>>>,
            ) as AsChangeset>::Changeset;
            fn as_changeset(self) -> Self::Changeset {
                (
                    self.content.map(|x| comments::content.eq(x)),
                    self.approved.map(|x| comments::approved.eq(x)),
                    self.post_id.map(|x| comments::post_id.eq(x)),
                    self.user_id.map(|x| comments::user_id.eq(x)),
                    self.anonymous_user.map(|x| comments::anonymous_user.eq(x)),
                )
                    .as_changeset()
            }
        }
    }
    #[allow(non_snake_case, unused_extern_crates, unused_imports)]
    fn _impl_queryable_for_updatepatchcomment() {
        extern crate std;
        use diesel;
        use diesel::Queryable;
        impl<__DB: diesel::backend::Backend, __ST> Queryable<__ST, __DB> for UpdatePatchComment
        where
            (
                Option<String>,
                Option<bool>,
                Option<i32>,
                Option<Option<i32>>,
                Option<Option<String>>,
            ): Queryable<__ST, __DB>,
        {
            type Row = <(
                Option<String>,
                Option<bool>,
                Option<i32>,
                Option<Option<i32>>,
                Option<Option<String>>,
            ) as Queryable<__ST, __DB>>::Row;
            fn build(row: Self::Row) -> Self {
                let row: (
                    Option<String>,
                    Option<bool>,
                    Option<i32>,
                    Option<Option<i32>>,
                    Option<Option<String>>,
                ) = Queryable::build(row);
                Self {
                    content: (row.0.into()),
                    approved: (row.1.into()),
                    post_id: (row.2.into()),
                    user_id: (row.3.into()),
                    anonymous_user: (row.4.into()),
                }
            }
        }
    }
    #[table_name = "comments"]
    pub struct UpdatePutComment {
        id: i32,
        content: String,
        #[serde(default)]
        approved: bool,
        post_id: i32,
        user_id: Option<i32>,
        anonymous_user: Option<String>,
        created_at: rp1::datetime::OffsetDateTime,
        updated_at: rp1::datetime::OffsetDateTime,
    }
    impl ::validator::Validate for UpdatePutComment {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_args(())
        }
    }
    #[allow(clippy::all)]
    impl<'v_a> ::validator::ValidateArgs<'v_a> for UpdatePutComment {
        type Args = ();
        #[allow(unused_mut)]
        #[allow(unused_variable)]
        fn validate_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            let mut errors = ::validator::ValidationErrors::new();
            let mut result = if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            };
            result
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UpdatePutComment {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "content" => _serde::__private::Ok(__Field::__field1),
                            "approved" => _serde::__private::Ok(__Field::__field2),
                            "post_id" => _serde::__private::Ok(__Field::__field3),
                            "user_id" => _serde::__private::Ok(__Field::__field4),
                            "anonymous_user" => _serde::__private::Ok(__Field::__field5),
                            "created_at" => _serde::__private::Ok(__Field::__field6),
                            "updated_at" => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"content" => _serde::__private::Ok(__Field::__field1),
                            b"approved" => _serde::__private::Ok(__Field::__field2),
                            b"post_id" => _serde::__private::Ok(__Field::__field3),
                            b"user_id" => _serde::__private::Ok(__Field::__field4),
                            b"anonymous_user" => _serde::__private::Ok(__Field::__field5),
                            b"created_at" => _serde::__private::Ok(__Field::__field6),
                            b"updated_at" => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UpdatePutComment>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UpdatePutComment;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UpdatePutComment",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<i32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct UpdatePutComment with 8 elements",
                                        ),
                                    );
                                }
                            };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct UpdatePutComment with 8 elements",
                                        ),
                                    );
                                }
                            };
                        let __field2 =
                            match match _serde::de::SeqAccess::next_element::<bool>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => _serde::__private::Default::default(),
                            };
                        let __field3 =
                            match match _serde::de::SeqAccess::next_element::<i32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct UpdatePutComment with 8 elements",
                                        ),
                                    );
                                }
                            };
                        let __field4 = match match _serde::de::SeqAccess::next_element::<Option<i32>>(
                            &mut __seq,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct UpdatePutComment with 8 elements",
                                ));
                            }
                        };
                        let __field5 = match match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    5usize,
                                    &"struct UpdatePutComment with 8 elements",
                                ));
                            }
                        };
                        let __field6 = match match _serde::de::SeqAccess::next_element::<
                            rp1::datetime::OffsetDateTime,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    6usize,
                                    &"struct UpdatePutComment with 8 elements",
                                ));
                            }
                        };
                        let __field7 = match match _serde::de::SeqAccess::next_element::<
                            rp1::datetime::OffsetDateTime,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    7usize,
                                    &"struct UpdatePutComment with 8 elements",
                                ));
                            }
                        };
                        _serde::__private::Ok(UpdatePutComment {
                            id: __field0,
                            content: __field1,
                            approved: __field2,
                            post_id: __field3,
                            user_id: __field4,
                            anonymous_user: __field5,
                            created_at: __field6,
                            updated_at: __field7,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i32> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> =
                            _serde::__private::None;
                        let mut __field2: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<i32> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<Option<i32>> =
                            _serde::__private::None;
                        let mut __field5: _serde::__private::Option<Option<String>> =
                            _serde::__private::None;
                        let mut __field6: _serde::__private::Option<rp1::datetime::OffsetDateTime> =
                            _serde::__private::None;
                        let mut __field7: _serde::__private::Option<rp1::datetime::OffsetDateTime> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<i32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "content",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<String>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "approved",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<bool>(&mut __map)
                                        {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "post_id",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<i32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "user_id",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Option<i32>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "anonymous_user",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Option<String>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "created_at",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            rp1::datetime::OffsetDateTime,
                                        >(&mut __map)
                                        {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "updated_at",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            rp1::datetime::OffsetDateTime,
                                        >(&mut __map)
                                        {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("content") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => _serde::__private::Default::default(),
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("post_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("user_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("anonymous_user") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("created_at") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("updated_at") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(UpdatePutComment {
                            id: __field0,
                            content: __field1,
                            approved: __field2,
                            post_id: __field3,
                            user_id: __field4,
                            anonymous_user: __field5,
                            created_at: __field6,
                            updated_at: __field7,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &[
                    "id",
                    "content",
                    "approved",
                    "post_id",
                    "user_id",
                    "anonymous_user",
                    "created_at",
                    "updated_at",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UpdatePutComment",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UpdatePutComment>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_snake_case)]
    const _: () = { # [doc = r" Rocket generated FormForm context."] # [doc (hidden)] pub struct FromFormGeneratedContext < '__f > { __opts : :: rocket :: form :: prelude :: Options , __errors : :: rocket :: form :: prelude :: Errors < '__f > , __parent : :: std :: option :: Option < & '__f :: rocket :: form :: prelude :: Name > , id : :: std :: option :: Option < < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , content : :: std :: option :: Option < < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , approved : :: std :: option :: Option < < bool as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , post_id : :: std :: option :: Option < < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , user_id : :: std :: option :: Option < < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , anonymous_user : :: std :: option :: Option < < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , created_at : :: std :: option :: Option < < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , updated_at : :: std :: option :: Option < < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: Context > , } # [allow (unused_imports)] use :: rocket :: http :: uncased :: AsUncased ; impl < '__f > :: rocket :: form :: prelude :: FromForm < '__f > for UpdatePutComment { type Context = FromFormGeneratedContext < '__f > ; fn init (__opts : :: rocket :: form :: prelude :: Options) -> Self :: Context { Self :: Context { __opts , __errors : :: rocket :: form :: prelude :: Errors :: new () , __parent : :: std :: option :: Option :: None , id : :: std :: option :: Option :: None , content : :: std :: option :: Option :: None , approved : :: std :: option :: Option :: None , post_id : :: std :: option :: Option :: None , user_id : :: std :: option :: Option :: None , anonymous_user : :: std :: option :: Option :: None , created_at : :: std :: option :: Option :: None , updated_at : :: std :: option :: Option :: None , } } fn push_value (__c : & mut Self :: Context , __f : :: rocket :: form :: prelude :: ValueField < '__f >) { __c . __parent = __f . name . parent () ; match __f . name . key_lossy () . as_str () { "id" => { { < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . id . get_or_insert_with (| | < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "content" => { { < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . content . get_or_insert_with (| | < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "approved" => { { < bool as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . approved . get_or_insert_with (| | < bool as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "post_id" => { { < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . post_id . get_or_insert_with (| | < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "user_id" => { { < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . user_id . get_or_insert_with (| | < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "anonymous_user" => { { < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . anonymous_user . get_or_insert_with (| | < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "created_at" => { { < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . created_at . get_or_insert_with (| | < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } "updated_at" => { { < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_value ({ let __o = __c . __opts ; __c . updated_at . get_or_insert_with (| | < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; } } __k if __k == "_method" || ! __c . __opts . strict => { } _ => __c . __errors . push (__f . unexpected ()) , } } # [allow (clippy :: let_unit_value , clippy :: type_complexity , clippy :: type_repetition_in_bounds , clippy :: used_underscore_binding)] fn push_data < 'life0 , 'life1 , 'async_trait > (__c : & 'life0 mut FromFormGeneratedContext < '__f > , __f : :: rocket :: form :: prelude :: DataField < '__f , 'life1 >) -> :: core :: pin :: Pin < Box < dyn :: core :: future :: Future < Output = () > + :: core :: marker :: Send + 'async_trait > > where '__f : 'async_trait , 'life0 : 'async_trait , 'life1 : 'async_trait { Box :: pin (async move { let __c = __c ; let __f = __f ; let _ : () = { __c . __parent = __f . name . parent () ; match __f . name . key_lossy () . as_str () { "id" => { { let _fut = < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . id . get_or_insert_with (| | < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "content" => { { let _fut = < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . content . get_or_insert_with (| | < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "approved" => { { let _fut = < bool as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . approved . get_or_insert_with (| | < bool as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "post_id" => { { let _fut = < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . post_id . get_or_insert_with (| | < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "user_id" => { { let _fut = < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . user_id . get_or_insert_with (| | < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "anonymous_user" => { { let _fut = < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . anonymous_user . get_or_insert_with (| | < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "created_at" => { { let _fut = < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . created_at . get_or_insert_with (| | < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } "updated_at" => { { let _fut = < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: push_data ({ let __o = __c . __opts ; __c . updated_at . get_or_insert_with (| | < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: init (__o)) } , __f . shift ()) ; _fut . await ; } } __k if __k == "_method" || ! __c . __opts . strict => { } _ => __c . __errors . push (__f . unexpected ()) , } } ; }) } fn finalize (mut __c : Self :: Context) -> :: std :: result :: Result < Self , :: rocket :: form :: prelude :: Errors < '__f > > { # [allow (unused_imports)] use :: rocket :: form :: prelude :: validate :: * ; let id = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "id")) ; let __opts = __c . __opts ; __c . id . map_or_else (| | { < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| id | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | id) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (id) => :: std :: option :: Option :: Some (id) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let content = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "content")) ; let __opts = __c . __opts ; __c . content . map_or_else (| | { < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < String as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| content | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | content) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (content) => :: std :: option :: Option :: Some (content) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let approved = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "approved")) ; let __opts = __c . __opts ; __c . approved . map_or_else (| | { < bool as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < bool as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| approved | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | approved) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (approved) => :: std :: option :: Option :: Some (approved) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let post_id = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "post_id")) ; let __opts = __c . __opts ; __c . post_id . map_or_else (| | { < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < i32 as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| post_id | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | post_id) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (post_id) => :: std :: option :: Option :: Some (post_id) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let user_id = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "user_id")) ; let __opts = __c . __opts ; __c . user_id . map_or_else (| | { < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < Option < i32 > as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| user_id | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | user_id) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (user_id) => :: std :: option :: Option :: Some (user_id) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let anonymous_user = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "anonymous_user")) ; let __opts = __c . __opts ; __c . anonymous_user . map_or_else (| | { < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < Option < String > as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| anonymous_user | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | anonymous_user) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (anonymous_user) => :: std :: option :: Option :: Some (anonymous_user) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let created_at = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "created_at")) ; let __opts = __c . __opts ; __c . created_at . map_or_else (| | { < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| created_at | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | created_at) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (created_at) => :: std :: option :: Option :: Some (created_at) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; let updated_at = match { let __name = :: rocket :: form :: prelude :: NameBuf :: from ((__c . __parent , "updated_at")) ; let __opts = __c . __opts ; __c . updated_at . map_or_else (| | { < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: default (__opts) } . ok_or_else (| | :: rocket :: form :: prelude :: ErrorKind :: Missing . into ()) , < rp1 :: datetime :: OffsetDateTime as :: rocket :: form :: prelude :: FromForm < '__f > > :: finalize) . and_then (| updated_at | { let mut __es = :: rocket :: form :: prelude :: Errors :: new () ; __es . is_empty () . then (| | updated_at) . ok_or (__es) }) . map_err (| __e | __e . with_name (__name)) . map_err (| __e | __e . is_empty () . then (| | :: rocket :: form :: prelude :: ErrorKind :: Unknown . into ()) . unwrap_or (__e)) } { :: std :: result :: Result :: Ok (updated_at) => :: std :: option :: Option :: Some (updated_at) , :: std :: result :: Result :: Err (__e) => { __c . __errors . extend (__e) ; :: std :: option :: Option :: None } } ; if ! __c . __errors . is_empty () { return :: std :: result :: Result :: Err (__c . __errors) ; } let __o = Self { id : id . unwrap () , content : content . unwrap () , approved : approved . unwrap () , post_id : post_id . unwrap () , user_id : user_id . unwrap () , anonymous_user : anonymous_user . unwrap () , created_at : created_at . unwrap () , updated_at : updated_at . unwrap () , } ; if ! __c . __errors . is_empty () { return :: std :: result :: Result :: Err (__c . __errors) ; } Ok (__o) } } };
    #[allow(non_snake_case, unused_extern_crates, unused_imports)]
    fn _impl_as_changeset_for_updateputcomment() {
        extern crate std;
        use diesel;
        use diesel::query_builder::AsChangeset;
        use diesel::prelude::*;
        impl<'update> AsChangeset for &'update UpdatePutComment {
            type Target = comments::table;
            type Changeset = <(
                diesel::dsl::Eq<comments::content, &'update String>,
                diesel::dsl::Eq<comments::approved, &'update bool>,
                diesel::dsl::Eq<comments::post_id, &'update i32>,
                std::option::Option<diesel::dsl::Eq<comments::user_id, &'update i32>>,
                std::option::Option<diesel::dsl::Eq<comments::anonymous_user, &'update String>>,
                diesel::dsl::Eq<comments::created_at, &'update rp1::datetime::OffsetDateTime>,
                diesel::dsl::Eq<comments::updated_at, &'update rp1::datetime::OffsetDateTime>,
            ) as AsChangeset>::Changeset;
            fn as_changeset(self) -> Self::Changeset {
                (
                    comments::content.eq(&self.content),
                    comments::approved.eq(&self.approved),
                    comments::post_id.eq(&self.post_id),
                    self.user_id.as_ref().map(|x| comments::user_id.eq(x)),
                    self.anonymous_user
                        .as_ref()
                        .map(|x| comments::anonymous_user.eq(x)),
                    comments::created_at.eq(&self.created_at),
                    comments::updated_at.eq(&self.updated_at),
                )
                    .as_changeset()
            }
        }
        impl<'update> AsChangeset for UpdatePutComment {
            type Target = comments::table;
            type Changeset = <(
                diesel::dsl::Eq<comments::content, String>,
                diesel::dsl::Eq<comments::approved, bool>,
                diesel::dsl::Eq<comments::post_id, i32>,
                std::option::Option<diesel::dsl::Eq<comments::user_id, i32>>,
                std::option::Option<diesel::dsl::Eq<comments::anonymous_user, String>>,
                diesel::dsl::Eq<comments::created_at, rp1::datetime::OffsetDateTime>,
                diesel::dsl::Eq<comments::updated_at, rp1::datetime::OffsetDateTime>,
            ) as AsChangeset>::Changeset;
            fn as_changeset(self) -> Self::Changeset {
                (
                    comments::content.eq(self.content),
                    comments::approved.eq(self.approved),
                    comments::post_id.eq(self.post_id),
                    self.user_id.map(|x| comments::user_id.eq(x)),
                    self.anonymous_user.map(|x| comments::anonymous_user.eq(x)),
                    comments::created_at.eq(self.created_at),
                    comments::updated_at.eq(self.updated_at),
                )
                    .as_changeset()
            }
        }
    }
    #[allow(non_snake_case, unused_extern_crates, unused_imports)]
    fn _impl_queryable_for_updateputcomment() {
        extern crate std;
        use diesel;
        use diesel::Queryable;
        impl<__DB: diesel::backend::Backend, __ST> Queryable<__ST, __DB> for UpdatePutComment
        where
            (
                i32,
                String,
                bool,
                i32,
                Option<i32>,
                Option<String>,
                rp1::datetime::OffsetDateTime,
                rp1::datetime::OffsetDateTime,
            ): Queryable<__ST, __DB>,
        {
            type Row = <(
                i32,
                String,
                bool,
                i32,
                Option<i32>,
                Option<String>,
                rp1::datetime::OffsetDateTime,
                rp1::datetime::OffsetDateTime,
            ) as Queryable<__ST, __DB>>::Row;
            fn build(row: Self::Row) -> Self {
                let row: (
                    i32,
                    String,
                    bool,
                    i32,
                    Option<i32>,
                    Option<String>,
                    rp1::datetime::OffsetDateTime,
                    rp1::datetime::OffsetDateTime,
                ) = Queryable::build(row);
                Self {
                    id: (row.0.into()),
                    content: (row.1.into()),
                    approved: (row.2.into()),
                    post_id: (row.3.into()),
                    user_id: (row.4.into()),
                    anonymous_user: (row.5.into()),
                    created_at: (row.6.into()),
                    updated_at: (row.7.into()),
                }
            }
        }
    }
    impl UpdatePutComment {
        pub fn create(base: &Comment, patch: &UpdatePatchComment) -> UpdatePutComment {
            let content = if let Some(ref v) = patch.content {
                v.clone()
            } else {
                base.content.clone()
            };
            let approved = if let Some(ref v) = patch.approved {
                v.clone()
            } else {
                base.approved.clone()
            };
            let post_id = if let Some(ref v) = patch.post_id {
                v.clone()
            } else {
                base.post_id.clone()
            };
            let user_id = if let Some(ref v) = patch.user_id {
                v.clone()
            } else {
                base.user_id.clone()
            };
            let anonymous_user = if let Some(ref v) = patch.anonymous_user {
                v.clone()
            } else {
                base.anonymous_user.clone()
            };
            UpdatePutComment {
                content,
                approved,
                post_id,
                user_id,
                anonymous_user,
                id: base.id.clone(),
                created_at: base.created_at.clone(),
                updated_at: base.updated_at.clone(),
            }
        }
        pub fn validate_update(&self, base: &Comment) -> ::rp1::CrudResult<()> {
            if self.id != base.id {
                return Err(::rp1::CrudError::UnchangeableField("id".to_owned()));
            }
            if self.created_at != base.created_at {
                return Err(::rp1::CrudError::UnchangeableField("created_at".to_owned()));
            }
            if self.updated_at != base.updated_at {
                return Err(::rp1::CrudError::UnchangeableField("updated_at".to_owned()));
            }
            Ok(())
        }
        pub fn into_patch(self, base: &Comment) -> UpdatePatchComment {
            UpdatePatchComment {
                content: if self.content == base.content {
                    None
                } else {
                    Some(self.content)
                },
                approved: if self.approved == base.approved {
                    None
                } else {
                    Some(self.approved)
                },
                post_id: if self.post_id == base.post_id {
                    None
                } else {
                    Some(self.post_id)
                },
                user_id: if self.user_id == base.user_id {
                    None
                } else {
                    Some(self.user_id)
                },
                anonymous_user: if self.anonymous_user == base.anonymous_user {
                    None
                } else {
                    Some(self.anonymous_user)
                },
            }
        }
    }
    impl ::rp1::CrudUpdatable for Comment {
        type PatchType = UpdatePatchComment;
        type PutType = UpdatePutComment;
    }
    async fn update_put_fn_help(
        db: Db,
        id: i32,
        value: UpdatePutComment,
        auth_user: <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<Comment> {
        let row = db
            .run(move |conn| {
                crate::schema::comments::table
                    .find(id)
                    .first::<Comment>(conn)
            })
            .await?;
        if !<Comment as ::rp1::CheckPermissions>::allow_update(&row, &value, &auth_user) {
            return Err(::rp1::CrudError::NotFound);
        }
        value.validate_update(&row)?;
        use ::validator::Validate;
        value.validate()?;
        Ok(::rocket::serde::json::Json(
            db.run(move |conn| {
                diesel::update(crate::schema::comments::table.find(id))
                    .set(&value)
                    .get_result(conn)
            })
            .await?,
        ))
    }
    async fn update_patch_fn_help(
        db: Db,
        id: i32,
        value: UpdatePatchComment,
        auth_user: <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<Comment> {
        let row = db
            .run(move |conn| {
                crate::schema::comments::table
                    .find(id)
                    .first::<Comment>(conn)
            })
            .await?;
        let put_value = UpdatePutComment::create(&row, &value);
        if !<Comment as ::rp1::CheckPermissions>::allow_update(&row, &put_value, &auth_user) {
            return Err(::rp1::CrudError::NotFound);
        }
        use ::validator::Validate;
        value.validate()?;
        Ok(::rocket::serde::json::Json(
            db.run(move |conn| {
                diesel::update(crate::schema::comments::table.find(id))
                    .set(&value)
                    .get_result(conn)
            })
            .await?,
        ))
    }
    async fn update_patch_fn_json(
        db: Db,
        id: i32,
        value: ::rocket::serde::json::Json<UpdatePatchComment>,
        auth_user: <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<Comment> {
        let value = value.into_inner();
        update_patch_fn_help(db, id, value, auth_user).await
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct update_patch_fn_json {}
    /// Rocket code generated proxy static conversion implementations.
    impl update_patch_fn_json {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::comment",
                                                "example/src/main.rs",
                                                69u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::comment",
                                                "example/src/main.rs",
                                                69u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let __rocket_id: i32 = match __req.routed_segment(0usize) {
                        ::std::option::Option::Some(__s) => {
                            match <i32 as ::rocket::request::FromParam>::from_param(__s) {
                                ::std::result::Result::Ok(__v) => __v,
                                ::std::result::Result::Err(__error) => {
                                    return {
                                        {
                                            let lvl = ::log::Level::Warn;
                                            if lvl <= ::log::STATIC_MAX_LEVEL
                                                && lvl <= ::log::max_level()
                                            {
                                                :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , ": " , "` param guard parsed forwarding with error "] , & match (& "id" , & "i32" , & __error) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ;
                                            }
                                        };
                                        ::rocket::outcome::Outcome::Forward(__data)
                                    }
                                }
                            }
                        }
                        ::std::option::Option::None => {
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Internal invariant broken: dyn param not found."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &(
                                            "_",
                                            "rp1_example::comment",
                                            "example/src/main.rs",
                                            72u32,
                                        ),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Please report this to the Rocket issue tracker."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &(
                                            "_",
                                            "rp1_example::comment",
                                            "example/src/main.rs",
                                            72u32,
                                        ),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["https://github.com/SergioBenitez/Rocket/issues"],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &(
                                            "_",
                                            "rp1_example::comment",
                                            "example/src/main.rs",
                                            72u32,
                                        ),
                                    );
                                }
                            };
                            return ::rocket::outcome::Outcome::Forward(__data);
                        }
                    };
                    let __rocket_value : :: rocket :: serde :: json :: Json < UpdatePatchComment > = match < :: rocket :: serde :: json :: Json < UpdatePatchComment > as :: rocket :: data :: FromData > :: from_data (__req , __data) . await { :: rocket :: outcome :: Outcome :: Success (__d) => __d , :: rocket :: outcome :: Outcome :: Forward (__d) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard is forwarding."] , & match (& ":: rocket :: serde :: json :: Json < UpdatePatchComment >" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__d) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard failed: " , "."] , & match (& ":: rocket :: serde :: json :: Json < UpdatePatchComment >" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let ___responder = update_patch_fn_json(
                        __rocket_db,
                        __rocket_id,
                        __rocket_value,
                        __rocket_auth_user,
                    )
                    .await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "update_patch_fn_json",
                method: ::rocket::http::Method::Patch,
                uri: "/<id>",
                handler: monomorphized_function,
                format: ::std::option::Option::Some(::rocket::http::MediaType::const_new(
                    "application",
                    "json",
                    &[],
                )),
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<i32>(),
                            type_name: std::any::type_name::<i32>(),
                            parent: None,
                            location: ("example/src/main.rs", 72u32, 9u32),
                            specialized: Resolve::<i32>::SPECIALIZED,
                            abort: Resolve::<i32>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized: Resolve::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Comment>(),
                            type_name: std::any::type_name::<Comment>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 70u32, 8u32),
                            specialized: Resolve::<Comment>::SPECIALIZED,
                            abort: Resolve::<Comment>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::CrudJsonResult<Comment>>(),
                            type_name: std::any::type_name::<::rp1::CrudJsonResult<Comment>>(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized: Resolve::<::rp1::CrudJsonResult<Comment>>::SPECIALIZED,
                            abort: Resolve::<::rp1::CrudJsonResult<Comment>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Comment>(),
                            type_name: std::any::type_name::<Comment>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                ::rp1::CrudJsonResult<Comment>,
                            >())),
                            location: ("example/src/main.rs", 70u32, 8u32),
                            specialized: Resolve::<Comment>::SPECIALIZED,
                            abort: Resolve::<Comment>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_update_patch_fn_json_3091274444072980750 as rocket_uri_macro_update_patch_fn_json;
    async fn update_patch_fn_form(
        db: Db,
        id: i32,
        value: ::rocket::form::Form<UpdatePatchComment>,
        auth_user: <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<Comment> {
        let value = value.into_inner();
        update_patch_fn_help(db, id, value, auth_user).await
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct update_patch_fn_form {}
    /// Rocket code generated proxy static conversion implementations.
    impl update_patch_fn_form {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::comment",
                                                "example/src/main.rs",
                                                69u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::comment",
                                                "example/src/main.rs",
                                                69u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let __rocket_id: i32 = match __req.routed_segment(0usize) {
                        ::std::option::Option::Some(__s) => {
                            match <i32 as ::rocket::request::FromParam>::from_param(__s) {
                                ::std::result::Result::Ok(__v) => __v,
                                ::std::result::Result::Err(__error) => {
                                    return {
                                        {
                                            let lvl = ::log::Level::Warn;
                                            if lvl <= ::log::STATIC_MAX_LEVEL
                                                && lvl <= ::log::max_level()
                                            {
                                                :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , ": " , "` param guard parsed forwarding with error "] , & match (& "id" , & "i32" , & __error) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ;
                                            }
                                        };
                                        ::rocket::outcome::Outcome::Forward(__data)
                                    }
                                }
                            }
                        }
                        ::std::option::Option::None => {
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Internal invariant broken: dyn param not found."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &(
                                            "_",
                                            "rp1_example::comment",
                                            "example/src/main.rs",
                                            72u32,
                                        ),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Please report this to the Rocket issue tracker."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &(
                                            "_",
                                            "rp1_example::comment",
                                            "example/src/main.rs",
                                            72u32,
                                        ),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["https://github.com/SergioBenitez/Rocket/issues"],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &(
                                            "_",
                                            "rp1_example::comment",
                                            "example/src/main.rs",
                                            72u32,
                                        ),
                                    );
                                }
                            };
                            return ::rocket::outcome::Outcome::Forward(__data);
                        }
                    };
                    let __rocket_value : :: rocket :: form :: Form < UpdatePatchComment > = match < :: rocket :: form :: Form < UpdatePatchComment > as :: rocket :: data :: FromData > :: from_data (__req , __data) . await { :: rocket :: outcome :: Outcome :: Success (__d) => __d , :: rocket :: outcome :: Outcome :: Forward (__d) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard is forwarding."] , & match (& ":: rocket :: form :: Form < UpdatePatchComment >" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__d) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard failed: " , "."] , & match (& ":: rocket :: form :: Form < UpdatePatchComment >" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let ___responder = update_patch_fn_form(
                        __rocket_db,
                        __rocket_id,
                        __rocket_value,
                        __rocket_auth_user,
                    )
                    .await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "update_patch_fn_form",
                method: ::rocket::http::Method::Patch,
                uri: "/<id>",
                handler: monomorphized_function,
                format: ::std::option::Option::Some(::rocket::http::MediaType::const_new(
                    "application",
                    "x-www-form-urlencoded",
                    &[],
                )),
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<i32>(),
                            type_name: std::any::type_name::<i32>(),
                            parent: None,
                            location: ("example/src/main.rs", 72u32, 9u32),
                            specialized: Resolve::<i32>::SPECIALIZED,
                            abort: Resolve::<i32>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized: Resolve::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Comment>(),
                            type_name: std::any::type_name::<Comment>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 70u32, 8u32),
                            specialized: Resolve::<Comment>::SPECIALIZED,
                            abort: Resolve::<Comment>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::CrudJsonResult<Comment>>(),
                            type_name: std::any::type_name::<::rp1::CrudJsonResult<Comment>>(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized: Resolve::<::rp1::CrudJsonResult<Comment>>::SPECIALIZED,
                            abort: Resolve::<::rp1::CrudJsonResult<Comment>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Comment>(),
                            type_name: std::any::type_name::<Comment>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                ::rp1::CrudJsonResult<Comment>,
                            >())),
                            location: ("example/src/main.rs", 70u32, 8u32),
                            specialized: Resolve::<Comment>::SPECIALIZED,
                            abort: Resolve::<Comment>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_update_patch_fn_form_8751806004374122565 as rocket_uri_macro_update_patch_fn_form;
    async fn update_put_fn_json(
        db: Db,
        id: i32,
        value: ::rocket::serde::json::Json<UpdatePutComment>,
        auth_user: <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<Comment> {
        let value = value.into_inner();
        update_put_fn_help(db, id, value, auth_user).await
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct update_put_fn_json {}
    /// Rocket code generated proxy static conversion implementations.
    impl update_put_fn_json {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::comment",
                                                "example/src/main.rs",
                                                69u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::comment",
                                                "example/src/main.rs",
                                                69u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let __rocket_id: i32 = match __req.routed_segment(0usize) {
                        ::std::option::Option::Some(__s) => {
                            match <i32 as ::rocket::request::FromParam>::from_param(__s) {
                                ::std::result::Result::Ok(__v) => __v,
                                ::std::result::Result::Err(__error) => {
                                    return {
                                        {
                                            let lvl = ::log::Level::Warn;
                                            if lvl <= ::log::STATIC_MAX_LEVEL
                                                && lvl <= ::log::max_level()
                                            {
                                                :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , ": " , "` param guard parsed forwarding with error "] , & match (& "id" , & "i32" , & __error) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ;
                                            }
                                        };
                                        ::rocket::outcome::Outcome::Forward(__data)
                                    }
                                }
                            }
                        }
                        ::std::option::Option::None => {
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Internal invariant broken: dyn param not found."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &(
                                            "_",
                                            "rp1_example::comment",
                                            "example/src/main.rs",
                                            72u32,
                                        ),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Please report this to the Rocket issue tracker."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &(
                                            "_",
                                            "rp1_example::comment",
                                            "example/src/main.rs",
                                            72u32,
                                        ),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["https://github.com/SergioBenitez/Rocket/issues"],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &(
                                            "_",
                                            "rp1_example::comment",
                                            "example/src/main.rs",
                                            72u32,
                                        ),
                                    );
                                }
                            };
                            return ::rocket::outcome::Outcome::Forward(__data);
                        }
                    };
                    let __rocket_value : :: rocket :: serde :: json :: Json < UpdatePutComment > = match < :: rocket :: serde :: json :: Json < UpdatePutComment > as :: rocket :: data :: FromData > :: from_data (__req , __data) . await { :: rocket :: outcome :: Outcome :: Success (__d) => __d , :: rocket :: outcome :: Outcome :: Forward (__d) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard is forwarding."] , & match (& ":: rocket :: serde :: json :: Json < UpdatePutComment >" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__d) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard failed: " , "."] , & match (& ":: rocket :: serde :: json :: Json < UpdatePutComment >" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let ___responder = update_put_fn_json(
                        __rocket_db,
                        __rocket_id,
                        __rocket_value,
                        __rocket_auth_user,
                    )
                    .await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "update_put_fn_json",
                method: ::rocket::http::Method::Put,
                uri: "/<id>",
                handler: monomorphized_function,
                format: ::std::option::Option::Some(::rocket::http::MediaType::const_new(
                    "application",
                    "json",
                    &[],
                )),
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<i32>(),
                            type_name: std::any::type_name::<i32>(),
                            parent: None,
                            location: ("example/src/main.rs", 72u32, 9u32),
                            specialized: Resolve::<i32>::SPECIALIZED,
                            abort: Resolve::<i32>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized: Resolve::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Comment>(),
                            type_name: std::any::type_name::<Comment>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 70u32, 8u32),
                            specialized: Resolve::<Comment>::SPECIALIZED,
                            abort: Resolve::<Comment>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::CrudJsonResult<Comment>>(),
                            type_name: std::any::type_name::<::rp1::CrudJsonResult<Comment>>(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized: Resolve::<::rp1::CrudJsonResult<Comment>>::SPECIALIZED,
                            abort: Resolve::<::rp1::CrudJsonResult<Comment>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Comment>(),
                            type_name: std::any::type_name::<Comment>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                ::rp1::CrudJsonResult<Comment>,
                            >())),
                            location: ("example/src/main.rs", 70u32, 8u32),
                            specialized: Resolve::<Comment>::SPECIALIZED,
                            abort: Resolve::<Comment>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_update_put_fn_json_12968688415600525458 as rocket_uri_macro_update_put_fn_json;
    async fn update_put_fn_form(
        db: Db,
        id: i32,
        value: ::rocket::serde::json::Json<UpdatePutComment>,
        auth_user: <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<Comment> {
        let value = value.into_inner();
        update_put_fn_help(db, id, value, auth_user).await
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct update_put_fn_form {}
    /// Rocket code generated proxy static conversion implementations.
    impl update_put_fn_form {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::comment",
                                                "example/src/main.rs",
                                                69u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::comment",
                                                "example/src/main.rs",
                                                69u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let __rocket_id: i32 = match __req.routed_segment(0usize) {
                        ::std::option::Option::Some(__s) => {
                            match <i32 as ::rocket::request::FromParam>::from_param(__s) {
                                ::std::result::Result::Ok(__v) => __v,
                                ::std::result::Result::Err(__error) => {
                                    return {
                                        {
                                            let lvl = ::log::Level::Warn;
                                            if lvl <= ::log::STATIC_MAX_LEVEL
                                                && lvl <= ::log::max_level()
                                            {
                                                :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , ": " , "` param guard parsed forwarding with error "] , & match (& "id" , & "i32" , & __error) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ;
                                            }
                                        };
                                        ::rocket::outcome::Outcome::Forward(__data)
                                    }
                                }
                            }
                        }
                        ::std::option::Option::None => {
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Internal invariant broken: dyn param not found."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &(
                                            "_",
                                            "rp1_example::comment",
                                            "example/src/main.rs",
                                            72u32,
                                        ),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Please report this to the Rocket issue tracker."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &(
                                            "_",
                                            "rp1_example::comment",
                                            "example/src/main.rs",
                                            72u32,
                                        ),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["https://github.com/SergioBenitez/Rocket/issues"],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &(
                                            "_",
                                            "rp1_example::comment",
                                            "example/src/main.rs",
                                            72u32,
                                        ),
                                    );
                                }
                            };
                            return ::rocket::outcome::Outcome::Forward(__data);
                        }
                    };
                    let __rocket_value : :: rocket :: serde :: json :: Json < UpdatePutComment > = match < :: rocket :: serde :: json :: Json < UpdatePutComment > as :: rocket :: data :: FromData > :: from_data (__req , __data) . await { :: rocket :: outcome :: Outcome :: Success (__d) => __d , :: rocket :: outcome :: Outcome :: Forward (__d) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard is forwarding."] , & match (& ":: rocket :: serde :: json :: Json < UpdatePutComment >" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__d) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` data guard failed: " , "."] , & match (& ":: rocket :: serde :: json :: Json < UpdatePutComment >" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let ___responder = update_put_fn_form(
                        __rocket_db,
                        __rocket_id,
                        __rocket_value,
                        __rocket_auth_user,
                    )
                    .await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "update_put_fn_form",
                method: ::rocket::http::Method::Put,
                uri: "/<id>",
                handler: monomorphized_function,
                format: ::std::option::Option::Some(::rocket::http::MediaType::const_new(
                    "application",
                    "x-www-form-urlencoded",
                    &[],
                )),
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<i32>(),
                            type_name: std::any::type_name::<i32>(),
                            parent: None,
                            location: ("example/src/main.rs", 72u32, 9u32),
                            specialized: Resolve::<i32>::SPECIALIZED,
                            abort: Resolve::<i32>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized: Resolve::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Comment>(),
                            type_name: std::any::type_name::<Comment>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 70u32, 8u32),
                            specialized: Resolve::<Comment>::SPECIALIZED,
                            abort: Resolve::<Comment>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::CrudJsonResult<Comment>>(),
                            type_name: std::any::type_name::<::rp1::CrudJsonResult<Comment>>(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized: Resolve::<::rp1::CrudJsonResult<Comment>>::SPECIALIZED,
                            abort: Resolve::<::rp1::CrudJsonResult<Comment>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Comment>(),
                            type_name: std::any::type_name::<Comment>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                ::rp1::CrudJsonResult<Comment>,
                            >())),
                            location: ("example/src/main.rs", 70u32, 8u32),
                            specialized: Resolve::<Comment>::SPECIALIZED,
                            abort: Resolve::<Comment>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_update_put_fn_form_6504327009724034363 as rocket_uri_macro_update_put_fn_form;
    async fn delete_fn(
        db: Db,
        id: i32,
        auth_user: <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudResult<::rocket::serde::json::Value> {
        let row = db
            .run(move |conn| {
                crate::schema::comments::table
                    .find(id)
                    .first::<Comment>(conn)
            })
            .await?;
        if !<Comment as ::rp1::CheckPermissions>::allow_delete(&row, &auth_user) {
            return Err(::rp1::CrudError::NotFound);
        }
        let deleted = db
            .run(move |conn| diesel::delete(crate::schema::comments::table.find(id)).execute(conn))
            .await?;
        Ok(::serde_json::Value::Object({
            let mut object = ::serde_json::Map::new();
            let _ = object.insert(
                ("deleted").into(),
                ::serde_json::to_value(&deleted).unwrap(),
            );
            object
        }))
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct delete_fn {}
    /// Rocket code generated proxy static conversion implementations.
    impl delete_fn {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::comment",
                                                "example/src/main.rs",
                                                69u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::comment",
                                                "example/src/main.rs",
                                                69u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let __rocket_id: i32 = match __req.routed_segment(0usize) {
                        ::std::option::Option::Some(__s) => {
                            match <i32 as ::rocket::request::FromParam>::from_param(__s) {
                                ::std::result::Result::Ok(__v) => __v,
                                ::std::result::Result::Err(__error) => {
                                    return {
                                        {
                                            let lvl = ::log::Level::Warn;
                                            if lvl <= ::log::STATIC_MAX_LEVEL
                                                && lvl <= ::log::max_level()
                                            {
                                                :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , ": " , "` param guard parsed forwarding with error "] , & match (& "id" , & "i32" , & __error) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ;
                                            }
                                        };
                                        ::rocket::outcome::Outcome::Forward(__data)
                                    }
                                }
                            }
                        }
                        ::std::option::Option::None => {
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Internal invariant broken: dyn param not found."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &(
                                            "_",
                                            "rp1_example::comment",
                                            "example/src/main.rs",
                                            72u32,
                                        ),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["Please report this to the Rocket issue tracker."],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &(
                                            "_",
                                            "rp1_example::comment",
                                            "example/src/main.rs",
                                            72u32,
                                        ),
                                    );
                                }
                            };
                            {
                                let lvl = ::log::Level::Error;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &["https://github.com/SergioBenitez/Rocket/issues"],
                                            &match () {
                                                () => [],
                                            },
                                        ),
                                        lvl,
                                        &(
                                            "_",
                                            "rp1_example::comment",
                                            "example/src/main.rs",
                                            72u32,
                                        ),
                                    );
                                }
                            };
                            return ::rocket::outcome::Outcome::Forward(__data);
                        }
                    };
                    let ___responder =
                        delete_fn(__rocket_db, __rocket_id, __rocket_auth_user).await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "delete_fn",
                method: ::rocket::http::Method::Delete,
                uri: "/<id>",
                handler: monomorphized_function,
                format: ::std::option::Option::None,
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<i32>(),
                            type_name: std::any::type_name::<i32>(),
                            parent: None,
                            location: ("example/src/main.rs", 72u32, 9u32),
                            specialized: Resolve::<i32>::SPECIALIZED,
                            abort: Resolve::<i32>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized: Resolve::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Comment>(),
                            type_name: std::any::type_name::<Comment>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 70u32, 8u32),
                            specialized: Resolve::<Comment>::SPECIALIZED,
                            abort: Resolve::<Comment>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        :: rocket :: sentinel :: Sentry { type_id : std :: any :: TypeId :: of :: < :: rp1 :: CrudResult < :: rocket :: serde :: json :: Value > > () , type_name : std :: any :: type_name :: < :: rp1 :: CrudResult < :: rocket :: serde :: json :: Value > > () , parent : None , location : ("example/src/main.rs" , 69u32 , 1u32) , specialized : Resolve :: < :: rp1 :: CrudResult < :: rocket :: serde :: json :: Value > > :: SPECIALIZED , abort : Resolve :: < :: rp1 :: CrudResult < :: rocket :: serde :: json :: Value > > :: abort , }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rocket::serde::json::Value>(),
                            type_name: std::any::type_name::<::rocket::serde::json::Value>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                ::rp1::CrudResult<::rocket::serde::json::Value>,
                            >())),
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized: Resolve::<::rocket::serde::json::Value>::SPECIALIZED,
                            abort: Resolve::<::rocket::serde::json::Value>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_delete_fn_5483576883084669820 as rocket_uri_macro_delete_fn;
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    pub enum SortableFields {
        id,
        content,
        approved,
        post_id,
        anonymous_user,
        created_at,
        updated_at,
    }
    #[allow(non_snake_case)]
    const _: () = {
        #[allow(unused_imports)]
        use ::rocket::http::uncased::AsUncased;
        impl<'__v> ::rocket::form::prelude::FromFormField<'__v> for SortableFields {
            fn from_value(
                __f: ::rocket::form::prelude::ValueField<'__v>,
            ) -> Result<Self, ::rocket::form::prelude::Errors<'__v>> {
                if __f.value.as_uncased() == "id" {
                    return ::std::result::Result::Ok(SortableFields::id);
                }
                if __f.value.as_uncased() == "content" {
                    return ::std::result::Result::Ok(SortableFields::content);
                }
                if __f.value.as_uncased() == "approved" {
                    return ::std::result::Result::Ok(SortableFields::approved);
                }
                if __f.value.as_uncased() == "post_id" {
                    return ::std::result::Result::Ok(SortableFields::post_id);
                }
                if __f.value.as_uncased() == "anonymous_user" {
                    return ::std::result::Result::Ok(SortableFields::anonymous_user);
                }
                if __f.value.as_uncased() == "created_at" {
                    return ::std::result::Result::Ok(SortableFields::created_at);
                }
                if __f.value.as_uncased() == "updated_at" {
                    return ::std::result::Result::Ok(SortableFields::updated_at);
                }
                const OPTS: &'static [::std::borrow::Cow<'static, str>] = &[
                    ::std::borrow::Cow::Borrowed("id"),
                    ::std::borrow::Cow::Borrowed("content"),
                    ::std::borrow::Cow::Borrowed("approved"),
                    ::std::borrow::Cow::Borrowed("post_id"),
                    ::std::borrow::Cow::Borrowed("anonymous_user"),
                    ::std::borrow::Cow::Borrowed("created_at"),
                    ::std::borrow::Cow::Borrowed("updated_at"),
                ];
                let _error = ::rocket::form::prelude::Error::from(OPTS)
                    .with_name(__f.name)
                    .with_value(__f.value);
                ::std::result::Result::Err(_error)?
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::fmt::Debug for SortableFields {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&SortableFields::id,) => ::core::fmt::Formatter::write_str(f, "id"),
                (&SortableFields::content,) => ::core::fmt::Formatter::write_str(f, "content"),
                (&SortableFields::approved,) => ::core::fmt::Formatter::write_str(f, "approved"),
                (&SortableFields::post_id,) => ::core::fmt::Formatter::write_str(f, "post_id"),
                (&SortableFields::anonymous_user,) => {
                    ::core::fmt::Formatter::write_str(f, "anonymous_user")
                }
                (&SortableFields::created_at,) => {
                    ::core::fmt::Formatter::write_str(f, "created_at")
                }
                (&SortableFields::updated_at,) => {
                    ::core::fmt::Formatter::write_str(f, "updated_at")
                }
            }
        }
    }
    use ::rocket::request::{self, Request, FromRequest};
    pub struct CommentFilterSpec {
        id: Vec<::rp1::FilterOperator<i32>>,
        content: Vec<::rp1::FilterOperator<String>>,
        approved: Vec<::rp1::FilterOperator<bool>>,
        post_id: Vec<::rp1::FilterOperator<i32>>,
        user_id: Vec<::rp1::FilterOperator<Option<i32>>>,
        anonymous_user: Vec<::rp1::FilterOperator<Option<String>>>,
        created_at: Vec<::rp1::FilterOperator<rp1::datetime::OffsetDateTime>>,
        updated_at: Vec<::rp1::FilterOperator<rp1::datetime::OffsetDateTime>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for CommentFilterSpec {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                CommentFilterSpec {
                    id: ref __self_0_0,
                    content: ref __self_0_1,
                    approved: ref __self_0_2,
                    post_id: ref __self_0_3,
                    user_id: ref __self_0_4,
                    anonymous_user: ref __self_0_5,
                    created_at: ref __self_0_6,
                    updated_at: ref __self_0_7,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "CommentFilterSpec");
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "id", &&(*__self_0_0));
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "content",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "approved",
                        &&(*__self_0_2),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "post_id",
                        &&(*__self_0_3),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "user_id",
                        &&(*__self_0_4),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "anonymous_user",
                        &&(*__self_0_5),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "created_at",
                        &&(*__self_0_6),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "updated_at",
                        &&(*__self_0_7),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::rp1::CrudFilterSpec for Comment {
        type FilterSpecType = CommentFilterSpec;
    }
    impl Default for CommentFilterSpec {
        fn default() -> CommentFilterSpec {
            CommentFilterSpec {
                id: ::alloc::vec::Vec::new(),
                content: ::alloc::vec::Vec::new(),
                approved: ::alloc::vec::Vec::new(),
                post_id: ::alloc::vec::Vec::new(),
                user_id: ::alloc::vec::Vec::new(),
                anonymous_user: ::alloc::vec::Vec::new(),
                created_at: ::alloc::vec::Vec::new(),
                updated_at: ::alloc::vec::Vec::new(),
            }
        }
    }
    #[doc(hidden)]
    pub struct FilterSpecContext<'r> {
        spec: CommentFilterSpec,
        errors: ::rocket::form::Errors<'r>,
    }
    impl<'r> FilterSpecContext<'r> {
        fn push(&mut self, mut field_name: rocket::form::name::NameView<'r>, value: &'r str) {
            use std::convert::{TryFrom, TryInto};
            let field_filtered = match field_name.key() {
                Some(k) => k,
                None => {
                    self.errors
                        .push(::rocket::form::error::ErrorKind::Unexpected.into());
                    return;
                }
            };
            field_name.shift();
            let field_operator = field_name.key().map(|k| k.as_str()).unwrap_or("eq");
            match field_filtered.as_str() {
                "id" => match ::rp1::FilterOperator::try_parse(field_operator, value) {
                    Ok(v) => self.spec.id.push(v),
                    Err(e) => self.errors.push(::rp1::ParseError::from(e).into()),
                },
                "content" => match ::rp1::FilterOperator::try_parse(field_operator, value) {
                    Ok(v) => self.spec.content.push(v),
                    Err(e) => self.errors.push(::rp1::ParseError::from(e).into()),
                },
                "approved" => match ::rp1::FilterOperator::try_parse(field_operator, value) {
                    Ok(v) => self.spec.approved.push(v),
                    Err(e) => self.errors.push(::rp1::ParseError::from(e).into()),
                },
                "post_id" => match ::rp1::FilterOperator::try_parse(field_operator, value) {
                    Ok(v) => self.spec.post_id.push(v),
                    Err(e) => self.errors.push(::rp1::ParseError::from(e).into()),
                },
                "user_id" => {
                    if value == "" {
                        match ::rp1::FilterOperator::from_none(field_operator) {
                            Ok(v) => self.spec.user_id.push(v),
                            Err(e) => self.errors.push(::rp1::ParseError::from(e).into()),
                        }
                    } else {
                        match ::rp1::FilterOperator::try_parse_option(field_operator, value) {
                            Ok(v) => self.spec.user_id.push(v),
                            Err(e) => self.errors.push(::rp1::ParseError::from(e).into()),
                        }
                    }
                }
                "anonymous_user" => {
                    if value == "" {
                        match ::rp1::FilterOperator::from_none(field_operator) {
                            Ok(v) => self.spec.anonymous_user.push(v),
                            Err(e) => self.errors.push(::rp1::ParseError::from(e).into()),
                        }
                    } else {
                        match ::rp1::FilterOperator::try_parse_option(field_operator, value) {
                            Ok(v) => self.spec.anonymous_user.push(v),
                            Err(e) => self.errors.push(::rp1::ParseError::from(e).into()),
                        }
                    }
                }
                "created_at" => match ::rp1::FilterOperator::try_parse(field_operator, value) {
                    Ok(v) => self.spec.created_at.push(v),
                    Err(e) => self.errors.push(::rp1::ParseError::from(e).into()),
                },
                "updated_at" => match ::rp1::FilterOperator::try_parse(field_operator, value) {
                    Ok(v) => self.spec.updated_at.push(v),
                    Err(e) => self.errors.push(::rp1::ParseError::from(e).into()),
                },
                _ => {
                    self.errors
                        .push(::rocket::form::error::ErrorKind::Unexpected.into());
                }
            };
        }
    }
    impl<'r> ::rocket::form::FromForm<'r> for CommentFilterSpec {
        type Context = FilterSpecContext<'r>;
        fn init(opts: ::rocket::form::Options) -> Self::Context {
            FilterSpecContext {
                spec: Default::default(),
                errors: ::rocket::form::Errors::new(),
            }
        }
        fn push_value(ctxt: &mut Self::Context, field: ::rocket::form::ValueField<'r>) {
            ctxt.push(field.name, field.value);
        }
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn push_data<'life0, 'life1, 'async_trait>(
            ctxt: &'life0 mut Self::Context,
            field: ::rocket::form::DataField<'r, 'life1>,
        ) -> ::core::pin::Pin<
            Box<dyn ::core::future::Future<Output = ()> + ::core::marker::Send + 'async_trait>,
        >
        where
            'r: 'async_trait,
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                let ctxt = ctxt;
                let field = field;
                let _: () = {
                    use rocket::data::ToByteUnit;
                    let limit = 256.kibibytes();
                    let bytes = match field.data.open(limit).into_bytes().await {
                        Ok(b) => b,
                        Err(e) => {
                            ctxt.errors.push(e.into());
                            return;
                        }
                    };
                    if !bytes.is_complete() {
                        ctxt.errors
                            .push(rocket::form::error::ErrorKind::from((None, Some(limit))).into());
                        return;
                    }
                    let bytes = bytes.into_inner();
                    let bytes = {
                        struct Local<T>(T);
                        &field.request.local_cache(move || Local(bytes)).0
                    };
                    let data = match std::str::from_utf8(bytes) {
                        Ok(d) => d.into(),
                        Err(e) => {
                            ctxt.errors.push(e.into());
                            return;
                        }
                    };
                    ctxt.push(field.name, data);
                };
            })
        }
        fn finalize(ctxt: Self::Context) -> ::rocket::form::Result<'r, Self> {
            if ctxt.errors.is_empty() {
                Ok(ctxt.spec)
            } else {
                Err(ctxt.errors)
            }
        }
    }
    async fn list_fn(
        db: Db,
        sort: Vec<::rp1::SortSpec<SortableFields>>,
        filter: CommentFilterSpec,
        offset: Option<i64>,
        limit: Option<i64>,
        auth_user: <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
    ) -> ::rp1::CrudJsonResult<Vec<Comment>> {
        let offset = i64::max(0, offset.unwrap_or(0));
        let limit = i64::max(1, i64::min(100i64, limit.unwrap_or(100i64)));
        let results = db
            .run(move |conn| {
                use ::rp1::SortDirection;
                use ::diesel::expression::Expression;
                let mut query = crate::schema::comments::table
                    .offset(offset)
                    .limit(limit)
                    .into_boxed();
                for sort_spec in sort {
                    match sort_spec.field {
                        SortableFields::id => {
                            query = if sort_spec.direction == SortDirection::Asc {
                                query.then_order_by(crate::schema::comments::columns::id.asc())
                            } else {
                                query.then_order_by(crate::schema::comments::columns::id.desc())
                            };
                        }
                        SortableFields::content => {
                            query = if sort_spec.direction == SortDirection::Asc {
                                query.then_order_by(crate::schema::comments::columns::content.asc())
                            } else {
                                query
                                    .then_order_by(crate::schema::comments::columns::content.desc())
                            };
                        }
                        SortableFields::approved => {
                            query = if sort_spec.direction == SortDirection::Asc {
                                query
                                    .then_order_by(crate::schema::comments::columns::approved.asc())
                            } else {
                                query.then_order_by(
                                    crate::schema::comments::columns::approved.desc(),
                                )
                            };
                        }
                        SortableFields::post_id => {
                            query = if sort_spec.direction == SortDirection::Asc {
                                query.then_order_by(crate::schema::comments::columns::post_id.asc())
                            } else {
                                query
                                    .then_order_by(crate::schema::comments::columns::post_id.desc())
                            };
                        }
                        SortableFields::anonymous_user => {
                            query = if sort_spec.direction == SortDirection::Asc {
                                query.then_order_by(
                                    crate::schema::comments::columns::anonymous_user.asc(),
                                )
                            } else {
                                query.then_order_by(
                                    crate::schema::comments::columns::anonymous_user.desc(),
                                )
                            };
                        }
                        SortableFields::created_at => {
                            query = if sort_spec.direction == SortDirection::Asc {
                                query.then_order_by(
                                    crate::schema::comments::columns::created_at.asc(),
                                )
                            } else {
                                query.then_order_by(
                                    crate::schema::comments::columns::created_at.desc(),
                                )
                            };
                        }
                        SortableFields::updated_at => {
                            query = if sort_spec.direction == SortDirection::Asc {
                                query.then_order_by(
                                    crate::schema::comments::columns::updated_at.asc(),
                                )
                            } else {
                                query.then_order_by(
                                    crate::schema::comments::columns::updated_at.desc(),
                                )
                            };
                        }
                    }
                }
                for op in filter.id.iter() {
                    use ::rp1::FilterOperator;
                    use crate::schema::comments::columns;
                    query = match op {
                        FilterOperator::Eq(val) => query.filter(columns::id.eq(val)),
                        FilterOperator::Ne(val) => query.filter(columns::id.ne(val)),
                        FilterOperator::Gt(val) => query.filter(columns::id.gt(val)),
                        FilterOperator::Ge(val) => query.filter(columns::id.ge(val)),
                        FilterOperator::Lt(val) => query.filter(columns::id.lt(val)),
                        FilterOperator::Le(val) => query.filter(columns::id.le(val)),
                        FilterOperator::EqAny(val) => query.filter(columns::id.eq_any(val)),
                    };
                }
                for op in filter.content.iter() {
                    use ::rp1::FilterOperator;
                    use crate::schema::comments::columns;
                    query = match op {
                        FilterOperator::Eq(val) => query.filter(columns::content.eq(val)),
                        FilterOperator::Ne(val) => query.filter(columns::content.ne(val)),
                        FilterOperator::Gt(val) => query.filter(columns::content.gt(val)),
                        FilterOperator::Ge(val) => query.filter(columns::content.ge(val)),
                        FilterOperator::Lt(val) => query.filter(columns::content.lt(val)),
                        FilterOperator::Le(val) => query.filter(columns::content.le(val)),
                        FilterOperator::EqAny(val) => query.filter(columns::content.eq_any(val)),
                    };
                }
                for op in filter.approved.iter() {
                    use ::rp1::FilterOperator;
                    use crate::schema::comments::columns;
                    query = match op {
                        FilterOperator::Eq(val) => query.filter(columns::approved.eq(val)),
                        FilterOperator::Ne(val) => query.filter(columns::approved.ne(val)),
                        FilterOperator::Gt(val) => query.filter(columns::approved.gt(val)),
                        FilterOperator::Ge(val) => query.filter(columns::approved.ge(val)),
                        FilterOperator::Lt(val) => query.filter(columns::approved.lt(val)),
                        FilterOperator::Le(val) => query.filter(columns::approved.le(val)),
                        FilterOperator::EqAny(val) => query.filter(columns::approved.eq_any(val)),
                    };
                }
                for op in filter.post_id.iter() {
                    use ::rp1::FilterOperator;
                    use crate::schema::comments::columns;
                    query = match op {
                        FilterOperator::Eq(val) => query.filter(columns::post_id.eq(val)),
                        FilterOperator::Ne(val) => query.filter(columns::post_id.ne(val)),
                        FilterOperator::Gt(val) => query.filter(columns::post_id.gt(val)),
                        FilterOperator::Ge(val) => query.filter(columns::post_id.ge(val)),
                        FilterOperator::Lt(val) => query.filter(columns::post_id.lt(val)),
                        FilterOperator::Le(val) => query.filter(columns::post_id.le(val)),
                        FilterOperator::EqAny(val) => query.filter(columns::post_id.eq_any(val)),
                    };
                }
                for op in filter.user_id.iter() {
                    use ::rp1::FilterOperator;
                    use crate::schema::comments::columns;
                    query = match op {
                        FilterOperator::Eq(val) => query.filter(columns::user_id.eq(val)),
                        FilterOperator::Ne(val) => query.filter(columns::user_id.ne(val)),
                        FilterOperator::Gt(val) => query.filter(columns::user_id.gt(val)),
                        FilterOperator::Ge(val) => query.filter(columns::user_id.ge(val)),
                        FilterOperator::Lt(val) => query.filter(columns::user_id.lt(val)),
                        FilterOperator::Le(val) => query.filter(columns::user_id.le(val)),
                        FilterOperator::EqAny(val) => query.filter(columns::user_id.eq_any(val)),
                    };
                }
                for op in filter.anonymous_user.iter() {
                    use ::rp1::FilterOperator;
                    use crate::schema::comments::columns;
                    query = match op {
                        FilterOperator::Eq(val) => query.filter(columns::anonymous_user.eq(val)),
                        FilterOperator::Ne(val) => query.filter(columns::anonymous_user.ne(val)),
                        FilterOperator::Gt(val) => query.filter(columns::anonymous_user.gt(val)),
                        FilterOperator::Ge(val) => query.filter(columns::anonymous_user.ge(val)),
                        FilterOperator::Lt(val) => query.filter(columns::anonymous_user.lt(val)),
                        FilterOperator::Le(val) => query.filter(columns::anonymous_user.le(val)),
                        FilterOperator::EqAny(val) => {
                            query.filter(columns::anonymous_user.eq_any(val))
                        }
                    };
                }
                for op in filter.created_at.iter() {
                    use ::rp1::FilterOperator;
                    use crate::schema::comments::columns;
                    query = match op {
                        FilterOperator::Eq(val) => query.filter(columns::created_at.eq(val)),
                        FilterOperator::Ne(val) => query.filter(columns::created_at.ne(val)),
                        FilterOperator::Gt(val) => query.filter(columns::created_at.gt(val)),
                        FilterOperator::Ge(val) => query.filter(columns::created_at.ge(val)),
                        FilterOperator::Lt(val) => query.filter(columns::created_at.lt(val)),
                        FilterOperator::Le(val) => query.filter(columns::created_at.le(val)),
                        FilterOperator::EqAny(val) => query.filter(columns::created_at.eq_any(val)),
                    };
                }
                for op in filter.updated_at.iter() {
                    use ::rp1::FilterOperator;
                    use crate::schema::comments::columns;
                    query = match op {
                        FilterOperator::Eq(val) => query.filter(columns::updated_at.eq(val)),
                        FilterOperator::Ne(val) => query.filter(columns::updated_at.ne(val)),
                        FilterOperator::Gt(val) => query.filter(columns::updated_at.gt(val)),
                        FilterOperator::Ge(val) => query.filter(columns::updated_at.ge(val)),
                        FilterOperator::Lt(val) => query.filter(columns::updated_at.lt(val)),
                        FilterOperator::Le(val) => query.filter(columns::updated_at.le(val)),
                        FilterOperator::EqAny(val) => query.filter(columns::updated_at.eq_any(val)),
                    };
                }
                let filter = <Comment as ::rp1::CheckPermissions>::filter_list(&auth_user);
                let query = filter.apply(query);
                query.map(|q| q.load(conn))
            })
            .await
            .ok_or_else(|| ::rp1::CrudError::Forbidden)??;
        Ok(::rocket::serde::json::Json(results))
    }
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// Rocket code generated proxy structure.
    struct list_fn {}
    /// Rocket code generated proxy static conversion implementations.
    impl list_fn {
        #[allow(non_snake_case, unreachable_patterns, unreachable_code)]
        fn into_info(self) -> ::rocket::route::StaticInfo {
            fn monomorphized_function<'__r>(
                __req: &'__r ::rocket::request::Request<'_>,
                __data: ::rocket::data::Data<'__r>,
            ) -> ::rocket::route::BoxFuture<'__r> {
                ::std::boxed::Box::pin(async move {
                    let __rocket_db: Db =
                        match <Db as ::rocket::request::FromRequest>::from_request(__req).await {
                            ::rocket::outcome::Outcome::Success(__v) => __v,
                            ::rocket::outcome::Outcome::Forward(_) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard is forwarding."],
                                                &match (&"Db",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::comment",
                                                "example/src/main.rs",
                                                69u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Forward(__data);
                            }
                            ::rocket::outcome::Outcome::Failure((__c, __e)) => {
                                {
                                    let lvl = ::log::Level::Warn;
                                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                        ::log::__private_api_log(
                                            ::core::fmt::Arguments::new_v1(
                                                &["`", "` request guard failed: ", "."],
                                                &match (&"Db", &__e) {
                                                    (arg0, arg1) => [
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        ),
                                                        ::core::fmt::ArgumentV1::new(
                                                            arg1,
                                                            ::core::fmt::Debug::fmt,
                                                        ),
                                                    ],
                                                },
                                            ),
                                            lvl,
                                            &(
                                                "_",
                                                "rp1_example::comment",
                                                "example/src/main.rs",
                                                69u32,
                                            ),
                                        );
                                    }
                                };
                                return ::rocket::outcome::Outcome::Failure(__c);
                            }
                        };
                    let __rocket_auth_user : < Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser = match < < Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser as :: rocket :: request :: FromRequest > :: from_request (__req) . await { :: rocket :: outcome :: Outcome :: Success (__v) => __v , :: rocket :: outcome :: Outcome :: Forward (_) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard is forwarding."] , & match (& "< Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Forward (__data) ; } :: rocket :: outcome :: Outcome :: Failure ((__c , __e)) => { { let lvl = :: log :: Level :: Warn ; if lvl <= :: log :: STATIC_MAX_LEVEL && lvl <= :: log :: max_level () { :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["`" , "` request guard failed: " , "."] , & match (& "< Comment as :: rp1 :: access_control :: CheckPermissions > :: AuthUser" , & __e) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }) , lvl , & ("_" , "rp1_example::comment" , "example/src/main.rs" , 69u32)) ; } } ; return :: rocket :: outcome :: Outcome :: Failure (__c) ; } } ;
                    let mut __e = ::rocket::form::prelude::Errors::new();
                    let mut __rocket_sort =
                        <Vec<::rp1::SortSpec<SortableFields>> as ::rocket::form::FromForm>::init(
                            ::rocket::form::prelude::Options::Lenient,
                        );
                    let mut __rocket_offset = <Option<i64> as ::rocket::form::FromForm>::init(
                        ::rocket::form::prelude::Options::Lenient,
                    );
                    let mut __rocket_limit = <Option<i64> as ::rocket::form::FromForm>::init(
                        ::rocket::form::prelude::Options::Lenient,
                    );
                    let mut __rocket_filter = <CommentFilterSpec as ::rocket::form::FromForm>::init(
                        ::rocket::form::prelude::Options::Lenient,
                    );
                    for _f in __req.query_fields() {
                        let _raw = (_f.name.source().as_str(), _f.value);
                        let _key = _f.name.key_lossy().as_str();
                        match (_raw , _key) { (_ , "sort") => < Vec < :: rp1 :: SortSpec < SortableFields > > as :: rocket :: form :: FromForm > :: push_value (& mut __rocket_sort , _f . shift ()) , (_ , "offset") => < Option < i64 > as :: rocket :: form :: FromForm > :: push_value (& mut __rocket_offset , _f . shift ()) , (_ , "limit") => < Option < i64 > as :: rocket :: form :: FromForm > :: push_value (& mut __rocket_limit , _f . shift ()) , (_ , "filter") => < CommentFilterSpec as :: rocket :: form :: FromForm > :: push_value (& mut __rocket_filter , _f . shift ()) , _ => { } }
                    }
                    let __rocket_sort = match < Vec < :: rp1 :: SortSpec < SortableFields > > as :: rocket :: form :: FromForm > :: finalize (__rocket_sort) { :: std :: result :: Result :: Ok (_v) => :: std :: option :: Option :: Some (_v) , :: std :: result :: Result :: Err (_err) => { __e . extend (_err . with_name (:: rocket :: form :: prelude :: NameView :: new ("sort"))) ; :: std :: option :: Option :: None } } ;
                    let __rocket_offset = match <Option<i64> as ::rocket::form::FromForm>::finalize(
                        __rocket_offset,
                    ) {
                        ::std::result::Result::Ok(_v) => ::std::option::Option::Some(_v),
                        ::std::result::Result::Err(_err) => {
                            __e.extend(
                                _err.with_name(::rocket::form::prelude::NameView::new("offset")),
                            );
                            ::std::option::Option::None
                        }
                    };
                    let __rocket_limit =
                        match <Option<i64> as ::rocket::form::FromForm>::finalize(__rocket_limit) {
                            ::std::result::Result::Ok(_v) => ::std::option::Option::Some(_v),
                            ::std::result::Result::Err(_err) => {
                                __e.extend(
                                    _err.with_name(::rocket::form::prelude::NameView::new("limit")),
                                );
                                ::std::option::Option::None
                            }
                        };
                    let __rocket_filter =
                        match <CommentFilterSpec as ::rocket::form::FromForm>::finalize(
                            __rocket_filter,
                        ) {
                            ::std::result::Result::Ok(_v) => ::std::option::Option::Some(_v),
                            ::std::result::Result::Err(_err) => {
                                __e.extend(
                                    _err.with_name(::rocket::form::prelude::NameView::new(
                                        "filter",
                                    )),
                                );
                                ::std::option::Option::None
                            }
                        };
                    if !__e.is_empty() {
                        {
                            let lvl = ::log::Level::Warn;
                            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                ::log::__private_api_log(
                                    ::core::fmt::Arguments::new_v1(
                                        &["query string failed to match declared route"],
                                        &match () {
                                            () => [],
                                        },
                                    ),
                                    lvl,
                                    &("_", "rp1_example::comment", "example/src/main.rs", 69u32),
                                );
                            }
                        };
                        for _err in __e {
                            {
                                let lvl = ::log::Level::Warn;
                                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                    ::log::__private_api_log(
                                        ::core::fmt::Arguments::new_v1(
                                            &[""],
                                            &match (&_err,) {
                                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                                    arg0,
                                                    ::core::fmt::Display::fmt,
                                                )],
                                            },
                                        ),
                                        lvl,
                                        &(
                                            "_",
                                            "rp1_example::comment",
                                            "example/src/main.rs",
                                            69u32,
                                        ),
                                    );
                                }
                            };
                        }
                        return ::rocket::outcome::Outcome::Forward(__data);
                    }
                    let __rocket_sort = __rocket_sort.unwrap();
                    let __rocket_offset = __rocket_offset.unwrap();
                    let __rocket_limit = __rocket_limit.unwrap();
                    let __rocket_filter = __rocket_filter.unwrap();
                    let ___responder = list_fn(
                        __rocket_db,
                        __rocket_sort,
                        __rocket_filter,
                        __rocket_offset,
                        __rocket_limit,
                        __rocket_auth_user,
                    )
                    .await;
                    ::rocket::route::Outcome::from(__req, ___responder)
                })
            }
            ::rocket::route::StaticInfo {
                name: "list_fn",
                method: ::rocket::http::Method::Get,
                uri: "/?<sort>&<offset>&<limit>&<filter>",
                handler: monomorphized_function,
                format: ::std::option::Option::None,
                rank: ::std::option::Option::None,
                sentinels: <[_]>::into_vec(box [
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Vec<::rp1::SortSpec<SortableFields>>>(),
                            type_name: std::any::type_name::<Vec<::rp1::SortSpec<SortableFields>>>(
                            ),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized:
                                Resolve::<Vec<::rp1::SortSpec<SortableFields>>>::SPECIALIZED,
                            abort: Resolve::<Vec<::rp1::SortSpec<SortableFields>>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::SortSpec<SortableFields>>(),
                            type_name: std::any::type_name::<::rp1::SortSpec<SortableFields>>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                Vec<::rp1::SortSpec<SortableFields>>,
                            >())),
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized: Resolve::<::rp1::SortSpec<SortableFields>>::SPECIALIZED,
                            abort: Resolve::<::rp1::SortSpec<SortableFields>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<SortableFields>(),
                            type_name: std::any::type_name::<SortableFields>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                ::rp1::SortSpec<SortableFields>,
                            >())),
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized: Resolve::<SortableFields>::SPECIALIZED,
                            abort: Resolve::<SortableFields>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Option<i64>>(),
                            type_name: std::any::type_name::<Option<i64>>(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized: Resolve::<Option<i64>>::SPECIALIZED,
                            abort: Resolve::<Option<i64>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<i64>(),
                            type_name: std::any::type_name::<i64>(),
                            parent: None.or(Some(std::any::TypeId::of::<Option<i64>>())),
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized: Resolve::<i64>::SPECIALIZED,
                            abort: Resolve::<i64>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Option<i64>>(),
                            type_name: std::any::type_name::<Option<i64>>(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized: Resolve::<Option<i64>>::SPECIALIZED,
                            abort: Resolve::<Option<i64>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<i64>(),
                            type_name: std::any::type_name::<i64>(),
                            parent: None.or(Some(std::any::TypeId::of::<Option<i64>>())),
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized: Resolve::<i64>::SPECIALIZED,
                            abort: Resolve::<i64>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<CommentFilterSpec>(),
                            type_name: std::any::type_name::<CommentFilterSpec>(),
                            parent: None,
                            location: ("example/src/main.rs", 70u32, 8u32),
                            specialized: Resolve::<CommentFilterSpec>::SPECIALIZED,
                            abort: Resolve::<CommentFilterSpec>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Db>(),
                            type_name: std::any::type_name::<Db>(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 24u32),
                            specialized: Resolve::<Db>::SPECIALIZED,
                            abort: Resolve::<Db>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            type_name: std::any::type_name::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized: Resolve::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::SPECIALIZED,
                            abort: Resolve::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Comment>(),
                            type_name: std::any::type_name::<Comment>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                <Comment as ::rp1::access_control::CheckPermissions>::AuthUser,
                            >())),
                            location: ("example/src/main.rs", 70u32, 8u32),
                            specialized: Resolve::<Comment>::SPECIALIZED,
                            abort: Resolve::<Comment>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<::rp1::CrudJsonResult<Vec<Comment>>>(),
                            type_name: std::any::type_name::<::rp1::CrudJsonResult<Vec<Comment>>>(),
                            parent: None,
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized:
                                Resolve::<::rp1::CrudJsonResult<Vec<Comment>>>::SPECIALIZED,
                            abort: Resolve::<::rp1::CrudJsonResult<Vec<Comment>>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Vec<Comment>>(),
                            type_name: std::any::type_name::<Vec<Comment>>(),
                            parent: None.or(Some(std::any::TypeId::of::<
                                ::rp1::CrudJsonResult<Vec<Comment>>,
                            >())),
                            location: ("example/src/main.rs", 69u32, 1u32),
                            specialized: Resolve::<Vec<Comment>>::SPECIALIZED,
                            abort: Resolve::<Vec<Comment>>::abort,
                        }
                    },
                    {
                        #[allow(unused_imports)]
                        use ::rocket::sentinel::resolution::{Resolve, DefaultSentinel as _};
                        ::rocket::sentinel::Sentry {
                            type_id: std::any::TypeId::of::<Comment>(),
                            type_name: std::any::type_name::<Comment>(),
                            parent: None.or(Some(std::any::TypeId::of::<Vec<Comment>>())),
                            location: ("example/src/main.rs", 70u32, 8u32),
                            specialized: Resolve::<Comment>::SPECIALIZED,
                            abort: Resolve::<Comment>::abort,
                        }
                    },
                ]),
            }
        }
        #[doc(hidden)]
        pub fn into_route(self) -> ::rocket::Route {
            self.into_info().into()
        }
    }
    #[doc(hidden)]
    pub use rocket_uri_macro_list_fn_11092859169431448817 as rocket_uri_macro_list_fn;
    impl Comment {
        pub fn get_routes() -> Vec<::rocket::Route> {
            {
                let ___vec: ::std::vec::Vec<::rocket::Route> = <[_]>::into_vec(box [
                    {
                        let ___struct = create_fn_form {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                    {
                        let ___struct = create_fn_json {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                    {
                        let ___struct = read_fn {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                    {
                        let ___struct = update_patch_fn_json {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                    {
                        let ___struct = update_patch_fn_form {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                    {
                        let ___struct = update_put_fn_json {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                    {
                        let ___struct = update_put_fn_form {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                    {
                        let ___struct = delete_fn {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                    {
                        let ___struct = list_fn {};
                        let ___item: ::rocket::Route = ___struct.into_route();
                        ___item
                    },
                ]);
                ___vec
            }
        }
    }
    impl ::rp1::CrudStruct for Comment {
        type TableType = crate::schema::comments::table;
    }
}
use self::comment::Comment;
#[allow(dead_code)]
fn rocket() -> ::rocket::Rocket<::rocket::Build> {
    rocket::build()
        .mount("/users", User::get_routes())
        .mount("/posts", Post::get_routes())
        .mount("/comments", Comment::get_routes())
        .attach(Db::fairing())
}
fn main() {
    ::rocket::async_main(async move {
        let _res = {
            let ___rocket: ::rocket::Rocket<::rocket::Build> = {
                rocket::build()
                    .mount("/users", User::get_routes())
                    .mount("/posts", Post::get_routes())
                    .mount("/comments", Comment::get_routes())
                    .attach(Db::fairing())
            };
            let ___rocket: ::rocket::Rocket<::rocket::Build> = ___rocket;
            ___rocket
        }
        .launch()
        .await;
    })
}
pub enum AUser {
    LoggedIn(User),
    Anonymous,
}
use rocket::request::{FromRequest, Outcome, Request};
impl<'r> FromRequest<'r> for AUser {
    type Error = std::convert::Infallible;
    #[allow(
        clippy::let_unit_value,
        clippy::type_complexity,
        clippy::type_repetition_in_bounds,
        clippy::used_underscore_binding
    )]
    fn from_request<'life0, 'async_trait>(
        req: &'r Request<'life0>,
    ) -> ::core::pin::Pin<
        Box<
            dyn ::core::future::Future<Output = Outcome<Self, Self::Error>>
                + ::core::marker::Send
                + 'async_trait,
        >,
    >
    where
        'r: 'async_trait,
        'life0: 'async_trait,
        Self: 'async_trait,
    {
        Box::pin(async move {
            if let ::core::option::Option::Some(__ret) =
                ::core::option::Option::None::<Outcome<Self, Self::Error>>
            {
                return __ret;
            }
            let req = req;
            let __ret: Outcome<Self, Self::Error> = {
                use diesel::prelude::*;
                match req.headers().get_one("X-UNSAFE-USER-ID") {
                    Some(user_id_str) => {
                        let db = <Db as FromRequest>::from_request(req).await.unwrap();
                        let user_id: i32 = user_id_str.parse().unwrap();
                        let user: User = db
                            .run(move |conn| {
                                schema::users::table
                                    .find(user_id)
                                    .first::<User>(conn)
                                    .unwrap()
                            })
                            .await;
                        Outcome::Success(AUser::LoggedIn(user))
                    }
                    None => Outcome::Success(AUser::Anonymous),
                }
            };
            #[allow(unreachable_code)]
            __ret
        })
    }
}
